{"posts":[{"title":"User Guide","text":"Python玩转自动化运维-成长路径 专注于自动化运维领域，帮助任何想将编程与运维相结合的朋友，从零开始引领大家走进运维自动化。 内容受众你是否已经决定走上了运维工程师的道路，或者是深耕运维多年的老手； 升职加薪一直与自己绝缘，还总是锅从天上来； 看着别人自动化运维搞得风生水起，自己巡检两台设备的时间别人已经巡检好了一百台设备，还顺带出了个报表，你迷茫了； 人往往很难跳出自己的舒适圈，对于之前没有涉足过的领域也很难找到合适的切入点，再加上平时的工作已经足够焦头烂额，没有时间去从零开始学一门新技术。 内容定位并不为了单纯的输出枯燥的知识点，区别于其他资料的随意搬运，东一榔头西一棒子； 而是从场景出发，使输出的内容具有实操性，自顶向下将具体场景拆分，并落实到每个知识点，让同学清晰的意识到所学知识能够如何运用； 让运维老手掌握平时经常听到的 Netmiko, SNMP, Netconf等知识，能够学有所得，学能所用； 番外篇会将正篇中涉及到的细节逐一展开，让计算机专业同学能够深入理解，夯实基础，逐步掌握操作系统，数据结构等专业知识； 并且也会涉及到编程思想，学习方法论等技巧，让大家有挑战大厂的底气。 路径的选择对于正在从事运维工作，但工作中遇到了一些自动化的需求的朋友，那么这里作者并不提倡大家去构建整个的自动化运维体系，一个是没有必要，另一个是这也可能会消耗相当大的精力，所以我们就暂时只点与自己实际工作相关的技能即可，全部的技能树如下图所示： 路径的规划一、【自动化运维新手村】那么对于自动化运维来说肯定首推的编程语言就是Python。 但网上对于Python语言的教程一抓一大把，我为什么还要在这里去讲解呢？这其实等同于另一个问题：刚接触编程的人是否能通过看类似的教程快速上手Python? 或者通俗易懂的讲：是不是能看得懂? 大部分从事运维工作的朋友可能都没有编程经验，也没有系统的学习过计算机底层原理，所以对于标准式的教程就会感觉，好像会了，但又没有全会；好像会了，但又不会用，所以我根据自己的学习方法再加上身边运维朋友们的学习经历，通过一些生动的例子和实际的场景来让大家快速的上手Python这门语言，并且能直接运用于实际工作中。 新手村的内容主要是为大家搭建一个简易的CMDB（资产管理），这也符合很多运维朋友的实际需求场景，比如想要做一个小功能，可以提供给其他人使用。除此之外也会对其中涉及到的部分知识点进行详细的深入挖掘，呈现在番外篇中，让对其感兴趣的读者朋友去更多的了解。 Python基本数据结构和操作 将CMDB的增删改查与Python数据结构相结合，将枯燥的基础知识进行深入浅出的讲解 番外：数据结构的详解 番外：字符串的详解 番外：数组的详解 番外：字典的详解 面试番外：算法 Python函数与对象 将如何构建CMDB的函数与对象逐步拆解 番外：深入了解面向对象 番外：设计模式简介 Flask Web框架 将对CMDB的操作与Web框架相结合，通过API的方式对CMDB进行操作 面试番外：计算机网络 MySQL数据库 将CMDB存储到数据库中，对其进行的增删改查从对文件读写转移到对数据库进行操作 番外：MongoDB数据库 面试番外：数据库 Linux部署应用 将应用部署在Linux系统上稳定的运行 面试番外：操作系统 二、【自动化运维初级村】 其实初级村的内容顺序的设计和新手村是类似的，但这一部分所运用的Python知识就会稍微深入，所以建议已经对Python有一定了解的朋友，可以跳过新手村直接看初级村的内容，因为初级村会是更多运维朋友们经常遇到的需求场景，也是做自动化运必须要走的路。 paramiko和netmiko 两者的使用方式及优劣 Python 正则解析 将通过SSH收集回来的各种信息进行正则解析 番外：text-fsm解析 Python snmp 如何使用Python调用SNMP采集指令，并讲解OID使用方式 NetConf 如何通过NetConf对网络设备进行操作 Crontab并回调CMDB 如何设置定时执行SSH任务进行定期巡检，并更新回写CMDB 番外：Python scheduler Flask Web框架 将SSH和NetConf与Web框架相结合，通过API方式或前端调用其执行 三、【自动化运维中级村】 中级村与初级村最大的不同就是，会从简单需求应用的完成，转变为更为复杂架构的设计与实现，以及能够支撑更大型运维的场景。 Celery任务队列 如何使用任务队列异步处理大量的SSH或NetConf执行操作 番外：Redis数据库 番外：RabbitMQ中间件 Rsyslog日志采集 通过Rsyslog收集设备日志并存储进行展示和查询。 Mysql性能优化 支持更大数据量的存储和查询，进行数据库的优化，分库和分表 ELK， Rsyslog - Kafkf - LogStash - ElasticSearch - Kibana 使用ELK套件对日志进行存储及展示 前后端分离 由于系统功能的丰富，需要实现前后端分离的应用。 四、【自动化运维高级村】 如果想要做一个完整的自动化运维系统，就必然需要有相应完善的自动化运维的理念和方法论，所以高级村会设计到更多关于自动化运维的理念介绍，以及更为复杂和适应更大型企业的自动化运维系统。 Celery分时任务队列 使用Celery任务队列，将SNMP大量采集任务或SSH变更任务根据频率发布在不同的队列中进行高效采集 Flink处理 使用Flink对SNMP采集的数据进行清洗并存储 Rsyslog - Kafka - Consumer- MySQL 如何将设备上报的日志进行收集解析，并通过Kafka中间件削峰，并进行存储 番外： Kafka中间件 告警通知，屏蔽，抑制 如何设置告警的通知，屏蔽和抑制机制 任务编排 通过白屏方式将变更步骤注册为执行算子，并进行编排后下发 基于意图的分组配置下发 将设备根据角色分组，并设置基于意图的模板命令，使用SSH或NetConf方式与其结合对网络设备进行变更或查询操作 路径的总结上述的路径梳理是一个目前我能给到大家的较为系统的自动化运维方面的实践，在更新的过程中，我可能会根据读者的需要或者平时的思考总结对内容进行更新迭代，所以说路径并不是固定的，它只是一个学习的方向，并且学习的过程必然是会有阻碍和困难的，希望大家都能有坚定的决心克服一个个的难点，当然也会提供给大家学习交流的群组，供大家互相探讨，互相进步，也欢迎大家有什么疑问都找我咨询。最后期待大家都能拿到属于自己的结果。 欢迎大家添加我的个人公众号【Python玩转自动化运维】加入读者交流群，获取更多干货内容","link":"/posts/5cb4afad.html"},{"title":"freshman-python-basics-1","text":"自动化运维新手村-Python基础-1 摘要 首先说明，以下几类读者朋友们请自行对号入座： 对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读此篇； 了解过Python基本的数据结构，但又没有经常在实践中运用的读者，建议阅读此篇； 已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇； CMDB简介简单赘述以下，CMDB的英文全称是Configuration Management Database，中文名叫配置管理数据库，它几乎贯穿了运维的每个环节。在实际的项目中，CMDB常常被认为是构建其它ITIL(Information Technology Infrastructure Library，IT基础架构库)流程的基础，ITIL项目的成败与是否成功建立CMDB有非常大的关系。 对于一些中大型的互联网公司必然都有自研的CMDB系统，而一些初创公司可能采用开源的CMDB工具或者部分运维工程师日常使用Excel表格充当简易的CMDB功能，我们的目的并不是让大家去构建一个新的CMDB去推翻原有系统，也不是说用Excel表格就不如用Python来的高级，而是能让大家从CMDB自顶向下的拆解，来更生动的体会到Python基础数据结构的运用 CMDBv1.0实现完整的CMDB十分复杂，但作为讲解Python基本数据结构的范例，我们先实现一个简易的1.0版本。 CMDBv1.0只需要通过一个Python脚本就可以做到资产数据的增删改查。 可能会有一些有CMDB使用经验的朋友会有质疑，觉得这也叫CMDB，还请大家稍安勿躁，任何大型系统的构建都是经过日积月累的迭代，但我可以保证，在项目冷启动阶段，这样一个稍微简陋的1.0版本，就可以起到基本的资产管理的作用。 下面假设我们已经有了一个Python脚本，名叫 cmdb-v1.0.py ，我们简单的演示以下它的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141root&gt; # python3 cmdb-v1.0.py init beijing // 初始化beijing IDC{ &quot;beijing&quot;: { &quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: {}, &quot;router&quot;: {} }}root&gt; # python3 cmdb-v1.0.py add /beijing/switch // 添加beijing IDC的IP地址是10.0.0.1的交换机信息{ &quot;beijing&quot;: { &quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: { &quot;10.0.0.1&quot;: { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;], &quot;stack&quot;: true } } }, &quot;router&quot;: {}}root&gt; # python3 cmdb-v1.0.py get /beijing/switch/10.0.0.1 // 读取beijing IDC的IP地址是10.0.0.1的交换机信息{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [ &quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: true}root&gt; # python .\\cmdb-v1.0.py update /beijing/switch/10.0.0.1/hostname '\\&quot;test\\&quot;' // 将 beijing IDC的IP地址是10.0.0.1的交换机主机名修改为 testroot&gt; # python .\\cmdb-v1.0.py get /beijing/switch/10.0.0.1 // 读取验证相关信息{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;test&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [ &quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: true}root&gt; # python .\\cmdb-v1.0.py delete /beijing/switch/10.0.0.1/role // 删除beijing IDC的IP地址是10.0.0.1的交换机的角色属性root&gt; # python .\\cmdb-v1.0.py delete /beijing/switch/10.0.0.1/port '[\\&quot;Eth1/1/0\\&quot;]' // 删除beijing IDC的IP地址是10.0.0.1的交换机端口属性中的 Eth1/1/0root&gt; # python .\\cmdb-v1.0.py get /beijing/switch/10.0.0.1 // 读取验证相关信息{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;test&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;port&quot;: [ &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: true} 上面演示的几个步骤包括了地域的初始化，资产信息的增删改查，大家可以发现整个1.0版本中，数据源的结构是比较清晰的，几乎涉及到了Python中最常用的数据类型，以及不同数据类型的常用操作，所以这也是我想以CMDB为例切入Python的原因。 Python 从笔者个人经历来说，写过Python，Java，Golang，至今仍然觉得Python是一门十分优秀的语言，能够持续霸占最热门语言的前三甲，确实有其独到之处 Python优缺点 优点 简单 免费、开源 高层语言面向对象 可扩展性 丰富的库 缺点 性能，虽然有一部分网友还是对Python颇有微词，但如果非要从Python的众多缺点中挑一个最重要的一点的话，那就是性能问题，但性能问题绝对不是我们弃用Python的原因，目前仍然有诸多方法可以保证Python支持企业级应用平稳运行迭代，而且就连字节如此大体量的公司很多地方都仍然使用Python进行开发 CMDB拆解及Python基本数据类型CMDB 拆解根据上面的演示大家应该已经大概了解CMDBv1.0版本的数据源大概长什么样子了，它的层级的划分其实是根据每个公司不同的实际场景决定的，我们这里就暂且先考虑普适情况，即idc为顶层，其包含了switch和router，然后再包含具体的设备信息和属性，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161{ &quot;beijing&quot;: { &quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: { &quot;10.0.0.1&quot;: { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [ &quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: true }, &quot;10.0.0.2&quot;: { &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-02&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;dsw&quot;, &quot;port&quot;: [ &quot;GEth1/1/0&quot;, &quot;GEth1/1/1&quot;, &quot;GEth1/1/2&quot; ], &quot;stack&quot;: true } }, &quot;router&quot;: { &quot;10.0.0.3&quot;: { &quot;ip&quot;: &quot;10.0.0.3&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;br&quot;, &quot;port&quot;: [ &quot;TGEth1/0/0/1&quot;, &quot;TGEth1/0/0/2&quot;, &quot;TGEth1/0/0/3&quot; ], &quot;bgp_as&quot;: 64512 } } }, &quot;shanghai&quot;: { &quot;idc&quot;: &quot;shanghai&quot;, &quot;switch&quot;: { &quot;10.0.1.1&quot;: { &quot;ip&quot;: &quot;10.0.1.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-01-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [ &quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: false } }, &quot;router&quot;: { &quot;10.0.1.3&quot;: { &quot;ip&quot;: &quot;10.0.1.3&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-01-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;br&quot;, &quot;port&quot;: [ &quot;TGEth1/0/0/1&quot;, &quot;TGEth1/0/0/2&quot;, &quot;TGEth1/0/0/3&quot; ], &quot;bgp_as&quot;: 64512 } } }} 想必很多读者都听过数据结构，构建一个可扩展的CMDB非常需要一个合适的数据结构，当然很多计算机专业的同学应该了解，数据结构是一门十分复杂的学科，无法在短时间内将其讲解清楚，感兴趣的同学可以阅读番外篇详细了解，此处我们先简短的介绍一下需要用到的一些概念： 数据结构（英语：data structure）是计算机中存储、组织数据的方式，不同种类的数据结构适合于不同种类的应用；常见的数据结构有，栈，队列，数组，链表，树，图，堆，散列表=其实我们目前只需要用到数组和散列表(又称哈希表)两种数据结构，我先通俗易懂的讲解一下这两种数据结构 数组， 可以将其理解为一个容器，里面可以装很多元素，只不过这些元素必须是相同类型的, 他们可以用下标的位置进行存取，如 123|a | b | c | d | e | f | g | h | i | j | 0 1 2 3 4 5 6 7 8 9 值得注意的是数组的下标永远都是从0开始，这个对于初期接触编程的读者朋友来说可能会有点儿不适应 散列表，可以将其理解为通讯录，通讯录里的人不可以重名，每个人的名字都对应他的个人信息，个人信息可以存储任何数据，如 123456789101112131415161718192021{ &quot;jack&quot;: &quot;19098090000&quot;, &quot;allen&quot;: { &quot;age&quot;: 20, &quot;gender&quot;: &quot;male&quot; }, &quot;john&quot;: { &quot;city&quot;: &quot;shanghai&quot;, &quot;family&quot;: [&quot;father&quot;, &quot;mother&quot;, &quot;sister&quot;] }} Python基础数据操作 通过上述的介绍，我们了解到了CMDB-v1.0的数据源长什么样子，以及它使用了什么样的数据结构，那么接下来就是如何用Python来表示它，这就涉及到了Python的几大数据类型 字符串: 上述数据源中用到最多的类型就是字符串，如&quot;ip&quot;, &quot;cisco&quot;, &quot;role&quot;等 整数：Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，如 1, 64512, -100 等 浮点数：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，如1.23，3.14，-9.01，1.5e11，1.5e-21 布尔值：布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值 列表：Python中列表即为数据结构中的数组，一种有序的集合，可以随时添加和删除其中的元素 元组：另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改 集合：也是一组key的集合，但在set中，没有重复的key 字典：dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度，dict即为数据结构中的散列表 Tips 上述说列表和元组为有序序列，并不是说列表和元组中的元素会按大小顺序排列，而是说列表和元组中的每个元素的排列是固定的，即不管print多少次，显示的结果是一样的；但字典和集合中的元素不是有序的，print出的结果可能会不一样；这种现象其实是由于不同的数据结构在计算机内存中不同的存储和表示方法造成的，后续会在番外篇中详细解释。 下面我们就结合CMDB-v1.0的数据源逐一讲解涉及到的数据类型和其操作： 第一个Python程序学习任何一门编程语言第一个程序都是如何打印出Hello World，Python对此的实现十分简单 1# 在命令行模式下，输入python，进入Python的交互模式&gt;&gt;&gt; print(&quot;Hello, World!!!&quot;)# 输出结果为 Hello World# 输入exit()退出Python交互模式，或者可以直接输入ctrl-D直接退出 Tips 从Python实现打印一行字符串其实可以看出很多这门语言的特点，首先给人的第一感觉就是简洁，代码阅读起来和阅读英文十分相似，其次就是Python程序的运行不需要编译，诸如C++，JAVA，Golang运行前都需要进行编译，这是因为Python是一门解释型语言，具体关于解释型语言和编译型语言的区别，后续会在番外篇中详细解释。 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如: 123port_num = 40 # 变量port_num是一个整数hostname = &quot;cisco-test&quot; # 变量hostname是一个字符串。stack = True # 变量stack是一个布尔值True Tips 有过其他语言学习经历的同学可能会了解，程序中定义一个变量时，需要指定这个变量的数据类型，比如 int a = 123;，当把变量a指定为整型时，就无法把字符串再赋值给它，如a='ABC'，这样会出发报错，但Python并没有这样的限制，这也是Python的另一大特点，即Python是一门动态类型语言，动态类型语言的一大好处就是灵活，这也是Python易上手的原因之一，但同时，由于在运行时才确定变量的数据类型，相较于静态类型语言，动态类型语言更容易出错，但我们享受其优点的同时，就必须要接受其弊病。更多关于静态语言与动态语言类型的区别，后续会在番外篇中详细解释。 注释上面的示例代码中我们有使用到注释，注释可以帮我们很好的对代码进行解释说明，利于我们及他人后续阅读 Python的注释一般分为两种 单行注释，可以跟在某行代码的后面，或者写在一个代码块的上面，没有强制的规定， 如 1port_num = 40 # 变量port_num是一个整数 或者 1# 变量port_num是一个整数port_num = 40 多行注释，顾名思义，可以在多行注释内写多行文本 123&quot;&quot;&quot;变量port_num是一个整数这是一个十分复杂的代码&quot;&quot;&quot;port_num = 40 Tips 程序员之间比较流行的一句话是：今天的代码没写注释，别说其他人以后不认识，明天我自己就不认识了。 数组在CMDB-v1.0中端口属性的数据类型就是数组，与之相对应的数据结构是列表。 该数组中存储了某台设备上所有的端口号，我们以此为例看看Python中的数组都有哪些常用操作： 如果我们想知道一共有多少端口，可以使用len()方法，len即为length的简称，很多方法名其实是可以根据名称推断出其作用 len()方法即为求某个可迭代对象的长度，此处我们的可迭代对象为数组，何为可迭代对象，我们会在番外篇中提到 123&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; len(port)# 输出 3 如果我们想获取某一个端口，可以使用数组下标索引进行访问，下标索引默认从0开始，最大为数组长度-1，如果超过数组长度，则会报错 1234567891011&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port[0]# 输出 Eth1/1/0&gt;&gt;&gt; port[2]# 输出 Eth1/1/2&gt;&gt; port[-1]# 等同于上一个，Eth1/1/2，以此类推，-2即为倒数第二个元素，同样不可以超出数组长度&gt;&gt;&gt; port[len(port)-1]# 输出 Eth1/1/2&gt;&gt;&gt; port[3]# 会产生 IndexError 错误 如果我们想在端口列表中增加一个端口，可以使用append()方法 append()方法为在数组末尾追加一个元素 12345&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port.append(&quot;Eth1/1/3&quot;)&gt;&gt;&gt; port# 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;, &quot;Eth1/1/3&quot;] insert()方法可以在数组任意位置插入一个元素 123&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port.insert(1, &quot;Eth1/1/1/1&quot;)# 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1/1&quot;, Eth1/1/1&quot;, &quot;Eth1/1/2&quot;] 如果我们想将两个端口列表合并，可以使用extend方法 12345&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port.extend([&quot;Eth1/1/3&quot;, &quot;Eth1/1/4&quot;])&gt;&gt;&gt; port# 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;, &quot;Eth1/1/3&quot;, &quot;Eth1/1/4&quot;] 如果我们想修改数组中某个元素，可以直接使用下标索引并对其赋值 12345&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port[1] = &quot;GEth1/1/1&quot;&gt;&gt;&gt; port# 输出 [&quot;Eth1/1/0&quot;, &quot;GEth1/1/1&quot;, &quot;Eth1/1/2&quot;] 如果我们想删除端口列表中的最后一个端口，可以使用pop()方法 pop()方法会返回弹出数组的最后一个元素，并将其返回 12345&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port.pop()# 输出 Eth1/1/2&gt;&gt;&gt; port# 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;] pop(i)可以弹出数组中任意位置的元素 更多数组相关的操作我们可以在以后的实践中慢慢学习 字典CMDB-v1.0中的核心数据类型是字典，对应的数据结构是散列表。 字典中存储了某个IDC的名称和其设备信息，我们以此为例看看Python中的字典都有哪些常用操作： 如果我们想知道这个字典是存储的IDC的信息，可以使用键对其进行查找 字典具有一个性质就是不管存储的数据有多大，根据某个键对其进行查找的速度都会非常快，不会随着字典数据的增加而变慢，这是数据结构中散列表的一个特性，并且字典要求键必须是不可变对象，相关知识我们后续会在番外篇中提到，此处我们暂且以字符串作为字典的键 1234567&gt;&gt;&gt; data = {{...}, {...}}&gt;&gt;&gt; bj_info= data[&quot;beijing&quot;] # 获取beijing IDC的数据&gt;&gt;&gt; data.get(&quot;beijing&quot;) # 同样为根据键进行查找，当字典中不存在 &quot;beijing&quot; 这个键时会返回 None&gt;&gt;&gt; idc_info.get(&quot;xiamen&quot;, {}) # dict.get() 方法可以接收另外一个参数，作为查找的键值不存在时的默认返回值# 输出 {} 如果我们想修改IDC的值，可以通过键对其进行赋值 字典中键和值是一一对应的，一个键只能存储一个值 123&gt;&gt;&gt; device_info = data[&quot;beijing&quot;][&quot;switch&quot;][&quot;10.0.0.1&quot;]&gt;&gt;&gt; device_info[&quot;hostname&quot;] = &quot;test&quot; # 将device_info设备的hostname修改为test 如果我们想知道switch下有哪些设备IP，可以使用dict.keys()方法 12345&gt;&gt;&gt; bj_switches = data[&quot;beijing&quot;][&quot;switch&quot;]&gt;&gt;&gt; bj_switches.keys()# 输出 [&quot;10.0.0.1&quot;, &quot;10.0.0.2&quot;]&gt;&gt;&gt; bj_switches.values() # 该方法可以获取字典中的所有值，得到beijing IDC的所有switch的详情# 输出 [{...}, {...}] 如果我们想给某个设备新增属性信息，可以直接用键去赋值 123456789&gt;&gt;&gt; switch_info_10_1 = bj_switches.get(&quot;10.0.0.1&quot;, {}) # 赋值时必须保证变量是字典，所以如果此处不用dict.get() 默认返回空字典，那么当不存在查询的数据时就会返回None，给None通过键赋值就会报错&gt;&gt;&gt; switch_info_10_1[&quot;label&quot;] = &quot;test_label&quot;&gt;&gt;&gt; switch_info_10_1# 输出 { &quot;label&quot;: &quot;test_label&quot;, manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, ...} 如果我们想用某个新的设备信息覆盖原有设备的属性信息，可以使用dict.update()方法 dict.update()方法接收一个字典，用来更新在原有的字典上 1234567&gt;&gt;&gt; new_dict = { &quot;hostname&quot;：&quot;test-00-00-01&quot;, &quot;role&quot;: &quot;csw&quot; }&gt;&gt;&gt; switch_info_10_1.update(new_dict)&gt;&gt;&gt; switch_info_10_1# 输出 { &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;test-00-00-01&quot;, ...} 如果我们想删除设备的某个属性，可以使用dict.pop()方法 dict.pop()方法接收一个键，将该键和其对应的值从字典中删除 1&gt;&gt;&gt; bj_switches[&quot;10.0.0.1&quot;].pop(&quot;label&quot;) # 删除beijing IDC下10.0.0.1设备的label属性 更多字典相关的操作我们可以在以后的实践中慢慢学习 字符串我们CMDB-v1.0中最多使用到的就是字符串这一数据类型，如&quot;idc&quot;, &quot;beijing&quot;,&quot;ip&quot;等，在Python中使用引号将一串字符引住，即为字符串，引号可以是双引号或者单引号并没有强制要求，但具体如何使用更加规范我们会在番外篇中提到。 下面我们以设备的主机名为例，看看对于字符串有哪些具体的操作方法需要用到， 如&quot;cisco-nx95-00-00-01&quot; 如果我们想查看主机名的长度，可以使用len()方法，上文中提到len()可以获取数组的长度，因为字符串同样也为可迭代对象，所以len()同样可以获取字符串的长度 123&gt;&gt;&gt; hostname = &quot;cisco-nx95-00-00-01&quot;&gt;&gt;&gt; len(hostname)# 输出 19 如果我们将主机名以**-**分隔，可以使用split()方法，该方法需要传入分隔符，并且返回一个数组 1&gt;&gt;&gt; hostname.split(&quot;-&quot;)# 输出 [&quot;cisco&quot;, &quot;nx95&quot;, &quot;00&quot;, &quot;00&quot;, &quot;01&quot;] 如果我们想获取字符串的某一段，可以使用切片的方式，因为Python中字符串的存储与数组十分类似，所以切片的方式同时适用于数组和字符串 123456789101112131415&gt;&gt;&gt; hostname[0:5] # 0可以省略，故等价于 hostname[:5]，Python中的切片是一个左闭右开区间，0-5的切片范围不包括下标5# 输出 cisco&gt;&gt;&gt; hostname[6:len(hostname)] # 等价于 hostname[6:]，切片的区间右侧数字大于等于字符串长度时，都不会报错，此时相当于一直取到字符串末尾# 输出 nx95-00-00-01&gt;&gt;&gt; hostname[0:len(hostname):2] # 切片操作可以接受第三个参数，用于表示步长# 输出 cson9-00-1&gt;&gt;&gt; hostname[::-1] # 第三个操作为负数时可以将字符串或数组倒置# 输出 10-00-00-59xn-ocsic 如果我们想获取某个字符所在的位置，可以使用index()方法，该方法接收字符参数，并且返回该字符在字符串中的第一个出现的下标 1&gt;&gt;&gt; hostname.index(&quot;-&quot;)# 输出 5 更多字符串相关的操作我们可以在以后的实践中慢慢学习 Tips 字符串是一种十分常见的数据类型，但由于字符串是文本，既然是文本就涉及到不同国家之间的编码问题，关于编码相关的内容我们会在番外篇中详细解释，大家暂时只需要知道目前国际通用的是UTF-8编码即可。 知识总结 介绍了CMDB在自动化运维中的重要性 演示了v1.0版本的CMDB的增删改查操作 讲解了Python常用的数据类型：字符串，数组，字典，以及对它们的常用操作方法 CMDB系列第一节我们就暂且讲解到这里，其实Python的数据类型和其操作还没有全部涉及到，我们先只掌握最常用的即可，更多的类型和内置操作方法可以慢慢积累。 第二节我们就会进入到CMDBv1.0版本的具体代码，为大家讲解Python的基础语句以及函数和面向对象相关的知识。 篇后语 文中我们多次提到部分内容会在番外篇中详细解释，最大的原因是某个知识点如果详细展开，都足以单独写一篇文章，但对于初学者来说，我们完全必要花时间在一些细枝末节上，因为当我们学习一门新知识时，我们最好的方法就是自顶向下逐步拆解，如果一头扎进知识的海洋中，那极有可能“溺亡”。 所以如果一些职场朋友，没有多余的精力去深究细节，就没有必要去看番外篇，当然如果对某个知识点十分感兴趣也可以多做了解； 但对于计算机专业的同学，不管已经毕业或者还未毕业，我都强烈大家建议阅读番外篇，只有基础打的足够牢，才能做到触类旁通。","link":"/posts/71625180.html"}],"tags":[{"name":"Python-Basics","slug":"Python-Basics","link":"/tags/Python-Basics/"},{"name":"CMDB","slug":"CMDB","link":"/tags/CMDB/"}],"categories":[{"name":"Freshman","slug":"Freshman","link":"/categories/Freshman/"}],"pages":[]}
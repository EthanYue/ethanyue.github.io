{"posts":[{"title":"自动化运维新手村-Python基础-1","text":"摘要首先说明，以下几类读者朋友们请自行对号入座： 对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读此篇； 了解过Python基本的数据结构，但又没有经常在实践中运用的读者，建议阅读此篇； 已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇； CMDB简介简单赘述以下，CMDB的英文全称是Configuration Management Database，中文名叫配置管理数据库，它几乎贯穿了运维的每个环节。在实际的项目中，CMDB常常被认为是构建其它ITIL(Information Technology Infrastructure Library，IT基础架构库)流程的基础，ITIL项目的成败与是否成功建立CMDB有非常大的关系。 对于一些中大型的互联网公司必然都有自研的CMDB系统，而一些初创公司可能采用开源的CMDB工具或者部分运维工程师日常使用Excel表格充当简易的CMDB功能，我们的目的并不是让大家去构建一个新的CMDB去推翻原有系统，也不是说用Excel表格就不如用Python来的高级，而是能让大家从CMDB自顶向下的拆解，来更生动的体会到Python基础数据结构的运用 CMDBv1.0实现完整的CMDB十分复杂，但作为讲解Python基本数据结构的范例，我们先实现一个简易的1.0版本。 CMDBv1.0只需要通过一个Python脚本就可以做到资产数据的增删改查。 可能会有一些有CMDB使用经验的朋友会有质疑，觉得这也叫CMDB，还请大家稍安勿躁，任何大型系统的构建都是经过日积月累的迭代，但我可以保证，在项目冷启动阶段，这样一个稍微简陋的1.0版本，就可以起到基本的资产管理的作用。 下面假设我们已经有了一个Python脚本，名叫 cmdb-v1.0.py ，我们简单的演示以下它的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141root&gt; # python3 cmdb-v1.0.py init beijing // 初始化beijing IDC{ &quot;beijing&quot;: { &quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: {}, &quot;router&quot;: {} }}root&gt; # python3 cmdb-v1.0.py add /beijing/switch // 添加beijing IDC的IP地址是10.0.0.1的交换机信息{ &quot;beijing&quot;: { &quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: { &quot;10.0.0.1&quot;: { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;], &quot;stack&quot;: true } } }, &quot;router&quot;: {}}root&gt; # python3 cmdb-v1.0.py get /beijing/switch/10.0.0.1 // 读取beijing IDC的IP地址是10.0.0.1的交换机信息{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [ &quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: true}root&gt; # python .\\cmdb-v1.0.py update /beijing/switch/10.0.0.1/hostname '\\&quot;test\\&quot;' // 将 beijing IDC的IP地址是10.0.0.1的交换机主机名修改为 testroot&gt; # python .\\cmdb-v1.0.py get /beijing/switch/10.0.0.1 // 读取验证相关信息{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;test&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [ &quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: true}root&gt; # python .\\cmdb-v1.0.py delete /beijing/switch/10.0.0.1/role // 删除beijing IDC的IP地址是10.0.0.1的交换机的角色属性root&gt; # python .\\cmdb-v1.0.py delete /beijing/switch/10.0.0.1/port '[\\&quot;Eth1/1/0\\&quot;]' // 删除beijing IDC的IP地址是10.0.0.1的交换机端口属性中的 Eth1/1/0root&gt; # python .\\cmdb-v1.0.py get /beijing/switch/10.0.0.1 // 读取验证相关信息{ &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;test&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;port&quot;: [ &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: true} 上面演示的几个步骤包括了地域的初始化，资产信息的增删改查，大家可以发现整个1.0版本中，数据源的结构是比较清晰的，几乎涉及到了Python中最常用的数据类型，以及不同数据类型的常用操作，所以这也是我想以CMDB为例切入Python的原因。 Python 从笔者个人经历来说，写过Python，Java，Golang，至今仍然觉得Python是一门十分优秀的语言，能够持续霸占最热门语言的前三甲，确实有其独到之处 Python优缺点 优点 简单 免费、开源 高层语言面向对象 可扩展性 丰富的库 缺点 性能，虽然有一部分网友还是对Python颇有微词，但如果非要从Python的众多缺点中挑一个最重要的一点的话，那就是性能问题，但性能问题绝对不是我们弃用Python的原因，目前仍然有诸多方法可以保证Python支持企业级应用平稳运行迭代，而且就连字节如此大体量的公司很多地方都仍然使用Python进行开发 CMDB拆解及Python基本数据类型CMDB 拆解根据上面的演示大家应该已经大概了解CMDBv1.0版本的数据源大概长什么样子了，它的层级的划分其实是根据每个公司不同的实际场景决定的，我们这里就暂且先考虑普适情况，即idc为顶层，其包含了switch和router，然后再包含具体的设备信息和属性，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161{ &quot;beijing&quot;: { &quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: { &quot;10.0.0.1&quot;: { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [ &quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: true }, &quot;10.0.0.2&quot;: { &quot;ip&quot;: &quot;10.0.0.2&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-02&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;dsw&quot;, &quot;port&quot;: [ &quot;GEth1/1/0&quot;, &quot;GEth1/1/1&quot;, &quot;GEth1/1/2&quot; ], &quot;stack&quot;: true } }, &quot;router&quot;: { &quot;10.0.0.3&quot;: { &quot;ip&quot;: &quot;10.0.0.3&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;br&quot;, &quot;port&quot;: [ &quot;TGEth1/0/0/1&quot;, &quot;TGEth1/0/0/2&quot;, &quot;TGEth1/0/0/3&quot; ], &quot;bgp_as&quot;: 64512 } } }, &quot;shanghai&quot;: { &quot;idc&quot;: &quot;shanghai&quot;, &quot;switch&quot;: { &quot;10.0.1.1&quot;: { &quot;ip&quot;: &quot;10.0.1.1&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-01-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;asw&quot;, &quot;port&quot;: [ &quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot; ], &quot;stack&quot;: false } }, &quot;router&quot;: { &quot;10.0.1.3&quot;: { &quot;ip&quot;: &quot;10.0.1.3&quot;, &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-01-01&quot;, &quot;hardware&quot;: &quot;nexus9500&quot;, &quot;role&quot;: &quot;br&quot;, &quot;port&quot;: [ &quot;TGEth1/0/0/1&quot;, &quot;TGEth1/0/0/2&quot;, &quot;TGEth1/0/0/3&quot; ], &quot;bgp_as&quot;: 64512 } } }} 想必很多读者都听过数据结构，构建一个可扩展的CMDB非常需要一个合适的数据结构，当然很多计算机专业的同学应该了解，数据结构是一门十分复杂的学科，无法在短时间内将其讲解清楚，感兴趣的同学可以阅读番外篇详细了解，此处我们先简短的介绍一下需要用到的一些概念： 数据结构（英语：data structure）是计算机中存储、组织数据的方式，不同种类的数据结构适合于不同种类的应用；常见的数据结构有，栈，队列，数组，链表，树，图，堆，散列表=其实我们目前只需要用到数组和散列表(又称哈希表)两种数据结构，我先通俗易懂的讲解一下这两种数据结构 数组， 可以将其理解为一个容器，里面可以装很多元素，只不过这些元素必须是相同类型的, 他们可以用下标的位置进行存取，如 123|a | b | c | d | e | f | g | h | i | j | 0 1 2 3 4 5 6 7 8 9 值得注意的是数组的下标永远都是从0开始，这个对于初期接触编程的读者朋友来说可能会有点儿不适应 散列表，可以将其理解为通讯录，通讯录里的人不可以重名，每个人的名字都对应他的个人信息，个人信息可以存储任何数据，如 123456789101112131415161718192021{ &quot;jack&quot;: &quot;19098090000&quot;, &quot;allen&quot;: { &quot;age&quot;: 20, &quot;gender&quot;: &quot;male&quot; }, &quot;john&quot;: { &quot;city&quot;: &quot;shanghai&quot;, &quot;family&quot;: [&quot;father&quot;, &quot;mother&quot;, &quot;sister&quot;] }} Python基础数据操作 通过上述的介绍，我们了解到了CMDB-v1.0的数据源长什么样子，以及它使用了什么样的数据结构，那么接下来就是如何用Python来表示它，这就涉及到了Python的几大数据类型 字符串: 上述数据源中用到最多的类型就是字符串，如&quot;ip&quot;, &quot;cisco&quot;, &quot;role&quot;等 整数：Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，如 1, 64512, -100 等 浮点数：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，如1.23，3.14，-9.01，1.5e11，1.5e-21 布尔值：布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值 列表：Python中列表即为数据结构中的数组，一种有序的集合，可以随时添加和删除其中的元素 元组：另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改 集合：也是一组key的集合，但在set中，没有重复的key 字典：dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度，dict即为数据结构中的散列表 Tips 上述说列表和元组为有序序列，并不是说列表和元组中的元素会按大小顺序排列，而是说列表和元组中的每个元素的排列是固定的，即不管print多少次，显示的结果是一样的；但字典和集合中的元素不是有序的，print出的结果可能会不一样；这种现象其实是由于不同的数据结构在计算机内存中不同的存储和表示方法造成的，后续会在番外篇中详细解释。 下面我们就结合CMDB-v1.0的数据源逐一讲解涉及到的数据类型和其操作： 第一个Python程序学习任何一门编程语言第一个程序都是如何打印出Hello World，Python对此的实现十分简单 1# 在命令行模式下，输入python，进入Python的交互模式&gt;&gt;&gt; print(&quot;Hello, World!!!&quot;)# 输出结果为 Hello World# 输入exit()退出Python交互模式，或者可以直接输入ctrl-D直接退出 Tips 从Python实现打印一行字符串其实可以看出很多这门语言的特点，首先给人的第一感觉就是简洁，代码阅读起来和阅读英文十分相似，其次就是Python程序的运行不需要编译，诸如C++，JAVA，Golang运行前都需要进行编译，这是因为Python是一门解释型语言，具体关于解释型语言和编译型语言的区别，后续会在番外篇中详细解释。 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如: 123port_num = 40 # 变量port_num是一个整数hostname = &quot;cisco-test&quot; # 变量hostname是一个字符串。stack = True # 变量stack是一个布尔值True Tips 有过其他语言学习经历的同学可能会了解，程序中定义一个变量时，需要指定这个变量的数据类型，比如 int a = 123;，当把变量a指定为整型时，就无法把字符串再赋值给它，如a='ABC'，这样会出发报错，但Python并没有这样的限制，这也是Python的另一大特点，即Python是一门动态类型语言，动态类型语言的一大好处就是灵活，这也是Python易上手的原因之一，但同时，由于在运行时才确定变量的数据类型，相较于静态类型语言，动态类型语言更容易出错，但我们享受其优点的同时，就必须要接受其弊病。更多关于静态语言与动态语言类型的区别，后续会在番外篇中详细解释。 注释上面的示例代码中我们有使用到注释，注释可以帮我们很好的对代码进行解释说明，利于我们及他人后续阅读 Python的注释一般分为两种 单行注释，可以跟在某行代码的后面，或者写在一个代码块的上面，没有强制的规定， 如 1port_num = 40 # 变量port_num是一个整数 或者 1# 变量port_num是一个整数port_num = 40 多行注释，顾名思义，可以在多行注释内写多行文本 123&quot;&quot;&quot;变量port_num是一个整数这是一个十分复杂的代码&quot;&quot;&quot;port_num = 40 Tips 程序员之间比较流行的一句话是：今天的代码没写注释，别说其他人以后不认识，明天我自己就不认识了。 数组在CMDB-v1.0中端口属性的数据类型就是数组，与之相对应的数据结构是列表。 该数组中存储了某台设备上所有的端口号，我们以此为例看看Python中的数组都有哪些常用操作： 如果我们想知道一共有多少端口，可以使用len()方法，len即为length的简称，很多方法名其实是可以根据名称推断出其作用 len()方法即为求某个可迭代对象的长度，此处我们的可迭代对象为数组，何为可迭代对象，我们会在番外篇中提到 123&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; len(port)# 输出 3 如果我们想获取某一个端口，可以使用数组下标索引进行访问，下标索引默认从0开始，最大为数组长度-1，如果超过数组长度，则会报错 1234567891011&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port[0]# 输出 Eth1/1/0&gt;&gt;&gt; port[2]# 输出 Eth1/1/2&gt;&gt; port[-1]# 等同于上一个，Eth1/1/2，以此类推，-2即为倒数第二个元素，同样不可以超出数组长度&gt;&gt;&gt; port[len(port)-1]# 输出 Eth1/1/2&gt;&gt;&gt; port[3]# 会产生 IndexError 错误 如果我们想在端口列表中增加一个端口，可以使用append()方法 append()方法为在数组末尾追加一个元素 12345&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port.append(&quot;Eth1/1/3&quot;)&gt;&gt;&gt; port# 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;, &quot;Eth1/1/3&quot;] insert()方法可以在数组任意位置插入一个元素 123&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port.insert(1, &quot;Eth1/1/1/1&quot;)# 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1/1&quot;, Eth1/1/1&quot;, &quot;Eth1/1/2&quot;] 如果我们想将两个端口列表合并，可以使用extend方法 12345&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port.extend([&quot;Eth1/1/3&quot;, &quot;Eth1/1/4&quot;])&gt;&gt;&gt; port# 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;, &quot;Eth1/1/3&quot;, &quot;Eth1/1/4&quot;] 如果我们想修改数组中某个元素，可以直接使用下标索引并对其赋值 12345&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port[1] = &quot;GEth1/1/1&quot;&gt;&gt;&gt; port# 输出 [&quot;Eth1/1/0&quot;, &quot;GEth1/1/1&quot;, &quot;Eth1/1/2&quot;] 如果我们想删除端口列表中的最后一个端口，可以使用pop()方法 pop()方法会返回弹出数组的最后一个元素，并将其返回 12345&gt;&gt;&gt; port = [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]&gt;&gt;&gt; port.pop()# 输出 Eth1/1/2&gt;&gt;&gt; port# 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;] pop(i)可以弹出数组中任意位置的元素 更多数组相关的操作我们可以在以后的实践中慢慢学习 字典CMDB-v1.0中的核心数据类型是字典，对应的数据结构是散列表。 字典中存储了某个IDC的名称和其设备信息，我们以此为例看看Python中的字典都有哪些常用操作： 如果我们想知道这个字典是存储的IDC的信息，可以使用键对其进行查找 字典具有一个性质就是不管存储的数据有多大，根据某个键对其进行查找的速度都会非常快，不会随着字典数据的增加而变慢，这是数据结构中散列表的一个特性，并且字典要求键必须是不可变对象，相关知识我们后续会在番外篇中提到，此处我们暂且以字符串作为字典的键 1234567&gt;&gt;&gt; data = {{...}, {...}}&gt;&gt;&gt; bj_info= data[&quot;beijing&quot;] # 获取beijing IDC的数据&gt;&gt;&gt; data.get(&quot;beijing&quot;) # 同样为根据键进行查找，当字典中不存在 &quot;beijing&quot; 这个键时会返回 None&gt;&gt;&gt; idc_info.get(&quot;xiamen&quot;, {}) # dict.get() 方法可以接收另外一个参数，作为查找的键值不存在时的默认返回值# 输出 {} 如果我们想修改IDC的值，可以通过键对其进行赋值 字典中键和值是一一对应的，一个键只能存储一个值 123&gt;&gt;&gt; device_info = data[&quot;beijing&quot;][&quot;switch&quot;][&quot;10.0.0.1&quot;]&gt;&gt;&gt; device_info[&quot;hostname&quot;] = &quot;test&quot; # 将device_info设备的hostname修改为test 如果我们想知道switch下有哪些设备IP，可以使用dict.keys()方法 12345&gt;&gt;&gt; bj_switches = data[&quot;beijing&quot;][&quot;switch&quot;]&gt;&gt;&gt; bj_switches.keys()# 输出 [&quot;10.0.0.1&quot;, &quot;10.0.0.2&quot;]&gt;&gt;&gt; bj_switches.values() # 该方法可以获取字典中的所有值，得到beijing IDC的所有switch的详情# 输出 [{...}, {...}] 如果我们想给某个设备新增属性信息，可以直接用键去赋值 123456789&gt;&gt;&gt; switch_info_10_1 = bj_switches.get(&quot;10.0.0.1&quot;, {}) # 赋值时必须保证变量是字典，所以如果此处不用dict.get() 默认返回空字典，那么当不存在查询的数据时就会返回None，给None通过键赋值就会报错&gt;&gt;&gt; switch_info_10_1[&quot;label&quot;] = &quot;test_label&quot;&gt;&gt;&gt; switch_info_10_1# 输出 { &quot;label&quot;: &quot;test_label&quot;, manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, ...} 如果我们想用某个新的设备信息覆盖原有设备的属性信息，可以使用dict.update()方法 dict.update()方法接收一个字典，用来更新在原有的字典上 1234567&gt;&gt;&gt; new_dict = { &quot;hostname&quot;：&quot;test-00-00-01&quot;, &quot;role&quot;: &quot;csw&quot; }&gt;&gt;&gt; switch_info_10_1.update(new_dict)&gt;&gt;&gt; switch_info_10_1# 输出 { &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;test-00-00-01&quot;, ...} 如果我们想删除设备的某个属性，可以使用dict.pop()方法 dict.pop()方法接收一个键，将该键和其对应的值从字典中删除 1&gt;&gt;&gt; bj_switches[&quot;10.0.0.1&quot;].pop(&quot;label&quot;) # 删除beijing IDC下10.0.0.1设备的label属性 更多字典相关的操作我们可以在以后的实践中慢慢学习 字符串我们CMDB-v1.0中最多使用到的就是字符串这一数据类型，如&quot;idc&quot;, &quot;beijing&quot;,&quot;ip&quot;等，在Python中使用引号将一串字符引住，即为字符串，引号可以是双引号或者单引号并没有强制要求，但具体如何使用更加规范我们会在番外篇中提到。 下面我们以设备的主机名为例，看看对于字符串有哪些具体的操作方法需要用到， 如&quot;cisco-nx95-00-00-01&quot; 如果我们想查看主机名的长度，可以使用len()方法，上文中提到len()可以获取数组的长度，因为字符串同样也为可迭代对象，所以len()同样可以获取字符串的长度 123&gt;&gt;&gt; hostname = &quot;cisco-nx95-00-00-01&quot;&gt;&gt;&gt; len(hostname)# 输出 19 如果我们将主机名以**-**分隔，可以使用split()方法，该方法需要传入分隔符，并且返回一个数组 1&gt;&gt;&gt; hostname.split(&quot;-&quot;)# 输出 [&quot;cisco&quot;, &quot;nx95&quot;, &quot;00&quot;, &quot;00&quot;, &quot;01&quot;] 如果我们想获取字符串的某一段，可以使用切片的方式，因为Python中字符串的存储与数组十分类似，所以切片的方式同时适用于数组和字符串 123456789101112131415&gt;&gt;&gt; hostname[0:5] # 0可以省略，故等价于 hostname[:5]，Python中的切片是一个左闭右开区间，0-5的切片范围不包括下标5# 输出 cisco&gt;&gt;&gt; hostname[6:len(hostname)] # 等价于 hostname[6:]，切片的区间右侧数字大于等于字符串长度时，都不会报错，此时相当于一直取到字符串末尾# 输出 nx95-00-00-01&gt;&gt;&gt; hostname[0:len(hostname):2] # 切片操作可以接受第三个参数，用于表示步长# 输出 cson9-00-1&gt;&gt;&gt; hostname[::-1] # 第三个操作为负数时可以将字符串或数组倒置# 输出 10-00-00-59xn-ocsic 如果我们想获取某个字符所在的位置，可以使用index()方法，该方法接收字符参数，并且返回该字符在字符串中的第一个出现的下标 1&gt;&gt;&gt; hostname.index(&quot;-&quot;)# 输出 5 更多字符串相关的操作我们可以在以后的实践中慢慢学习 Tips 字符串是一种十分常见的数据类型，但由于字符串是文本，既然是文本就涉及到不同国家之间的编码问题，关于编码相关的内容我们会在番外篇中详细解释，大家暂时只需要知道目前国际通用的是UTF-8编码即可。 知识总结 介绍了CMDB在自动化运维中的重要性 演示了v1.0版本的CMDB的增删改查操作 讲解了Python常用的数据类型：字符串，数组，字典，以及对它们的常用操作方法 CMDB系列第一节我们就暂且讲解到这里，其实Python的数据类型和其操作还没有全部涉及到，我们先只掌握最常用的即可，更多的类型和内置操作方法可以慢慢积累。 第二节我们就会进入到CMDBv1.0版本的具体代码，为大家讲解Python的基础语句以及函数和面向对象相关的知识。 篇后语 文中我们多次提到部分内容会在番外篇中详细解释，最大的原因是某个知识点如果详细展开，都足以单独写一篇文章，但对于初学者来说，我们完全必要花时间在一些细枝末节上，因为当我们学习一门新知识时，我们最好的方法就是自顶向下逐步拆解，如果一头扎进知识的海洋中，那极有可能“溺亡”。 所以如果一些职场朋友，没有多余的精力去深究细节，就没有必要去看番外篇，当然如果对某个知识点十分感兴趣也可以多做了解； 但对于计算机专业的同学，不管已经毕业或者还未毕业，我都强烈大家建议阅读番外篇，只有基础打的足够牢，才能做到触类旁通。","link":"/posts/71625180.html"},{"title":"Python玩转自动化运维","text":"专注于自动化运维领域，帮助任何想将编程与运维相结合的朋友，从零开始引领大家走进运维自动化。 内容受众你是否已经决定走上了运维工程师的道路，或者是深耕运维多年的老手； 升职加薪一直与自己绝缘，还总是锅从天上来； 看着别人自动化运维搞得风生水起，自己巡检两台设备的时间别人已经巡检好了一百台设备，还顺带出了个报表，你迷茫了； 人往往很难跳出自己的舒适圈，对于之前没有涉足过的领域也很难找到合适的切入点，再加上平时的工作已经足够焦头烂额，没有时间去从零开始学一门新技术。 内容定位并不为了单纯的输出枯燥的知识点，区别于其他资料的随意搬运，东一榔头西一棒子； 而是从场景出发，使输出的内容具有实操性，自顶向下将具体场景拆分，并落实到每个知识点，让同学清晰的意识到所学知识能够如何运用； 让运维老手掌握平时经常听到的 Netmiko, SNMP, Netconf等知识，能够学有所得，学能所用； 番外篇会将正篇中涉及到的细节逐一展开，让计算机专业同学能够深入理解，夯实基础，逐步掌握操作系统，数据结构等专业知识； 并且也会涉及到编程思想，学习方法论等技巧，让大家有挑战大厂的底气。 路径的选择对于正在从事运维工作，但工作中遇到了一些自动化的需求的朋友，那么这里作者并不提倡大家去构建整个的自动化运维体系，一个是没有必要，另一个是这也可能会消耗相当大的精力，所以我们就暂时只点与自己实际工作相关的技能即可，全部的技能树如下图所示： 路径的规划一、【自动化运维新手村】那么对于自动化运维来说肯定首推的编程语言就是Python。 但网上对于Python语言的教程一抓一大把，我为什么还要在这里去讲解呢？这其实等同于另一个问题：刚接触编程的人是否能通过看类似的教程快速上手Python? 或者通俗易懂的讲：是不是能看得懂? 大部分从事运维工作的朋友可能都没有编程经验，也没有系统的学习过计算机底层原理，所以对于标准式的教程就会感觉，好像会了，但又没有全会；好像会了，但又不会用，所以我根据自己的学习方法再加上身边运维朋友们的学习经历，通过一些生动的例子和实际的场景来让大家快速的上手Python这门语言，并且能直接运用于实际工作中。 新手村的内容主要是为大家搭建一个简易的CMDB（资产管理），这也符合很多运维朋友的实际需求场景，比如想要做一个小功能，可以提供给其他人使用。除此之外也会对其中涉及到的部分知识点进行详细的深入挖掘，呈现在番外篇中，让对其感兴趣的读者朋友去更多的了解。 Python基本数据结构和操作 将CMDB的增删改查与Python数据结构相结合，将枯燥的基础知识进行深入浅出的讲解 番外：数据结构的详解 番外：字符串的详解 番外：数组的详解 番外：字典的详解 面试番外：算法 Python函数与对象 将如何构建CMDB的函数与对象逐步拆解 番外：深入了解面向对象 番外：设计模式简介 Flask Web框架 将对CMDB的操作与Web框架相结合，通过API的方式对CMDB进行操作 面试番外：计算机网络 MySQL数据库 将CMDB存储到数据库中，对其进行的增删改查从对文件读写转移到对数据库进行操作 番外：MongoDB数据库 面试番外：数据库 Linux部署应用 将应用部署在Linux系统上稳定的运行 面试番外：操作系统 二、【自动化运维初级村】 其实初级村的内容顺序的设计和新手村是类似的，但这一部分所运用的Python知识就会稍微深入，所以建议已经对Python有一定了解的朋友，可以跳过新手村直接看初级村的内容，因为初级村会是更多运维朋友们经常遇到的需求场景，也是做自动化运必须要走的路。 paramiko和netmiko 两者的使用方式及优劣 Python 正则解析 将通过SSH收集回来的各种信息进行正则解析 番外：text-fsm解析 Python snmp 如何使用Python调用SNMP采集指令，并讲解OID使用方式 NetConf 如何通过NetConf对网络设备进行操作 Crontab并回调CMDB 如何设置定时执行SSH任务进行定期巡检，并更新回写CMDB 番外：Python scheduler Flask Web框架 将SSH和NetConf与Web框架相结合，通过API方式或前端调用其执行 三、【自动化运维中级村】 中级村与初级村最大的不同就是，会从简单需求应用的完成，转变为更为复杂架构的设计与实现，以及能够支撑更大型运维的场景。 Celery任务队列 如何使用任务队列异步处理大量的SSH或NetConf执行操作 番外：Redis数据库 番外：RabbitMQ中间件 Rsyslog日志采集 通过Rsyslog收集设备日志并存储进行展示和查询。 Mysql性能优化 支持更大数据量的存储和查询，进行数据库的优化，分库和分表 ELK， Rsyslog - Kafkf - LogStash - ElasticSearch - Kibana 使用ELK套件对日志进行存储及展示 前后端分离 由于系统功能的丰富，需要实现前后端分离的应用。 四、【自动化运维高级村】 如果想要做一个完整的自动化运维系统，就必然需要有相应完善的自动化运维的理念和方法论，所以高级村会设计到更多关于自动化运维的理念介绍，以及更为复杂和适应更大型企业的自动化运维系统。 Celery分时任务队列 使用Celery任务队列，将SNMP大量采集任务或SSH变更任务根据频率发布在不同的队列中进行高效采集 Flink处理 使用Flink对SNMP采集的数据进行清洗并存储 Rsyslog - Kafka - Consumer- MySQL 如何将设备上报的日志进行收集解析，并通过Kafka中间件削峰，并进行存储 番外： Kafka中间件 告警通知，屏蔽，抑制 如何设置告警的通知，屏蔽和抑制机制 任务编排 通过白屏方式将变更步骤注册为执行算子，并进行编排后下发 基于意图的分组配置下发 将设备根据角色分组，并设置基于意图的模板命令，使用SSH或NetConf方式与其结合对网络设备进行变更或查询操作 路径的总结上述的路径梳理是一个目前我能给到大家的较为系统的自动化运维方面的实践，在更新的过程中，我可能会根据读者的需要或者平时的思考总结对内容进行更新迭代，所以说路径并不是固定的，它只是一个学习的方向，并且学习的过程必然是会有阻碍和困难的，希望大家都能有坚定的决心克服一个个的难点，当然也会提供给大家学习交流的群组，供大家互相探讨，互相进步，也欢迎大家有什么疑问都找我咨询。最后期待大家都能拿到属于自己的结果。","link":"/posts/5cb4afad.html"},{"title":"自动化运维新手村-Python基础-2","text":"摘要首先说明，以下几类读者请自行对号入座： 对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读此篇； 了解过Python基本的数据结构，但又没有经常在实践中运用的读者，建议阅读此篇； 已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇； 上一节我们通过对自动化运维的基石–CMDBv1.0的演示，为大家讲了Python的基本数据类型和相关的操作，那么这一节我们就深入cmdb-v1.0.py的源码，并了解一下Python的语句，函数以及面向对象相关的知识。 一说到阅读源码很多读者就要慌了，觉得Python都没入门就阅读源码了？首先Python的一大好处就是，代码的逻辑像阅读英文一样简洁，并且我们的cmdb-v1.0.py的源码只有一百一十行左右，就实现了对资产数据增删改查的基本功能，话不多说，马上开始. Python脚本的启动1root&gt; # python ./cmdb-v1.0.py [额外参数...] 在命令行中直接通过python加文件名就可以执行该脚本，那么当执行该脚本时，脚本内部做了什么操作呢 1234567891011121314151617181920212223242526272829303132333435if __name__ == &quot;__main__&quot;: operations = [&quot;get&quot;, &quot;update&quot;, &quot;delete&quot;] args = sys.argv if len(args) &lt; 3: print(&quot;please input operation and args&quot;) else: if args[1] == &quot;init&quot;: init(args[2]) elif args[1] == &quot;add&quot;: add(*args[2:]) elif args[1] == &quot;get&quot;: get(args[2]) elif args[1] == &quot;update&quot;: update(args[2], args[3]) elif args[1] == &quot;delete&quot;: delete(*args[2:]) else: print(&quot;operation must be one of get,update,delete&quot;) 上述代码就是我们整个脚本的启动入口，大家最先看到的就是一行判断语句，那我们就先从判断语句开始讲起 条件判断 不管哪种编程语言，条件判断都是其最基本的逻辑，是让一行一行的代码能够被编排起来的最基本手段，条件判断可以实现在不同的情况下执行不同的代码块，如图所示 下面为Python判断语句的伪代码形式，当判断条件为真时执行语句1，为假时执行语句2，执行语句可以为多行，通过缩进来控制 1234567if 判断条件: 执行语句1else: 执行语句2 我们的源码中的第一行 if __name__ == &quot;__main__&quot;，这就是一个字符串判断的语句，__name__是一个Python的内置变量，它表示当前被执行脚本的名称，所以此处判断语句的含义为是否当前被执行脚本的名称等于&quot;__main__&quot;，这里有两个地方需要大家注意一下： 当使用python 文件名.py的方式执行脚本时，该脚本的__name__值即为__main__ 条件判断语句中等于通过==来表示，而非= 在掌握了判断语句的原理后，再加上我们上节内容所讲，我们就可以理解源码中启动入口的基本逻辑 1234567891011121314151617181920212223242526272829303132333435# 当前被执行脚本的名称是否等于&quot;__main__&quot;，如果等于执行以下语句if __name__ == &quot;__main__&quot;: args = sys.argv # 获取命令行输入的参数，此处sys.argv为python的内置方法 if len(args) &lt; 3: # 如果参数数量小于3个，则执行以下语句 print(&quot;please input operation and args&quot;) # 打印提示内容 else: # 如果参数数量不小于3个，则执行以下语句 if args[1] == &quot;init&quot;: # 是否参数的第二个元素等于&quot;init&quot;(数组下标从0开始) init(args[2]) # 如果等于&quot;init&quot;则执行该函数 elif args[1] == &quot;add&quot;: # 如果不等于&quot;init&quot;，则判断是否等于&quot;add&quot; add(*args[2:]) # 如果等于&quot;add&quot;则执行该函数 elif args[1] == &quot;get&quot;: # 如果也不等于&quot;add&quot;，则判断是否等于&quot;get&quot; get(args[2]) # 如果等于&quot;get&quot;则执行该函数 elif args[1] == &quot;update&quot;: # 如果也不等于&quot;get&quot;，则判断是否等于&quot;update&quot; update(args[2], args[3]) # 如果等于&quot;update&quot;则执行该函数 elif args[1] == &quot;delete&quot;: # 如果也不等于&quot;update&quot;，则判断是否等于&quot;delete&quot; delete(*args[2:]) # 如果等于&quot;delete&quot;则执行该函数 else: # 如果都不等于则执行以下打印语句，输出提示 print(&quot;operation must be one of get,update,delete&quot;) 大家可以发现只通过上述的条件判断语句就可以根据我们执行脚本时的命令行参数，去分别执行不同的增删改查的逻辑，读者可能对这里的*arg有一些疑问，我们会在番外篇中提到。 循环语句 目前我们已经掌握了让脚本启动，并且根据不同的条件判断去依次执行语句的能力，不过这时程序还只是在顺序执行，如果我们想查询多个资产信息，那么就必须多次去执行查询的语句，这时候就需要使用循环语句，循环语句可以让我们执行某一个代码块多次，如图所示 Python中的循环语句的伪代码形式如下所示 123for 判断条件: # 只要判断条件为真就会一直执行语句1 执行语句1 由于循环语句相对比较好理解，我们就先简单介绍以下，后面的源码中遇到时，再深入讲解一些细节 函数 通过上面的学习我们已经能够比较好的编排自己的代码去顺序执行或者循环执行，但对于一些可以重复使用的语句，我们可以把其组织起来，将它们定义为一个函数，这样我们后续就可以直接去使用这个函数，而不必每次都编写大量相同的语句。 Python中的函数伪代码形式如下所示 123def 函数名称(参数...)： 代码块 比如我们源码中定义的查询资产信息的函数的伪代码如下 1234567def get(path): # 函数名称为 get， 接受一个参数 path 打开资产信息的文件 根据参数path去查询资产信息中对应的信息 打印相关信息 当我们定义好这样一个函数之后，我们后续就可以十分方便的去调用它，调用的方法就是 1info = get(&quot;/beijing/switch/10.0.0.1&quot;) 其实函数的本意就是我们将一些可被复用的代码进行提取，将其中可变的变量作为参数传入，而将其相同的逻辑保留，这样我们每次只需要传入不同的参数就可以执行该逻辑，不用在需要使用该逻辑的地方再次编写冗余的代码 比如在脚本的启动入口地方，如下 1234567891011121314151617181920212223242526272829303132333435def init(path): ...def get(path): ...def delete(path): ...if args[1] == &quot;init&quot;: init(args[2])elif args[1] == &quot;get&quot;: get(args[2])else: print(&quot;operation must be one of get,update,delete&quot;) 我们只需要在执行脚本时，通过判断命令行的指令，就可以去执行不同的函数，十分方便，但这里有两个地方需要大家注意以下 定义的函数只是语句的抽象逻辑，如果不调用它，那么它就永远不会执行，比如如果我们定义了一个删除的函数，但始终都没有任何地方去调用它，那么它就永远不会被执行 print()其实也是一个函数，只不过它是Python的内置函数，它的功能相当于接收一个字符串，并将其输出到屏幕上，所以我们其实在尝试编写第一个python程序print(&quot;hello world&quot;)时，就已经无形中使用到了函数 Tips 大家可以设想以下，如果每次我们想将内容输出到屏幕，都需要自己去编写print的内部逻辑细节，那简直就是一场灾难；所以在什么时候将某个代码块抽象为函数，将多少逻辑的代码块抽象为一个函数，这其实是编程的艺术，取决于每个人对于实际场景的把握。但也有一些变成规范可依。 我们通常只将一个功能抽象为一个函数，也就是说每个函数只实现一个单一的功能。 面向对象 很多对于编程稍微有了解的读者都知道，面向对象是很多编程语言都有的一个特性，所谓面向对象其实是一种编程的思路，与之不同的思路还有面向过程； 比如同样要实现相同的功能，可以使用不同的思路，思路没有孰优孰劣之分，只要在当前场景适用即可 虽然Python实现一些简单的功能，只需要面向过程即可，比如将目标场景，拆分为不同的步骤，将每个步骤定义为函数，然后通过编排函数去实现最终的目标，但Python本身从设计之处就是一门面向对象的语言，并且Python中一切皆对象。 那么对象究竟是什么：世界上的任何事物都可以把它看成一个对象，其具有自己的属性和行为，不同的对象之间通过方法来交互。 比如Python中的某个字符串，它就是一个对象，它具有自己属性和方法，如下 12345root&gt; # a = &quot;string&quot;root&gt; # dir(a)['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] 我们定义了一个字符串变量a，通过dir方法来查看其所具有的所有属性和方法。 面向对象只是解决问题的思路，我们并不是将问题拆解为不同的步骤，而是将问题分解为不同的对象，在我们的CMDBv1.0中，我们要解决的问题就是实现资产信息的增删改查，那么我们分析该问题发现需要两个对象来解决： 资产对象 属性：可以执行的操作，当前的版本，创建时间，上次修改的时间等 方法：增、删、改、查 信息存储对象 属性：存储的位置，数据的大小 方法：存，取 所以经过我们面向对象的拆解，最终将我们的问题从面向过程，即根据命令行参数的传入去执行不同的函数，而修改为了我们与资产对象进行交互，而资产对象与存储对象进行交互。 知识总结 开始初步阅读CMDBv1.0版本的源码 讲解了Python基本的条件语句和循环语句 讲解了Python的函数，以及面向对象的分析 CMDB系列第二节我们就暂且讲到这里，对于判断语句和循环语句还有很多细节没有涉及到，但我们已经掌握了其基本的原理，并且我们了解了面向对象的思路。 后面的章节我们会继续阅读CMDBv1.0的源码，了解更为细节的内容，并且用面向对象的思路将CMDBv1.0改造为CMDBv1.5，敬请期待。 篇后语很多读者在阅读的过程中可能发现，我们很多的知识都是浅尝辄止，看似都是一些皮毛，并没有什么真材实料，包括阅读源码也是，只看了个大概； 其实不然，当我们新上手一门新的技术时，我们并不能揪住一个知识点不放，比如字符串是一个对象，通过dir可以发现它有二十多个属性和二十多种方法，但我们难道要在一开始就都掌握并把他们背会吗？ 答案当然是否定的，这些细节我们初期都不需要去深究，我们的场景是构建一个简易版CMDB，那么我们只需要一步一步将这过程中阻碍我们前进的知识掌握即可，具体的细节可以在后续的深入过程中去慢慢了解。 这也是为什么很多学生不愿意听老师讲课的原因，因为他并不知道我这节课学的知识点有什么用，只是机械的接受老师的灌输，所以好的学习方法一定是自顶向下的，希望读者朋友们能体会到其真正的内涵。","link":"/posts/a45b0691.html"},{"title":"自动化运维新手村-Python基础-3","text":"摘要首先说明，以下几类读者请自行对号入座： 对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇； 对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇； 已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇； 上一节我们简单地阅读了CMDBv1.0.py的源码，了解到其基本的模块构成，并且结合实际的程序理解了Python的常用数据结构以及基本的条件语句与循环语句的运用。那么这一节我们将详细阅读每一个模块的代码，并将其所涉及的知识点拆解开来，帮助各位读者更快的进入到Python的世界。 为什么要阅读源码填鸭式学习在开始之前我想向大家说明的是，之所以才在第三节就带领大家深入到源码中去，是因为Python作为最易上手的解释型语言，其社区生态和包含的各种第三方库数不胜数，而且任何一门语言其内置的规范和方法对于初学者来说都无法穷尽，所以如果一点儿一点儿的去学习某个内置方法，某个包如何使用，在我看来其实是本末倒置的，任何在没有使用场景的情况下进行填鸭式的灌输内容，都是”耍流氓“。 场景&lt;-&gt;知识点比如大家其他新手教程里十分常见的读写文件功能，说实话读写文件也就是一两行代码可以完成的事情，但哪怕你看过无数次如何读写文件，到了真正需要用它的时候，都是一脸懵”x”的，你只能模糊的记得好像学到过，但就是无法下手，本质上是因为你没有真正的场景去用它，对于刚接触编程的读者来说，一些简单的示例，无法在脑海中构建起一个完整的程序，这也是我刚开始就带领大家由浅入深去接触源码的原因。 编程思维首先这里的源码是对于我们运维人来说都熟知的CMDB的基本功能，大家在了解其功能的情况下，去思考如果这个代码是你写的，你会如何去实现这个CMDB基本的增删改查，然后在我们一起阅读源码的过程中，你会发现真正实现这些功能的过程是怎样的，慢慢去深入到具体的细节又该如何编写代码，这其实就是一个编程的思维，我们学任何一门语言，都不止是单纯的为了去学会它，然后用它，而是要了解面对一个大问题时候用编程去解决他的思维逻辑，这也就是为什么一些计算机专业毕业的同学，可以快速应对很多新技术的变迁。所以希望大家在阅读源码前能够有这样的认知，并且带着思考去一起学习。 CMDBv1.0.py伪代码首先我们先再熟悉一下CMDBv1.0.py的伪代码 123456789101112131415161718192021222324252627282930313233def get(): 查询内容def update(): 修改内容def delete(): 删除内容def init(): 初始化信息 def add(): 添加内容if __name__ == &quot;__main__&quot;: 通过命令行参数执行对应的操作 阅读源码前的思考上面说到希望读者们在阅读源码前要带着思考，这里的思考准确的就说，如果是你，你会如何去设计并且实现所需要的功能，虽然你不知道具体的代码如何写出来，但起码要去思考每一步应该怎么做，对于一些刚接触编程的读者，一开始就由我先来带着大家思考。 很多人一看到我们第一节中演示的功能时就已经懵了，内心os：”这么多复杂的步骤我从哪儿下手呢，根本毫无头绪“。那么其实我们的CMDBv1.0最主要的功能就是增删改查，具体的代码就应该是分别去实现增删改查四个不同的功能，然后在不同的情况下去使用这些功能就好了，这种思考貌似听起来是废话，但其实不然。如果你真的能够像我描述的这样思考，那恭喜你，其实你已经算是迈出了一大步，已经具备了将一个大问题去拆解成小问题的能力；如果你能再将其落地成我上述的伪代码形式，那么再次恭喜你，你已经具备了从一行行的脚本代码跨越到函数式编程的能力。 一开始不具备这种思维方式很正常，现在我已经向你演示了如何去分析拆解一个场景，那么接下来我们就继续深入，看看每一个步骤都是如何实现的。 上源码初始化地域信息一般对于运维资产的维护中，最顶层的是地域，也就是说我的设备是放在哪里的，那么我们CMDB如果需要录入设备信息之前，就必须要先初始化数据，那么初始化地域的代码如下： 1234567import jsondef init(region): data[region] = {&quot;idc&quot;: region, &quot;switch&quot;: {}, &quot;router&quot;: {}} print(json.dumps(data, indent=2)) 我们定义了一个函数叫做init，而这个函数需要传入一个region名称作为参数，这里的region其实就相当于我们的地域，我们此处假设一个region只有一个idc机房，那么我们需要初始化的数据格式如下： 12345678910111213data = { &quot;region名称&quot;: { &quot;idc&quot;: &quot;region名称&quot;, &quot;switch&quot;: {}, &quot;router&quot;: {} }} 而根据我们第一节课对于Python基本数据类型的学习来看，我们的数据源data是一个字典，那么给字典赋值的操作如下： 1data[region] = {&quot;idc&quot;: region, &quot;switch&quot;: {}, &quot;router&quot;: {}} 我们初始化好数据之后，肯定想将其打印出来看一看，那么可以使用print(data)将数据打印出来，但此处我们的data是一个字典，直接进行打印的结果可能像是如下这样： 1{&quot;region&quot;: {&quot;idc&quot;: &quot;region&quot;, &quot;switch&quot;: {}, &quot;router&quot;: {}}} 这种格式当数据越来越多的话就会很难阅读，所以我们利用到了一个Python的内置库json Tips：json库解读 Json（JavaScript Object Notation 的缩写）是一种数据交换格式，最常用于客户端-服务器通信；当然你也可以将它保存到本地，所以也可以用来作为配置文件；Json 很像 Python 中的字典，但Json本质上是一种字符串，所以在Python中需要利用其内置库 json，来实现Json字符串和字典的转换。 最常用的将Python中的字典与Json字符串进行转换的两个方法是 123data = json.loads(data_str) # 将json字符串转为字典data_str = json.dumps(data) # 将字典转为json字符串 代码中是将字典转为字符串之后打印出来，但大家注意代码中的写法是json.dumps(data, indent=2)，这时因为json.dumps可以传入很多参数，如下： 1json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw) 无论对于Python的内置方法时候第三方库，我们在调用其方法的时候，都可以通过跳转的方式，去进入到其源码中去看到他的实现逻辑，这里最常做的就是去看这些方法的注释以及参数说明。 Tips: 常见的vscode或者Pycharm都可以通过快捷键的方式去进行跳转，windows可以按住Ctrl+单击即可跳转，mac的话按住command+单击即可跳转。 这里我们跳转到json.dumps方法中去看看它的参数注释，但我们本着没用到就先忽略的原则，我们只了解其中的indent参数即可，注释如下： 12345If ``indent`` is a non-negative integer, then JSON array elements and object members will be pretty-printed with that indent level. An indentlevel of 0 will only insert new lines. ``None`` is the most compact representation.友情翻译如下：如果indent是一个非负整数，那么JSON数组或者对象成员将会被带着缩进层级优雅的打印出来，一个为0的缩进只会插入换行符，而当其为None时，JSON只会被最紧凑的表示出来。 所以通过注释可以理解为，indent其实就是帮助我们将json字符串好看的打印出来的参数，只要是正整数即可，大家可以自己去尝试不同的正整数打印出的结果。 现在我们已经了解了如何初始化一个地域，并且将其信息打印出来，但有一点需要注意的是，当程序结束后，我们的数据源data就会消失，当我们下次再次运行程序时，我们的数据源data仍然时空的。这里就涉及到数据的持久化。 Tips：持久化 因为Python程序运行过程中定义的所有变量，都只会存在于程序运行时计算机为其分配的内存空间里，此处设计到计算机组成原理的相关知识，我们会在番外篇中提到。而持久化的含义就是将数据永久的保存在磁盘上，这样我们每次都可以从磁盘上去读取数据。 Python中持久化数据的方式有很多种，而且在实际的企业应用中，肯定是将这些数据保存在数据库中，但因为我们目前还没有涉及到数据库的知识，且数据量较小，我们就暂且将其保存在文本文件中即可。这里我们仍然通过Python内置的json库来做数据的持久化和读取。 json库中还有两个常见的方法是 123data = json.load(f) # 从文件中读取内容并转为字典json.dump(data, d) # 将字典存到文件中 json数据的持久化如下 12345f = open(&quot;data.json&quot;, &quot;w+&quot;)json.dump(data, f)f.close() json数据的读取如下 12345f = open(&quot;data.json&quot;, &quot;r+&quot;)data = json.load(f)f.close() 划重点这里需要考虑一个特殊情况，当我们传入的region已经存在的时候会发生什么，比如有一个不太熟悉资产的同学使用了这个脚本，或者地域信息太多你自己也忘记已经存在哪些地域，那么这时候如果使用初始化功能去初始化一个已存在的地域时，这个地域的信息是不是就被清楚掉了，所以这里还需要补充一个判断条件 12345if region in data: print(&quot;region %s already exists&quot; % region) return 这里用到了一个条件判断，可以直接用 if key in dict的方式去判断字典中是否已存在这个键，当存在时我们就打印提示信息，并直接通过return退出该函数。 这里还用到了格式化字符串的操作，当我们的一个字符串中某个值为变量时，我们可以用上面的方式去表达，这里的%s表示字符，与之对应的还有%d表示整数，%f表示浮点数等，具体的其他格式化方法我们会在番外篇中提到。 Tips： 函数返回值 Python中的函数必然存在返回值，返回值可以是一个，也可以是多个，当函数中没有任何return语句时，函数的返回值即为None，当我们想要在指定地方显示的退出函数时可以直接用return，这时函数的返回值也为None。 当存在多个返回值时，可以直接使用return a, b，比如： 1234567891011121314151617181920212223def foo(): a = 1 b = 2 return a, b res = foo() # 这时的 res 值是一个元组类型， 输出结果为 (1, 2)a, b = foo() # 这里是用到了Python中的解包写法，解包的写法可以运用于Python的任何可迭代对象，比如 &gt; my_list1 = [1, 2]&gt; a, b = my_list # 最终的结果 a 为 1， b 为 2# 所以 a, b = foo() 等价于 res = foo()a, b = res 所以CMDB初始化地域的完整代码如下： 12345678910111213141516171819def init(region): with open(&quot;data.json&quot;, &quot;r+&quot;) as f: data = json.load(f) if region in data: print(&quot;region %s already exists&quot; % region) return data[region] = {&quot;idc&quot;: region, &quot;switch&quot;: {}, &quot;router&quot;: {}} with open(&quot;data.json&quot;, &quot;w+&quot;) as f: json.dump(data, f, indent=2) print(json.dumps(data, indent=2)) 细心的读者可能会发现怎么持久化的操作不太一样，这里是用到了一个Python中的语法糖，with... as，这样可以在对文件进行操作时，可以避免最后手动执行f.close()，具体with...as的原理我们会在番外篇中提到，这里大家先记住即可。 那么我们对于源码的解读这一节就先到这里，我们这一节最主要的是需要去学习培养正确的编程思维，学会在阅读源码前如何思考，如何带着思考去拆解源码。后面的章节我们会继续阅读其他功能模块，带领大家更进一步的探索Python的世界。 篇后语 最近听到了一个词叫做”知识的诅咒“，含义大概是，当你对某一个知识了解较深时，就无法准确的向别人解释清楚这个知识，因为你总是假设别人也和你一样有相同的知识背景。所以我在向大家传递Python的相关知识的时候，我其实有在刻意的避开这种诅咒，我写这个系列的本意也是想让没有接触过编程的同学能够更为通俗易懂的了解编程，并且上手写出自己真正需要的代码。所以如果大家对于我的讲解顺序或者逻辑有什么疑问和建议，也欢迎提出。","link":"/posts/d35c3607.html"},{"title":"自动化运维新手村-Python基础-4","text":"摘要首先说明，以下几类读者请自行对号入座： 对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇； 对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇； 已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇； 即了解Python，又了解CMDB的读者，可以出门左转，看下一篇。 上一节我带领读者们在阅读源码前进行了一系列思考，培养了一下大家的编程思想，并且紧接着阅读了CMDB v1.0.py的部分源码，那今天我们开篇就不再过多赘述，接上一节直接上干货。 上干货添加资产信息在初始化好地域信息之后，我们首先要做的就是添加资产信息了 按照我们上节课所讲，先要思考一下实现这个功能有哪些地方需要注意： 添加什么样的信息？ 将信息添加到哪里，如何定位到要添加的路径？ 如何把更新的数据持久化？ 这里我先依次给大家解答一下： 因为我们数据源是以JSON的格式存储在文本文件中，所以必须保证我们添加的信息也是json格式 JSON格式的数据源对应的是Python中的字典，所以字典是可以根据键进行索引的，那么我们可以通过多个键的排列去依次进行查找定位字典的位置，比如可以是key1/key2/key3的形式 数据的持久化依然选择通过JSON的方式将数据持久化到文本文件中 我们已经基本有了实现添加资产信息的思路，现在要做的就是将思路更进一步细化到可实现的伪代码： 我们需要定义一个add()函数来实现这个功能，并且这个函数需要接收两个参数，分别是要添加的信息和信息要更新到的指定路径，那么我们的函数签名应该是add(attrs, path) 这里的attrs是属性attributes的缩写，在写代码的过程中希望大家培养为变量起一个合适规范的名字的好习惯，初学者尽量避免使用拼音来给变量或函数命名，应该使用能表明变量含义的命名方式。 我们传入的attrs必须是一个json格式的字符串，传入的path必须是一个通过/分隔的字符串 通过path去按层级定位数据源中的指定位置，通过字典的赋值将attrs添加到数据源中 通过json.load和json.dump做数据持久化 接下来就是需要写出一份能实现上述功能的伪代码，如下： 123456789101112131415161718192021222324252627282930313233def add(path, attrs): # 判断attrs的合法性 if attrs is valid # 将attrs解析成Python类型 attrs = parse_attrs() # 从文本文件中读取数据源 data = read_file() # 分割path路径 seg = path.split() # 根据路径定位数据源的指定位置 target_path = position_data() # 将attrs添加到指定路径 data[target_path] = attrs # 将数据保存到文本文件 write_file(data) # 打印数据源 print(data) 那么最终添加资产信息的源代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def add(path, attrs=None): if attrs is None: # 判断attrs的合法性 print(&quot;add operation must have attrs arg&quot;) return try: # 将attrs解析成Python类型 attrs = json.loads(attrs) except Exception: print(&quot;input attribute is an invalid json string&quot;) return with open(&quot;data.json&quot;, &quot;r+&quot;) as f: # 从文本文件中读取数据源 data = json.load(f) path_seg = path.split(&quot;/&quot;) # 分割path路径 target_path = data for idx, seg in enumerate(path_seg[1:]): # 根据路径定位数据源的指定位置 if idx == len(path_seg)-2: if seg in target_path: print(&quot;%s already exists in %s, please use update operation&quot; % (seg, path)) return target_path[seg] = attrs # 将attrs添加到指定路径 break target_path = target_path[seg] with open(&quot;data.json&quot;, &quot;w+&quot;) as f: # 将数据保存到文本文件 json.dump(data, f, indent=2) print(json.dumps(data, indent=2)) # 打印数据源 很多读者可能第五步有点儿懵，有种刚学会1+1=2就跳到高等代数微积分的感觉，但其实把上述代码的每一部分单独拿出来还都是比较好理解的。 判断attrs的合法性并将attrs解析成Python类型 123456789101112131415if attrs is None: print(&quot;add operation must have attrs arg&quot;) returntry: # 将attrs解析成Python类型 attrs = json.loads(attrs)except Exception: print(&quot;input attribute is an invalid json string&quot;) return 这一步在解析参数的同时也是在判断attrs的合法性，因为我们要求输入的attrs参数不能为None且必须是一个json类型的字符串，那么我们理论上就可以通过json.loads将其进行解析，如果解析失败那么就说明该参数不是合法的json，就需要退出该函数；如果attrs为合法的json，那么我们就可以将其解析为Python中的数据类型应用于下面的代码中。关于try...except的详细讲解我们会在番外篇中提到。 Tips Python中None的判断 在Python中判断一个变量是否是None的写法不是 if var == None而是if var is None，这里我们推荐大家使用第二种方法，具体关于等于判断的区别我们会在番外篇中提到。 从文件中读取数据源 这一步就是运用我们上节课所讲的内容，此处不再赘述 分割path路径 1path_seg = path.split(&quot;/&quot;)[1:] # 分割path路径 这里就是运用到Python中对字符串的操作，str.split()用于分割字符串，通过传入分隔符，可以将字符串按分隔符切分成数组返回，所以这里的path_seg就是一个路径的数组，我们只需要根据这个数组，一层一层的定位到数据源的指定位置即可。这里同时运用到了数组切片的原理，因为我们的路径假设为/region/idc/switch的格式，所以按照/切割后，路径数组为[&quot;&quot;, &quot;region&quot;, &quot;idc&quot;, &quot;switch&quot;]，第一个元素为空字符串，所以通过path_seg[1:]的方式只取第二个到最后一个的路径元素。 根据路径定位数据源的指定位置并将attrs添加到指定路径 1234567891011121314151617target_path = datafor idx, seg in enumerate(path_seg): # 根据路径定位数据源的指定位置 if idx == len(path_seg)-1: if seg in target_path: print(&quot;%s already exists in %s, please use update operation&quot; % (seg, path)) return target_path[seg] = attrs # 将attrs添加到指定路径 break target_path = target_path[seg] 这一块可能是一个难点，需要大家对循环的有一定的理解，首先我们先定义一个目标路径的变量target_path，它一开始等于整个data的最外层，在后面的循环中它会不断的更新；在循环语句中用到了一个Python的语法糖enumerate()，通过传入一个可迭代对象(此处为我们的路径数组)，可以对于下标和内容同时进行循环遍历，所以for idx, seg in enumerate(path_seg[1:])这里的idx和seg分别表示路径数组中某一段路径的下标和内容。 这里向大家说明一下循环语句的本质原理，循环其实就是有一个可以重复的操作不停的在执行，当达到某一个边界条件时就退出循环，所以一般的循环语句都会存在边界条件，如果没有边界条件我们就称其为死循环。 我们上述代码块的边界条件就是遍历完整个路径数组，在每次遍历的时候对data一层一层的取值并返回，直到我们遍历到路径数组的最后一个元素（也就是其下标idx == len(path_seg)-1，之所以 -1是因为下标是从0开始的，所以数组的长度会比最后一个下标大1），这时候我们判断这个路径元素是否存在于当前位置，如果存在则说明不可以进行添加，直接通过return退出函数，如果不存在则我们通过字典赋值的方式将attrs添加到该位置，并通过break结束循环。 Tips: break与continue 对于刚接触编程的读者可能不太清楚break与continue的区别，break可以理解为直接退出这个循环，不管这个循环有没有到达边界条件；而continue则是跳过此次循环，如果还没有达到边界条件则继续进行下一次循环。如下代码 12345678910111213141516171819for i in [1, 2, 3]: if i == 2: continue print(i) # 输出 1 3 for i in [1, 2, 3]: if i == 2: break print(i) # 输出 1 上面的描述可能会有些晦涩难懂，下面我们通过Debug的方式看看每次循环时候的变量值就会清晰很多。 假设我们已经执行了语句python cmdb-v1.0.py init beijing，这时我们的数据源如下： 12345678910111213{ &quot;beijing&quot;: { &quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: {}, &quot;router&quot;: {} }} 那么这时候我们执行 python cmdb-v1.0.py add /beijing/switch/10.0.0.1 '{\\&quot;ip\\&quot;: \\&quot;10.0.0.1\\&quot;, \\&quot;role\\&quot;: \\&quot;asw\\&quot;}'进行调试 /beijing/switch/10.0.0.1就是我们要指定的路径 '{\\&quot;ip\\&quot;: \\&quot;10.0.0.1\\&quot;, \\&quot;role\\&quot;: \\&quot;asw\\&quot;}'就是我们要添加的信息，这里的信息是一个json格式的字符串 在还没有开始循环前的各变量值如下 此时的target_path = {&quot;beijing&quot;: {&quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: {}, &quot;router&quot;: {}}} 第一次循环结束后各变量值如下 此时的seg = &quot;beijing&quot; target_path = {&quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: {}, &quot;router&quot;: {}} 第二次循环结束后各变量值如下 此时的seg = &quot;switch&quot; target_path = {&quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: {}, &quot;router&quot;: {}} 当最后一次循环时 此时seg = &quot;10.0.0.1&quot; targe_path = {}，idc与path_seg长度相等，且seg原先不存在，所以可以将attrs更新到target_path上去。 根据上面一步一步的调试，我们可以清晰的看到每次循环中seg和target_path的变化，其实target_path是一个指针，它最开始指向字典的最外层，随着一次次的循环，它根据seg层层递进，直到指向目标路径，这时候将attrs添加上去就完成了最终操作。 最后的数据如下： 1234567891011121314151617181920212223{ &quot;beijing&quot;: { &quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: { &quot;10.0.0.1&quot;: { &quot;ip&quot;: &quot;10.0.0.1&quot;, &quot;role&quot;: &quot;asw&quot; } }, &quot;router&quot;: {} }} 这一节我们就先讲到这里，这次我们主要讲解了添加资产信息的详细源码，看起来虽然代码不长，但实际上需要注意的思想和需要新手朋友们注意的知识点还是有很多，希望大家可以自己亲自去调试运行一下，仔细体会一下每一次循环过程中变量的变化。一起期待我们下一节的继续讲解。 篇后语其实这一节除了代码细节的讲解之外，我们在阅读源码前的五个步骤是更为关键的部分。根 据我上面五个步骤的讲解，大家可以再次发现，在编程的过程中，前一到四步可以说是最终代码成型的地基，并且上面的四个步骤在进行的过程中并不需要我们真正掌握哪一门具体的编程语言，而是需要我们充分利用编程的思想，将要解决的问题逐步拆解；第五步才是真正需要利用代码实现，而且我们选择的Python是较为容易上手的语言，这也是对刚接触编程的朋友来说比较友好的。 最后希望大家能够在跟随我一步一步学习的过程中培养起良好的编程思想。��好的编程思想。","link":"/posts/4d38a3a4.html"},{"title":"自动化运维新手村-Python基础-5","text":"摘要首先说明，以下几类读者请自行对号入座： 对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇； 对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇； 已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇； 即了解Python，又了解CMDB的读者，可以出门左转，看下一篇。 上一节可能对刚开始编程的读者朋友们有一点挑战，其中涉及到通过循环来对复杂数据结构的修改，但只要大家认真理解了上一节的内容，这一节的内容就会感觉简单很多，这一节我们接着阅读剩余的对CMDB进行删改查的代码部分。 上干货在讲解删改查之前，我们需要再次回顾一下前两节的代码，看看有没有什么可以优化的地方。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import jsondef init(region): with open(&quot;data.json&quot;, &quot;r+&quot;) as f: data = json.load(f) if region in data: print(&quot;region %s already exists&quot; % region) return data[region] = {&quot;idc&quot;: region, &quot;switch&quot;: {}, &quot;router&quot;: {}} with open(&quot;data.json&quot;, &quot;w+&quot;) as f: json.dump(data, f, indent=2) print(json.dumps(data, indent=2)) def add(path, attrs=None): if attrs is None: print(&quot;add operation must have attrs arg&quot;) return try: attrs = json.loads(attrs) except Exception: print(&quot;input attribute is an invalid json string&quot;) return with open(&quot;data.json&quot;, &quot;r+&quot;) as f: data = json.load(f) path_seg = path.split(&quot;/&quot;)[1:] target_path = data for idx, seg in enumerate(path_seg): if idx == len(path_seg)-1: if seg in target_path: print(&quot;%s already exists in %s, please use update operation&quot; % (seg, path)) return target_path[seg] = attrs break target_path = target_path[seg] with open(&quot;data.json&quot;, &quot;w+&quot;) as f: data = json.dump(data, f, indent=2) print(json.dumps(data, indent=2)) 仔细的读者可能之前就已经发现，我们的初始化地域功能和新增资产信息功能都有对数据源的存取操作，而且看起来好像代码完全一样，那么在代码的重构原则中有涉及到，如果一段代码在两处及以上地方重复编写，那么就需要将其重构为单独的方法。 这个的意思就是说我们对数据源的存取已经有两处都使用了，而且可预见的是在之后的删改查中也会使用，那么我们就需要将其单独抽象为一个函数，这样就可以被不同的地方重复调用，重构后代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import jsondef read_file(): with open(&quot;data.json&quot;, &quot;r+&quot;) as f: data = json.load(f) return datadef write_file(data): with open(&quot;data.json&quot;, &quot;w+&quot;) as f: json.dump(data, f, indent=2)def init(region): data = read_file() if region in data: print(&quot;region %s already exists&quot; % region) return data[region] = {&quot;idc&quot;: region, &quot;switch&quot;: {}, &quot;router&quot;: {}} write_file(data) print(json.dumps(data, indent=2)) def add(path, attrs=None): if attrs is None: print(&quot;add operation must have attrs arg&quot;) return try: attrs = json.loads(attrs) except Exception: print(&quot;input attribute is an invalid json string&quot;) return data = read_file() path_seg = path.split(&quot;/&quot;)[1:] target_path = data for idx, seg in enumerate(path_seg): if idx == len(path_seg)-1: if seg in target_path: print(&quot;%s already exists in %s, please use update operation&quot; % (seg, path)) return target_path[seg] = attrs break target_path = target_path[seg] write_file(data) print(json.dumps(data, indent=2)) 大家可以看到，已经完成的代码会随着合理的重构优化而减少，因为我们会避免掉冗余的代码块，所以编程绝不是看谁写的行数多谁就会更牛X。 更新资产信息同样的更新资产信息的功能我们也需要五步法进行思考和实践 先要思考一下实现这个功能有哪些地方需要注意： 更新什么样的信息？ 如何定位到要更新的路径？ 这里我先依次给大家解答一下： 如何定位到要更新的路径这里我们在上一节介绍过，还不太理解的读者可以看上一节内容 我们要更新的信息的类型是一个需要注意的地方，因为我们的信息可以是字典格式，也可以是字符串或数组 现在要做的就是将思路更进一步细化到可实现的伪代码： 我们需要定义一个update()函数来实现这个功能，并且这个函数需要接收两个参数，分别是要更新的信息和信息要更新到的指定路径，那么我们的函数签名应该是update(path, attrs) 我们传入的attrs必须是一个JSON格式的字符串，传入的path必须是一个通过/分隔的字符串 通过path去按层级定位数据源中的指定位置，通过字典的赋值将attrs更新到数据源指定位置上 通过json.load和json.dump做数据持久化 接下来就是需要写出一份能实现上述功能的伪代码，如下： 123456789101112131415161718192021222324252627282930313233def update(path, attrs): # 判断attrs的合法性 if attrs is valid # 将attrs解析成Python类型 attrs = parse_attrs() # 从文本文件中读取数据源 data = read_file() # 分割path路径 seg = path.split() # 根据路径定位数据源的指定位置 target_path = position_data() # 将attrs更新到指定路径 data[target_path] = attrs # 将数据保存到文本文件 write_file(data) # 打印数据源 print(data) 大家可以发现更新和添加的逻辑十分相似，事实上在实际的其他增删改查场景中，更新和添加也都是如此。 最终更新资产信息的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def update(path, attrs=None): if attrs is None: # 判断attrs的合法性 print(&quot;add operation must have attrs arg&quot;) return try: attr_json = json.loads(attrs) except Exception: print(&quot;attributes is not valid json string&quot;) return data = read_file() target_path = data path_seg = path.split(&quot;/&quot;) for idx, seg in enumerate(path_seg[1:]): if idx == len(path_seg)-2: if seg not in target_path: print(&quot;update path is not exists in data, please use add function&quot;) return if type(attr_json) != type(target_path[seg]): print(&quot;update attributes and target_path attributes are different type.&quot;) return if isinstance(attr_json, dict): target_path[seg].update(attr_json) elif isinstance(attr_json, list): target_path[seg].extend(attr_json) else: target_path[seg] = attr_json else: target_path = target_path[seg] write_file(data) print(json.dumps(data, indent=2)) 更新有两个关键点需要大家注意一下： 5.1 在更新操作时，我们是对数据源中已存在的路径进行更新，这时候就涉及到数据的安全性，如果**attrs**为**None**可能会造成将原有信息清除。 判断attrs的合法性 12345if attrs is None: # 判断attrs的合法性 print(&quot;add operation must have attrs arg&quot;) return 我们首先要保证的就是attrs这个参数不能为None，**None**是Python中的一个表示空的变量类型，所以如果我们没有从命令行获取到attrs时，那么我们的程序应该给出提示，这里我是打印了一行提醒，要求添加资产的操作必须有attrs参数，然后直接return退出函数 5.2 第二点就是对于更新信息的类型，在添加功能中由于是在原先不存在的路径上新增信息，所以我们无需考虑**attrs**的类型，直接利用字典的特性进行赋值即可；但更新时，由于路径上已经存在数据，所以我们就需要对其类型做较为详细的判断。 更新属性 1234567891011121314151617181920212223if seg not in target_path: print(&quot;update path is not exists in data, please use add function&quot;) returnif type(attr_json) != type(target_path[seg]): print(&quot;update attributes and target_path attributes are different type.&quot;) returnif isinstance(attr_json, dict): target_path[seg].update(attr_json)elif isinstance(attr_json, list): target_path[seg].extend(attr_json)else: target_path[seg] = attr_json 需要判断要更新的路径是否在数据源中存在，如果不存在的话就需要使用添加的功能进行添加 需要对数据源中指定路径的类型和attrs的类型进行比较，如果类型不同也不可以进行更新 数据源中指定路径的类型是字典的话不可以直接赋值，这样会将原先的属性信息抹除，这里需要用到字典的一个特性dict.update()，这个功能接收一个参数，可以将两个字典合并，并且用参数字典中的信息更新原始字典中的信息。 如果源路径上的信息类型是数组，那么我们就需要将要更新的attrs添加到原来的信息上，这里用到了数组的一个特性list.extend()，这个功能接收一个参数，可以将参数数组合并到原始数组后面。 Tips: extend 和 append 关于数组的这两个方法是平时经常使用到的，通过例子大家就可以很好的理解用法： 123456789101112131415&gt; my_list = [1, 2, 3]&gt; new_list = [4, 5]&gt; my_list.append(new_list)&gt; my_list# 输出 [1, 2, 3, [4, 5]]&gt; my_list.extend(new_list)&gt; my_list# 输出 [1, 2, 3, 4, 5] 可以发现，append是将某个元素整体添加到了原始数组的末尾，而extend是将新的数组整合到原始数组末尾，并且通过查看这两个方法参数也可以看出区别 123456def append(self, __object: _T) -&gt; None: ...# append 方法可以接收传入任意类型的参数，因为这个方法只是将参数添加到了原始数组末尾def extend(self, __iterable: Iterable[_T]) -&gt; None: ...# extend 方法要求传入的参数必须是一个可迭代类型，因为这个方法会去迭代参数中的所有元素，将其整合到原始数组末尾 如果源路径上的信息类型不是字典也不是数组就可以直接赋值 到目前为止更新属性的功能也已经讲解完了，更新和添加大体上的逻辑类型，但更新中用到了大量了逻辑判断，关于判断语句还有一个需要和读者们讲解的地方，比如以上面更新方法中的多个逻辑判断为例，很多刚接触编程的读者可能会这样写： 1234567891011121314151617181920212223if seg in target_path: if type(attr_json) == type(target_path[seg]): if isinstance(attr_json, dict): target_path[seg].update(attr_json) elif isinstance(attr_json, list): target_path[seg].extend(attr_json) else: target_path[seg] = attr_json else: print(&quot;update attributes and target_path attributes are different type.&quot;)else: print(&quot;update path is not exists in data, please use add function&quot;) 通过这样多层次的**if...else...**嵌套，虽然也可以实现相同的功能，但对于代码的可读性上会是很大的灾难，并且多层嵌套对于后期逻辑的修改也是十分困难的，所以我们在编程的同时一定要尽力避免这种多层的嵌套。 一般常用的标准是对于循环语句和判断语句不要存在三层及以上的嵌套。那么当我们遇到上面的这种情况时，我们可以参照我给出的代码示例，先去判断非法逻辑，如果命中非法逻辑则直接抛出异常或者退出函数，这样一个简单的改动对代码的可读性和可维护性都会大大提高。 这一节我们又着重复习了一次五步法，并且对于更新功能的逻辑做了详细的解读，本来想把删除和查询也一起在这一节讲解，但又担心知识点太多，大家一时不太容易接受，之后我就不会再带着大家去一步一步的练习五步法，但这是一个熟能生巧的过程，希望读者朋友们能在自己实践的过程中潜移默化的使用它，我们下一节见。 篇后语​ 不知道大家在这几篇的学习中有没有发现，不管是在编程还是阅读源码前的逻辑梳理都十分的重要，而且代码中的很多部分都是对一些边界case的处理，所以对于伪代码的抽象也可以帮助我们更好的去理解复杂的业务逻辑。但这些边界case对于代码的健壮性又起到了关键作用，所以读者朋友们在编程的同时，也应该去培养对于边界case的敏感度，从不同维度去预判代码或者业务逻辑可能出现的逻辑，并提前规避它。 ​ 除此之外，虽然很多读者朋友是刚接触编程，但我们仍然从编程思维的养成和源码的阅读上，向大家普及一些更深入的东西，比如重构的原则，和多层嵌套的优雅处理等，所以我的本意是能够将这些知识在刚开始学习的时候就耳濡目染的让大家去了解，而不是说新手就应该死记硬背一些基础的方法和规范，这对于学习来说反而会适得其反，所以希望大家能在阅读文章的同时仔细去感受体会。","link":"/posts/3a3f9332.html"},{"title":"自动化运维新手村-Python基础-6","text":"摘要首先说明，以下几类读者请自行对号入座： 对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇； 对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇； 已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇； 即了解Python，又了解CMDB的读者，可以出门左转，看下一篇。 前面几节我们完成了CMDBv1.0版本最难的部分的讲解，这节内容我们就带领大家一次将删除和查询功能分析完成。话不多说上干货。 代码优化之前我们的新增和更新信息的功能中都有对attrs做校验和解析，那么我们是不是可以将其抽象成一个新的函数，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243def check_parse(attrs): if attrs is None: # 判断attrs的合法性 print(&quot;attributes is None&quot;) return try: attrs = json.loads(attrs) return attrs except Exception: print(&quot;attributes is not valid json string&quot;) return def add(path, attrs=None): attrs = check_parse(attrs) if not attrs: return ...def update(path, attrs=None): attrs = check_parse(attrs) if not attrs: return ... 恭喜我们的代码又成功减少几行 删除资产信息这一节我们就省略五步法的一些步骤，只对最关键的功能进行一下思考 在任何场景中一旦涉及到删除功能，就需要慎之又慎，绝不能多删误删，不然可能就要背锅走人了，那么我们在删除资产信息时需要注意什么呢，其实有时候为了保险期间我们会尽量使用更新去代替删除，但有一些多余的属性信息又不得不删除。 那么如果我们删除的路径上是一个字符串或者数字还比较简单，如果是一个字典，或者是一个数组，就需要格外注意了。 另外就是对于我们的参数，我们是否需要同时传入path和attrs。 源代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def delete(path, attrs=None): attrs = check_parse(attrs) path_seg = path.split(&quot;/&quot;)[1:] data = read_file() target_path = data for idx, seg in enumerate(path_seg): if seg not in target_path: print(&quot;delete target path not in data.&quot;) return if idx == len(path_seg)-1: if not attrs: target_path.pop(seg) break if isinstance(attrs, list): for attr in attrs: if attr not in target_path[seg]: print(&quot;attr %s not in target_path&quot; % attr) continue isinstance(target_path[seg], dict): target_path[seg].pop(attr) if isinstance(target_path[seg], list) target_path[seg].remove(attr) break target_path = target_path[seg] write_file(data) print(json.dumps(data, indent=2)) 这里首先仍然是对传入的属性值做解析，我们为什么不像add和update一样复用check_parse()方法，当解析到的attrs为None时就退出函数呢? 这里是因为我们的删除功能，可以不传attrs参数，有时候我们的目的就是直接删除数据源中的这个路径下的所有属性，那么就只需要传入path即可。 在查找指定路径的时候我们同样也做了优化，如下： 123456789for idx, seg in enumerate(path_seg): if seg not in target_path: print(&quot;delete target path not in data.&quot;) return ... 可以和之前定位路径的代码做一下对比： 1234567891011for idx, seg in enumerate(path_seg): if idx == len(path_seg)-1: if seg not in target_path: print(&quot;delete path is not exists in datan&quot;) return ... 我们之前在定位路径时，对path做了分割，只有在seg为path_seg的最后一个元素时才去判断是否这个seg在target_path上，这样就会导致程序运行很多无用的循环逻辑。 优化之后我们在每次循环的一开始就对seg做了判断，因为如果被分割开的path_seg中任何一段seg不在数据源路径中时，那么整段path就必然不可能在数据源中定位到，所以我们一旦检测到当前的**seg**不在**target_path**时就可以直接退出函数 删除功能中的核心代码块如下： 12345678910111213141516171819202122232425if idx == len(path_seg)-1: # 循环中定位到指定路径 if not attrs: target_path.pop(seg) if isinstance(attrs, list): for attr in attrs: if attr not in target_path[seg]: print(&quot;attr %s not in target_path&quot; % attr) continue if isinstance(target_path[seg], dict): target_path[seg].pop(attr) if isinstance(target_path[seg], list): target_path[seg].remove(attr) break 删除属性主要分为三个部分： 1.当我们没有传入要删除的attrs时，我们默认删除该路径下的所有内容，这里用到的操作是字典的删除功能dict.pop()，这个方法要求传入一个字典的键值，键值如果不存在会抛出异常，但由于我们在每次循环时都判断了seg是否在target_path中，所以程序运行到这里的话，这个路径就必然是存在的，那么我们通过target_path.pop(seg)就可以将该路径下面的属性全部删除 123if not attrs: target_path.pop(seg) Tips: 安全性 其实我们考虑到数据的安全性，应该在删除指定路径的全部属性时做一个判断，因为如果是忘记了输入attrs而造成了误删，那可能直接就一个P1了，所以我们可以这里将**attrs**传入一个**all**或者类似的标志，来表示确定删除指定路径下的全部属性。 2.当我们的指定路径下是一个字典并且传入的属性attrs是一个数组的时候，我们就去遍历attrs，将其元素一次从target_path下删除，这里有注意点就是我们在上面已经提到，dict.pop()必须传入字典中存在的键，所以我们在循环attrs时，需要先判断这个要删除的元素是否存在，如果不存在则使用**continue**跳过 12345678910111213if isinstance(attrs, list): for attr in attrs: if attr not in target_path[seg]: print(&quot;attr %s not in target_path&quot; % attr) continue if isinstance(target_path[seg], dict): target_path[seg].pop(attr) \\3. 当我们的指定路径下是一个数组，并且传入的属性attrs也是一个数组的时候，我们仍然通过遍历**attrs**的方式，将**attrs**中的元素依次从指定路径的数组下面移除，从数组中删除元素使用到了方法list.remove()，这个方法同样要求传入数组中已存在的元素，如果传入的元素不存在则会抛出异常。 12345678910111213if isinstance(attrs, list): for attr in attrs: if attr not in target_path[seg]: print(&quot;attr %s not in target_path&quot; % attr) continue if isinstance(target_path[seg], dict): target_path[seg].remove(attr) 查询资产信息终于到了增删改查的最后一个方法，其实查找是这四个方法中最为简单的，只需要定位到指定路径然后输出就好了，代码如下： 1234567891011121314151617181920212223def get(path): path_seg = path.split(&quot;/&quot;)[1:] data = read_file() target_path = data for idx, seg in enumerate(path_seg): if seg not in target_path: print(&quot;get path is not exists in data&quot;) return if idx == len(path_seg)-1: break target_path = target_path[seg] print(json.dumps(target_path, indent=2)) 不知道读者朋友们有没有觉得这段代码很眼熟，有没有触动你想要重构之前代码的想法。 完整重构：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259import jsonfrom os import readimport sysfrom typing import Iterabledef read_file(): with open(&quot;data.json&quot;, &quot;r+&quot;) as f: data = json.load(f) return datadef write_file(data): with open(&quot;data.json&quot;, &quot;w+&quot;) as f: json.dump(data, f, indent=2)def check_parse(attrs): if attrs is None: # 判断attrs的合法性 print(&quot;attributes is None&quot;) return try: attrs = json.loads(attrs) return attrs except Exception: print(&quot;attributes is not valid json string&quot;) returndef locate_path(data, path): target_path = data path_seg = path.split(&quot;/&quot;)[1:] for seg in path_seg[:-1]: if seg not in target_path: print(&quot;update path is not exists in data, please use add function&quot;) return target_path = target_path[seg] return target_path, path_seg[-1]def init(region): with open(&quot;data.json&quot;, &quot;r+&quot;) as f: data = json.load(f) if region in data: print(&quot;region %s already exists&quot; % region) return data[region] = {&quot;idc&quot;: region, &quot;switch&quot;: {}, &quot;router&quot;: {}} with open(&quot;data.json&quot;, &quot;w+&quot;) as f: json.dump(data, f, indent=2) print(json.dumps(data, indent=2))def add(path, attrs=None): attrs = check_parse(attrs) if not attrs: return with open(&quot;data.json&quot;, &quot;r+&quot;) as f: data = json.load(f) target_path, last_seg = locate_path(data, path) if last_seg in target_path: print(&quot;%s already exists in %s, please use update operation&quot; % (last_seg, path)) return target_path[last_seg] = attrs with open(&quot;data.json&quot;, &quot;w+&quot;) as f: data = json.dump(data, f, indent=2) print(json.dumps(data, indent=2))def update(path, attrs): attrs = check_parse(attrs) if not attrs: return data = read_file() target_path, last_seg = locate_path(data, path) if type(attrs) != type(target_path[last_seg]): print(&quot;update attributes and target_path attributes are different type.&quot;) return if isinstance(attrs, dict): target_path[last_seg].update(attrs) elif isinstance(attrs, list): target_path[last_seg].extend(attrs) target_path[last_seg] = list(set(target_path[last_seg])) else: target_path[last_seg] = attrs write_file(data) print(json.dumps(data, indent=2))def delete(path, attrs=None): attrs = check_parse(attrs) data = read_file() target_path, last_seg = locate_path(data, path) if not attrs: target_path.pop(last_seg) if isinstance(attrs, list): for attr in attrs: if attr not in target_path[last_seg]: print(&quot;attr %s not in target_path&quot; % attr) continue if isinstance(target_path[last_seg], dict): target_path[last_seg].pop(attr) if isinstance(target_path[last_seg], list): target_path[last_seg].remove(attr) write_file(data) print(json.dumps(data, indent=2))def get(path): data = read_file() target_path, last_seg = locate_path(data, path) print(json.dumps(target_path[last_seg], indent=2))if __name__ == &quot;__main__&quot;: operations = [&quot;get&quot;, &quot;update&quot;, &quot;delete&quot;] args = sys.argv if len(args) &lt; 3: print(&quot;please input operation and args&quot;) else: if args[1] == &quot;init&quot;: init(args[2]) elif args[1] == &quot;add&quot;: add(*args[2:]) elif args[1] == &quot;get&quot;: get(args[2]) elif args[1] == &quot;update&quot;: update(*args[2:]) elif args[1] == &quot;delete&quot;: delete(*args[2:]) else: print(&quot;operation must be one of get,update,delete&quot;) 总结经过我们一起不懈的努力，终于一行一行的读完了CMDBv1.0.py的源代码，理解了对资产信息增删改查的详细逻辑，并且在阅读源码的过程中逐步培养起良好的编程规范和编程思维，这对于大家以会起到至关重要的作用。 那么我们到此还没有结束，下一节我们会将CMDBv1.0利用面向对象的思想再次重构为CMDBv1.5，到时候将会是从函数式编程到面向对象编程的一个大的飞跃，敬请期待。","link":"/posts/a336c288.html"}],"tags":[{"name":"CMDB","slug":"CMDB","link":"/tags/CMDB/"},{"name":"Python基础","slug":"Python基础","link":"/tags/Python%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"新手村","slug":"新手村","link":"/categories/%E6%96%B0%E6%89%8B%E6%9D%91/"},{"name":"初级村","slug":"初级村","link":"/categories/%E5%88%9D%E7%BA%A7%E6%9D%91/"},{"name":"中级村","slug":"中级村","link":"/categories/%E4%B8%AD%E7%BA%A7%E6%9D%91/"},{"name":"高级村","slug":"高级村","link":"/categories/%E9%AB%98%E7%BA%A7%E6%9D%91/"}],"pages":[{"title":"test","text":"asdfasdfsadfsadf","link":"/test/index.html"}]}
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python玩转自动化运维</title>
    <url>/posts/5cb4afad.html</url>
    <content><![CDATA[<p><strong>专注于自动化运维领域，帮助任何想将编程与运维相结合的朋友，从零开始引领大家走进运维自动化。</strong></p>
<span id="more"></span>

<h2 id="内容受众"><a href="#内容受众" class="headerlink" title="内容受众"></a>内容受众</h2><p>你是否已经决定走上了<strong>运维工程师</strong>的道路，或者是深耕运维多年的老手；</p>
<p>升职加薪一直与自己绝缘，还总是锅从天上来；</p>
<p>看着别人自动化运维搞得风生水起，自己巡检两台设备的时间别人已经巡检好了一百台设备，还顺带出了个报表，你迷茫了；</p>
<p>人往往很难跳出自己的舒适圈，对于之前没有涉足过的领域也很难找到合适的切入点，再加上平时的工作已经足够焦头烂额，没有时间去从零开始学一门新技术。</p>
<h2 id="内容定位"><a href="#内容定位" class="headerlink" title="内容定位"></a>内容定位</h2><p>并不为了单纯的输出枯燥的知识点，区别于其他资料的随意搬运，东一榔头西一棒子；</p>
<p>而是从场景出发，使输出的内容具有<strong>实操性</strong>，<strong>自顶向下</strong>将具体场景拆分，并落实到每个知识点，让同学清晰的意识到所学知识能够如何运用；</p>
<p>让运维老手掌握平时经常听到的 <strong>Netmiko, SNMP, Netconf</strong>等知识，能够学有所得，学能所用；</p>
<p>番外篇会将正篇中涉及到的细节逐一展开，让计算机专业同学能够深入理解，夯实基础，逐步掌握操作系统，数据结构等专业知识；</p>
<p>并且也会涉及到<strong>编程思想，学习方法论</strong>等技巧，让大家有挑战大厂的底气。</p>
<h2 id="路径的选择"><a href="#路径的选择" class="headerlink" title="路径的选择"></a>路径的选择</h2><p>对于正在从事运维工作，但工作中遇到了一些自动化的需求的朋友，那么这里作者并不提倡大家去构建整个的自动化运维体系，一个是没有必要，另一个是这也可能会消耗相当大的精力，所以我们就暂时只点与自己<strong>实际工作相关的技能</strong>即可，全部的技能树如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/05/WqE3Gb1TmsiQrjY.png" alt="img"></p>
<h2 id="路径的规划"><a href="#路径的规划" class="headerlink" title="路径的规划"></a>路径的规划</h2><h3 id="一、【自动化运维新手村】"><a href="#一、【自动化运维新手村】" class="headerlink" title="一、【自动化运维新手村】"></a>一、【<strong>自动化运维新手村</strong>】</h3><p>那么对于自动化运维来说肯定首推的编程语言就是Python。</p>
<p>但网上对于Python语言的教程一抓一大把，我为什么还要在这里去讲解呢？这其实等同于另一个问题：<strong>刚接触编程的人是否能通过看类似的教程快速上手Python?</strong> 或者通俗易懂的讲：<strong>是不是能看得懂?</strong></p>
<p>大部分从事运维工作的朋友可能都没有编程经验，也没有系统的学习过计算机底层原理，所以对于标准式的教程就会感觉，<strong>好像会了，但又没有全会；好像会了，但又不会用</strong>，所以我根据自己的学习方法再加上身边运维朋友们的学习经历，通过一些生动的例子和实际的场景来让大家快速的上手Python这门语言，并且能直接运用于实际工作中。</p>
<blockquote>
<p> 新手村的内容主要是为大家搭建一个简易的CMDB（资产管理），这也符合很多运维朋友的实际需求场景，比如想要做一个小功能，可以提供给其他人使用。除此之外也会对其中涉及到的部分知识点进行详细的深入挖掘，呈现在番外篇中，让对其感兴趣的读者朋友去更多的了解。</p>
</blockquote>
<ul>
<li>Python基本数据结构和操作</li>
</ul>
<blockquote>
<p>将CMDB的增删改查与Python数据结构相结合，将枯燥的基础知识进行深入浅出的讲解</p>
</blockquote>
<ul>
<li><p>番外：数据结构的详解</p>
</li>
<li><p>番外：字符串的详解</p>
</li>
<li><p>番外：数组的详解</p>
</li>
<li><p>番外：字典的详解</p>
</li>
<li><p>面试番外：算法</p>
</li>
<li><p>Python函数与对象</p>
</li>
</ul>
<blockquote>
<p>将如何构建CMDB的函数与对象逐步拆解</p>
</blockquote>
<ul>
<li><p>番外：深入了解面向对象</p>
</li>
<li><p>番外：设计模式简介</p>
</li>
<li><p>Flask Web框架</p>
</li>
</ul>
<blockquote>
<p>将对CMDB的操作与Web框架相结合，通过API的方式对CMDB进行操作</p>
</blockquote>
<ul>
<li><p>面试番外：计算机网络</p>
</li>
<li><p>MySQL数据库</p>
</li>
</ul>
<blockquote>
<p>将CMDB存储到数据库中，对其进行的增删改查从对文件读写转移到对数据库进行操作</p>
</blockquote>
<ul>
<li><p>番外：MongoDB数据库</p>
</li>
<li><p>面试番外：数据库</p>
</li>
<li><p>Linux部署应用</p>
</li>
</ul>
<blockquote>
<p>将应用部署在Linux系统上稳定的运行</p>
</blockquote>
<ul>
<li>面试番外：操作系统</li>
</ul>
<h3 id="二、【自动化运维初级村】"><a href="#二、【自动化运维初级村】" class="headerlink" title="二、【自动化运维初级村】"></a>二、【<strong>自动化运维初级村</strong>】</h3><blockquote>
<p> 其实初级村的内容顺序的设计和新手村是类似的，但这一部分所运用的Python知识就会稍微深入，所以建议已经对Python有一定了解的朋友，可以跳过新手村直接看初级村的内容，因为初级村会是更多运维朋友们经常遇到的需求场景，也是做自动化运必须要走的路。</p>
</blockquote>
<ul>
<li>paramiko和netmiko</li>
</ul>
<blockquote>
<p>两者的使用方式及优劣</p>
</blockquote>
<ul>
<li>Python 正则解析</li>
</ul>
<blockquote>
<p>将通过SSH收集回来的各种信息进行正则解析</p>
</blockquote>
<ul>
<li><p>番外：text-fsm解析</p>
</li>
<li><p>Python snmp</p>
</li>
</ul>
<blockquote>
<p>如何使用Python调用SNMP采集指令，并讲解OID使用方式</p>
</blockquote>
<ul>
<li>NetConf</li>
</ul>
<blockquote>
<p>如何通过NetConf对网络设备进行操作</p>
</blockquote>
<ul>
<li>Crontab并回调CMDB</li>
</ul>
<blockquote>
<p>如何设置定时执行SSH任务进行定期巡检，并更新回写CMDB</p>
</blockquote>
<ul>
<li><p>番外：Python scheduler</p>
</li>
<li><p>Flask Web框架</p>
</li>
</ul>
<blockquote>
<p>将SSH和NetConf与Web框架相结合，通过API方式或前端调用其执行</p>
</blockquote>
<h3 id="三、【自动化运维中级村】"><a href="#三、【自动化运维中级村】" class="headerlink" title="三、【自动化运维中级村】"></a>三、【<strong>自动化运维中级村</strong>】</h3><blockquote>
<p>中级村与初级村最大的不同就是，会从简单需求应用的完成，转变为更为复杂架构的设计与实现，以及能够支撑更大型运维的场景。</p>
</blockquote>
<ul>
<li>Celery任务队列</li>
</ul>
<blockquote>
<p>如何使用任务队列异步处理大量的SSH或NetConf执行操作</p>
</blockquote>
<ul>
<li><p>番外：Redis数据库</p>
</li>
<li><p>番外：RabbitMQ中间件</p>
</li>
<li><p>Rsyslog日志采集</p>
</li>
</ul>
<blockquote>
<p>通过Rsyslog收集设备日志并存储进行展示和查询。</p>
</blockquote>
<ul>
<li>Mysql性能优化</li>
</ul>
<blockquote>
<p>支持更大数据量的存储和查询，进行数据库的优化，分库和分表</p>
</blockquote>
<ul>
<li>ELK， Rsyslog - Kafkf - LogStash - ElasticSearch - Kibana</li>
</ul>
<blockquote>
<p>使用ELK套件对日志进行存储及展示</p>
</blockquote>
<ul>
<li>前后端分离</li>
</ul>
<blockquote>
<p>由于系统功能的丰富，需要实现前后端分离的应用。</p>
</blockquote>
<h3 id="四、【自动化运维高级村】"><a href="#四、【自动化运维高级村】" class="headerlink" title="四、【自动化运维高级村】"></a>四、【<strong>自动化运维高级村</strong>】</h3><blockquote>
<p>如果想要做一个完整的自动化运维系统，就必然需要有相应完善的自动化运维的理念和方法论，所以高级村会设计到更多关于自动化运维的理念介绍，以及更为复杂和适应更大型企业的自动化运维系统。 </p>
</blockquote>
<ul>
<li>Celery分时任务队列</li>
</ul>
<blockquote>
<p>使用Celery任务队列，将SNMP大量采集任务或SSH变更任务根据频率发布在不同的队列中进行高效采集</p>
</blockquote>
<ul>
<li>Flink处理</li>
</ul>
<blockquote>
<p>使用Flink对SNMP采集的数据进行清洗并存储</p>
</blockquote>
<ul>
<li>Rsyslog - Kafka - Consumer- MySQL</li>
</ul>
<blockquote>
<p>如何将设备上报的日志进行收集解析，并通过Kafka中间件削峰，并进行存储</p>
</blockquote>
<ul>
<li><p>番外： Kafka中间件</p>
</li>
<li><p>告警通知，屏蔽，抑制</p>
</li>
</ul>
<blockquote>
<p>如何设置告警的通知，屏蔽和抑制机制</p>
</blockquote>
<ul>
<li>任务编排</li>
</ul>
<blockquote>
<p>通过白屏方式将变更步骤注册为执行算子，并进行编排后下发</p>
</blockquote>
<ul>
<li>基于意图的分组配置下发</li>
</ul>
<blockquote>
<p>将设备根据角色分组，并设置基于意图的模板命令，使用SSH或NetConf方式与其结合对网络设备进行变更或查询操作</p>
</blockquote>
<h2 id="路径的总结"><a href="#路径的总结" class="headerlink" title="路径的总结"></a>路径的总结</h2><p>上述的路径梳理是一个目前我能给到大家的较为系统的自动化运维方面的实践，在更新的过程中，我可能会根据读者的需要或者平时的思考总结对内容进行更新迭代，所以说路径并不是固定的，它只是一个学习的方向，并且学习的过程必然是会有<strong>阻碍和困难</strong>的，希望大家都能有坚定的决心克服一个个的难点，当然也会提供给大家学习交流的群组，供大家互相探讨，互相进步，也欢迎大家有什么疑问都找我咨询。最后期待大家都能拿到属于自己的结果。</p>
]]></content>
      <categories>
        <category>新手村</category>
        <category>初级村</category>
        <category>中级村</category>
        <category>高级村</category>
      </categories>
  </entry>
  <entry>
    <title>1.2 自动化运维新手村-Python基础-2</title>
    <url>/posts/a45b0691.html</url>
    <content><![CDATA[<hr>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li><p>对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读此篇；</p>
</li>
<li><p>了解过Python基本的数据结构，但又没有经常在实践中运用的读者，建议阅读此篇；</p>
</li>
<li><p>已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇；</p>
</li>
</ul>
<p>上一节我们通过对自动化运维的基石–CMDBv1.0的演示，为大家讲了Python的基本数据类型和相关的操作，那么这一节我们就深入cmdb-v1.0.py的源码，并了解一下Python的语句，函数以及面向对象相关的知识。</p>
<p>一说到阅读源码很多读者就要慌了，觉得Python都没入门就阅读源码了？首先Python的一大好处就是，代码的逻辑像阅读英文一样简洁，并且我们的cmdb-v1.0.py的源码只有一百一十行左右，就实现了对资产数据增删改查的基本功能，话不多说，马上开始.</p>
<span id="more"></span>

<h2 id="Python脚本的启动"><a href="#Python脚本的启动" class="headerlink" title="Python脚本的启动"></a>Python脚本的启动</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root&gt; <span class="comment"># python ./cmdb-v1.0.py [额外参数...]</span></span><br></pre></td></tr></table></figure>

<p>在命令行中直接通过<code>python</code>加文件名就可以执行该脚本，那么当执行该脚本时，脚本内部做了什么操作呢</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    operations = [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line"></span><br><span class="line">    args = sys.argv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;please input operation and args&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> args[<span class="number">1</span>] == <span class="string">&quot;init&quot;</span>:</span><br><span class="line"></span><br><span class="line">            init(args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;add&quot;</span>:</span><br><span class="line"></span><br><span class="line">            add(*args[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;get&quot;</span>:</span><br><span class="line"></span><br><span class="line">            get(args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;update&quot;</span>:</span><br><span class="line"></span><br><span class="line">            update(args[<span class="number">2</span>], args[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;delete&quot;</span>:</span><br><span class="line"></span><br><span class="line">            delete(*args[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;operation must be one of get,update,delete&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码就是我们整个脚本的启动入口，大家最先看到的就是一行判断语句，那我们就先从判断语句开始讲起</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><blockquote>
<p>不管哪种编程语言，条件判断都是其最基本的逻辑，是让一行一行的代码能够被编排起来的最基本手段，条件判断可以实现在不同的情况下执行不同的代码块，如图所示</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/07/P5sqX6AYlHV3719.png" alt="img"></p>
<p>下面为Python判断语句的伪代码形式，当判断条件为真时执行语句1，为假时执行语句2，执行语句可以为多行，通过缩进来控制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件:</span><br><span class="line"></span><br><span class="line">    执行语句<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">    执行语句<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>我们的源码中的第一行 <code>if __name__ == &quot;__main__&quot;</code>，这就是一个字符串判断的语句，<code>__name__</code>是一个Python的内置变量，它表示当前被执行脚本的名称，所以此处判断语句的含义为<code>是否当前被执行脚本的名称等于&quot;__main__&quot;</code>，这里有两个地方需要大家注意一下：</p>
<ul>
<li>当使用<code>python 文件名.py</code>的方式执行脚本时，该脚本的<code>__name__</code>值即为<code>__main__</code></li>
<li>条件判断语句中<code>等于</code>通过<code>==</code>来表示，而非<code>=</code></li>
</ul>
<p>在掌握了判断语句的原理后，再加上我们上节内容所讲，我们就可以理解源码中启动入口的基本逻辑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前被执行脚本的名称是否等于&quot;__main__&quot;，如果等于执行以下语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line"></span><br><span class="line">    args = sys.argv  <span class="comment"># 获取命令行输入的参数，此处sys.argv为python的内置方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span>:  <span class="comment"># 如果参数数量小于3个，则执行以下语句</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;please input operation and args&quot;</span>)  <span class="comment"># 打印提示内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 如果参数数量不小于3个，则执行以下语句</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> args[<span class="number">1</span>] == <span class="string">&quot;init&quot;</span>:  <span class="comment"># 是否参数的第二个元素等于&quot;init&quot;(数组下标从0开始)</span></span><br><span class="line"></span><br><span class="line">            init(args[<span class="number">2</span>])  <span class="comment"># 如果等于&quot;init&quot;则执行该函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;add&quot;</span>:  <span class="comment"># 如果不等于&quot;init&quot;，则判断是否等于&quot;add&quot;</span></span><br><span class="line"></span><br><span class="line">            add(*args[<span class="number">2</span>:])  <span class="comment"># 如果等于&quot;add&quot;则执行该函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;get&quot;</span>:  <span class="comment"># 如果也不等于&quot;add&quot;，则判断是否等于&quot;get&quot;</span></span><br><span class="line"></span><br><span class="line">            get(args[<span class="number">2</span>])  <span class="comment"># 如果等于&quot;get&quot;则执行该函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;update&quot;</span>:  <span class="comment"># 如果也不等于&quot;get&quot;，则判断是否等于&quot;update&quot;</span></span><br><span class="line"></span><br><span class="line">            update(args[<span class="number">2</span>], args[<span class="number">3</span>])  <span class="comment"># 如果等于&quot;update&quot;则执行该函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;delete&quot;</span>:  <span class="comment"># 如果也不等于&quot;update&quot;，则判断是否等于&quot;delete&quot;</span></span><br><span class="line"></span><br><span class="line">            delete(*args[<span class="number">2</span>:])  <span class="comment"># 如果等于&quot;delete&quot;则执行该函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 如果都不等于则执行以下打印语句，输出提示</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;operation must be one of get,update,delete&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>大家可以发现只通过上述的条件判断语句就可以根据我们执行脚本时的命令行参数，去分别执行不同的增删改查的逻辑，读者可能对这里的<code>*arg</code>有一些疑问，我们会在番外篇中提到。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><blockquote>
<p>目前我们已经掌握了让脚本启动，并且根据不同的条件判断去依次执行语句的能力，不过这时程序还只是在顺序执行，如果我们想查询多个资产信息，那么就必须多次去执行查询的语句，这时候就需要使用循环语句，循环语句可以让我们执行某一个代码块多次，如图所示</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/04/07/Zg8y1lLrSFiYQtW.png" alt="img"></p>
<p>Python中的循环语句的伪代码形式如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 判断条件:  <span class="comment"># 只要判断条件为真就会一直执行语句1</span></span><br><span class="line"></span><br><span class="line">    执行语句<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>由于循环语句相对比较好理解，我们就先简单介绍以下，后面的源码中遇到时，再深入讲解一些细节</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>通过上面的学习我们已经能够比较好的编排自己的代码去顺序执行或者循环执行，但对于一些可以重复使用的语句，我们可以把其组织起来，将它们定义为一个函数，这样我们后续就可以直接去使用这个函数，而不必每次都编写大量相同的语句。</p>
</blockquote>
<p>Python中的函数伪代码形式如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名称</span>(<span class="params">参数...</span>)：</span><br><span class="line"></span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>

<p>比如我们源码中定义的查询资产信息的函数的伪代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">path</span>):  <span class="comment"># 函数名称为 get， 接受一个参数 path</span></span><br><span class="line"></span><br><span class="line">    打开资产信息的文件</span><br><span class="line"></span><br><span class="line">    根据参数path去查询资产信息中对应的信息</span><br><span class="line"></span><br><span class="line">    打印相关信息</span><br></pre></td></tr></table></figure>

<p>当我们定义好这样一个函数之后，我们后续就可以十分方便的去调用它，调用的方法就是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = get(<span class="string">&quot;/beijing/switch/10.0.0.1&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其实函数的本意就是我们将一些可被复用的代码进行提取，将其中可变的变量作为参数传入，而将其相同的逻辑保留，这样我们每次只需要传入不同的参数就可以执行该逻辑，不用在需要使用该逻辑的地方再次编写冗余的代码</p>
<p>比如在脚本的启动入口地方，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">path</span>):</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">path</span>):</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">path</span>):</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args[<span class="number">1</span>] == <span class="string">&quot;init&quot;</span>:</span><br><span class="line"></span><br><span class="line">    init(args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;get&quot;</span>:</span><br><span class="line"></span><br><span class="line">    get(args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;operation must be one of get,update,delete&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们只需要在执行脚本时，通过判断命令行的指令，就可以去执行不同的函数，十分方便，但这里有两个地方需要大家注意以下</p>
<ul>
<li>定义的函数只是语句的抽象逻辑，如果不调用它，那么它就永远不会执行，比如如果我们定义了一个删除的函数，但始终都没有任何地方去调用它，那么它就永远不会被执行</li>
<li><code>print()</code>其实也是一个函数，只不过它是Python的内置函数，它的功能相当于接收一个字符串，并将其输出到屏幕上，所以我们其实在尝试编写第一个python程序<code>print(&quot;hello world&quot;)</code>时，就已经无形中使用到了函数</li>
</ul>
<blockquote>
<p>Tips</p>
</blockquote>
<blockquote>
<p>大家可以设想以下，如果每次我们想将内容输出到屏幕，都需要自己去编写print的内部逻辑细节，那简直就是一场灾难；所以在什么时候将某个代码块抽象为函数，将多少逻辑的代码块抽象为一个函数，这其实是编程的艺术，取决于每个人对于实际场景的把握。但也有一些变成规范可依。</p>
</blockquote>
<blockquote>
<p>我们通常只将一个功能抽象为一个函数，也就是说每个函数只实现一个单一的功能。</p>
</blockquote>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote>
<p> 很多对于编程稍微有了解的读者都知道，面向对象是很多编程语言都有的一个特性，所谓面向对象其实是一种编程的思路，与之不同的思路还有面向过程；</p>
</blockquote>
<blockquote>
<p>比如同样要实现相同的功能，可以使用不同的思路，思路没有孰优孰劣之分，只要在当前场景适用即可</p>
</blockquote>
<p>虽然Python实现一些简单的功能，只需要面向过程即可，比如将目标场景，拆分为不同的步骤，将每个步骤定义为函数，然后通过编排函数去实现最终的目标，但Python本身从设计之处就是一门面向对象的语言，并且<strong>Python中一切皆对象</strong>。</p>
<p>那么对象究竟是什么：世界上的任何事物都可以把它看成一个对象，其具有自己的属性和行为，不同的对象之间通过方法来交互。</p>
<p>比如Python中的某个字符串，它就是一个对象，它具有自己属性和方法，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root&gt; <span class="comment"># a = &quot;string&quot;</span></span><br><span class="line"></span><br><span class="line">root&gt; <span class="comment"># dir(a)</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__getnewargs__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mod__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__rmod__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>, <span class="string">&#x27;center&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;encode&#x27;</span>, <span class="string">&#x27;endswith&#x27;</span>, <span class="string">&#x27;expandtabs&#x27;</span>, <span class="string">&#x27;find&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;format_map&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;isalnum&#x27;</span>, <span class="string">&#x27;isalpha&#x27;</span>, <span class="string">&#x27;isascii&#x27;</span>, <span class="string">&#x27;isdecimal&#x27;</span>, <span class="string">&#x27;isdigit&#x27;</span>, <span class="string">&#x27;isidentifier&#x27;</span>, <span class="string">&#x27;islower&#x27;</span>, <span class="string">&#x27;isnumeric&#x27;</span>, <span class="string">&#x27;isprintable&#x27;</span>, <span class="string">&#x27;isspace&#x27;</span>, <span class="string">&#x27;istitle&#x27;</span>, <span class="string">&#x27;isupper&#x27;</span>, <span class="string">&#x27;join&#x27;</span>, <span class="string">&#x27;ljust&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>, <span class="string">&#x27;lstrip&#x27;</span>, <span class="string">&#x27;maketrans&#x27;</span>, <span class="string">&#x27;partition&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27;rfind&#x27;</span>, <span class="string">&#x27;rindex&#x27;</span>, <span class="string">&#x27;rjust&#x27;</span>, <span class="string">&#x27;rpartition&#x27;</span>, <span class="string">&#x27;rsplit&#x27;</span>, <span class="string">&#x27;rstrip&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;splitlines&#x27;</span>, <span class="string">&#x27;startswith&#x27;</span>, <span class="string">&#x27;strip&#x27;</span>, <span class="string">&#x27;swapcase&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;translate&#x27;</span>, <span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;zfill&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>我们定义了一个字符串变量a，通过<code>dir</code>方法来查看其所具有的所有属性和方法。</p>
<p>面向对象只是解决问题的思路，我们并不是将问题拆解为不同的步骤，而是将问题分解为不同的对象，在我们的CMDBv1.0中，我们要解决的问题就是实现资产信息的增删改查，那么我们分析该问题发现需要两个对象来解决：</p>
<ul>
<li>资产对象<ul>
<li>属性：可以执行的操作，当前的版本，创建时间，上次修改的时间等</li>
<li>方法：增、删、改、查</li>
</ul>
</li>
<li>信息存储对象<ul>
<li>属性：存储的位置，数据的大小</li>
<li>方法：存，取</li>
</ul>
</li>
</ul>
<p>所以经过我们面向对象的拆解，最终将我们的问题从面向过程，即根据命令行参数的传入去执行不同的函数，而修改为了我们与资产对象进行交互，而资产对象与存储对象进行交互。</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><ul>
<li>开始初步阅读CMDBv1.0版本的源码</li>
<li>讲解了Python基本的条件语句和循环语句</li>
<li>讲解了Python的函数，以及面向对象的分析</li>
</ul>
<p>CMDB系列第二节我们就暂且讲到这里，对于判断语句和循环语句还有很多细节没有涉及到，但我们已经掌握了其基本的原理，并且我们了解了面向对象的思路。</p>
<p>后面的章节我们会继续阅读CMDBv1.0的源码，了解更为细节的内容，并且用面向对象的思路将CMDBv1.0改造为CMDBv1.5，敬请期待。</p>
<h1 id="篇后语"><a href="#篇后语" class="headerlink" title="篇后语"></a><strong>篇后语</strong></h1><p>很多读者在阅读的过程中可能发现，我们很多的知识都是浅尝辄止，看似都是一些皮毛，并没有什么真材实料，包括阅读源码也是，只看了个大概；</p>
<p>其实不然，当我们新上手一门新的技术时，我们并不能揪住一个知识点不放，比如字符串是一个对象，通过<code>dir</code>可以发现它有二十多个属性和二十多种方法，但我们难道要在一开始就都掌握并把他们背会吗？</p>
<p>答案当然是否定的，这些细节我们初期都不需要去深究，我们的场景是构建一个简易版CMDB，那么我们只需要一步一步将这过程中阻碍我们前进的知识掌握即可，具体的细节可以在后续的深入过程中去慢慢了解。</p>
<p>这也是为什么很多学生不愿意听老师讲课的原因，因为他并不知道我这节课学的知识点有什么用，只是机械的接受老师的灌输，所以好的学习方法一定是自顶向下的，希望读者朋友们能体会到其真正的内涵。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.3 自动化运维新手村-Python基础-3</title>
    <url>/posts/d35c3607.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li><p>对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇；</p>
</li>
<li><p>对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇；</p>
</li>
<li><p>已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇；</p>
</li>
</ul>
<p>上一节我们简单地阅读了CMDBv1.0.py的源码，了解到其基本的模块构成，并且结合实际的程序理解了Python的常用数据结构以及基本的条件语句与循环语句的运用。那么这一节我们将详细阅读每一个模块的代码，并将其所涉及的知识点拆解开来，帮助各位读者更快的进入到Python的世界。</p>
<span id="more"></span>

<h2 id="为什么要阅读源码"><a href="#为什么要阅读源码" class="headerlink" title="为什么要阅读源码"></a><strong>为什么要阅读源码</strong></h2><h5 id="填鸭式学习"><a href="#填鸭式学习" class="headerlink" title="填鸭式学习"></a>填鸭式学习</h5><p>在开始之前我想向大家说明的是，之所以才在第三节就带领大家深入到源码中去，是因为Python作为最易上手的解释型语言，其社区生态和包含的各种第三方库数不胜数，<strong>而且任何一门语言其内置的规范和方法对于初学者来说都无法穷尽，所以如果一点儿一点儿的去学习某个内置方法，某个包如何使用，在我看来其实是本末倒置的，任何在没有使用场景的情况下进行填鸭式的灌输内容，都是”耍流氓“</strong>。</p>
<h5 id="场景-lt-gt-知识点"><a href="#场景-lt-gt-知识点" class="headerlink" title="场景&lt;-&gt;知识点"></a>场景&lt;-&gt;知识点</h5><p>比如大家其他新手教程里十分常见的读写文件功能，说实话读写文件也就是一两行代码可以完成的事情，但哪怕你看过无数次如何读写文件，到了真正需要用它的时候，都是一脸懵”x”的，你只能模糊的记得好像学到过，但就是无法下手，<strong>本质上是因为你没有真正的场景去用它，对于刚接触编程的读者来说，一些简单的示例，无法在脑海中构建起一个完整的程序，这也是我刚开始就带领大家由浅入深去接触源码的原因。</strong></p>
<h5 id="编程思维"><a href="#编程思维" class="headerlink" title="编程思维"></a>编程思维</h5><p>首先这里的源码是对于我们运维人来说都熟知的CMDB的基本功能，大家在了解其功能的情况下，去思考如果这个代码是你写的，你会如何去实现这个CMDB基本的增删改查，然后在我们一起阅读源码的过程中，<strong>你会发现真正实现这些功能的过程是怎样的，慢慢去深入到具体的细节又该如何编写代码，这其实就是一个编程的思维，我们学任何一门语言，都不止是单纯的为了去学会它，然后用它，而是要了解面对一个大问题时候用编程去解决他的思维逻辑</strong>，这也就是为什么一些计算机专业毕业的同学，可以快速应对很多新技术的变迁。所以希望大家在阅读源码前能够有这样的认知，并且带着思考去一起学习。</p>
<h2 id="CMDBv1-0-py伪代码"><a href="#CMDBv1-0-py伪代码" class="headerlink" title="CMDBv1.0.py伪代码"></a><strong>CMDBv1.0.py伪代码</strong></h2><p>首先我们先再熟悉一下CMDBv1.0.py的伪代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(): </span><br><span class="line"></span><br><span class="line">    查询内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(): </span><br><span class="line"></span><br><span class="line">    修改内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(): </span><br><span class="line"></span><br><span class="line">    删除内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(): </span><br><span class="line"></span><br><span class="line">    初始化信息    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(): </span><br><span class="line"></span><br><span class="line">    添加内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line"></span><br><span class="line">    通过命令行参数执行对应的操作</span><br></pre></td></tr></table></figure>

<h2 id="阅读源码前的思考"><a href="#阅读源码前的思考" class="headerlink" title="阅读源码前的思考"></a><strong>阅读源码前的思考</strong></h2><p>上面说到希望读者们在阅读源码前要带着思考，这里的思考准确的就说，<strong>如果是你，你会如何去设计并且实现所需要的功能，虽然你不知道具体的代码如何写出来，但起码要去思考每一步应该怎么做</strong>，对于一些刚接触编程的读者，一开始就由我先来带着大家思考。</p>
<p>很多人一看到我们第一节中演示的功能时就已经懵了，内心os：”这么多复杂的步骤我从哪儿下手呢，根本毫无头绪“。那么其实我们的CMDBv1.0最主要的功能就是增删改查，具体的代码就应该是分别去实现增删改查四个不同的功能，然后在不同的情况下去使用这些功能就好了，这种思考貌似听起来是废话，但其实不然。如果你真的能够像我描述的这样思考，那恭喜你，其实你已经算是迈出了一大步，已经具备了将一个大问题去拆解成小问题的能力；如果你能再将其落地成我上述的伪代码形式，那么再次恭喜你，你已经具备了从一行行的脚本代码跨越到函数式编程的能力。</p>
<p>一开始不具备这种思维方式很正常，现在我已经向你演示了如何去分析拆解一个场景，那么接下来我们就继续深入，看看每一个步骤都是如何实现的。</p>
<h2 id="上源码"><a href="#上源码" class="headerlink" title="上源码"></a><strong>上源码</strong></h2><h3 id="初始化地域信息"><a href="#初始化地域信息" class="headerlink" title="初始化地域信息"></a><strong>初始化地域信息</strong></h3><p>一般对于运维资产的维护中，最顶层的是地域，也就是说我的设备是放在哪里的，那么我们CMDB如果需要录入设备信息之前，就必须要先初始化数据，那么初始化地域的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">region</span>):</span><br><span class="line"></span><br><span class="line">    data[region] = &#123;<span class="string">&quot;idc&quot;</span>: region, <span class="string">&quot;switch&quot;</span>: &#123;&#125;, <span class="string">&quot;router&quot;</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>我们定义了一个函数叫做<code>init</code>，而这个函数需要传入一个<code>region</code>名称作为参数，这里的<code>region</code>其实就相当于我们的地域，我们此处假设一个<code>region</code>只有一个<code>idc</code>机房，那么我们需要初始化的数据格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">data = <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;region名称&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;idc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;region名称&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;switch&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;router&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span> </span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>而根据我们第一节课对于Python基本数据类型的学习来看，我们的数据源<code>data</code>是一个字典，那么给字典赋值的操作如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[region] = &#123;<span class="string">&quot;idc&quot;</span>: region, <span class="string">&quot;switch&quot;</span>: &#123;&#125;, <span class="string">&quot;router&quot;</span>: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>我们初始化好数据之后，肯定想将其打印出来看一看，那么可以使用<code>print(data)</code>将数据打印出来，但此处我们的data是一个字典，直接进行打印的结果可能像是如下这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;region&quot;: &#123;&quot;idc&quot;: &quot;region&quot;, &quot;switch&quot;: &#123;&#125;, &quot;router&quot;: &#123;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这种格式当数据越来越多的话就会很难阅读，所以我们利用到了一个Python的内置库<code>json</code></p>
<blockquote>
<p><strong>Tips：json库解读</strong></p>
</blockquote>
<blockquote>
<p>Json（JavaScript Object Notation 的缩写）是一种数据交换格式，最常用于客户端-服务器通信；当然你也可以将它保存到本地，所以也可以用来作为配置文件；Json 很像 Python 中的字典，但Json本质上是一种字符串，所以在Python中需要利用其内置库 json，来实现Json字符串和字典的转换。</p>
</blockquote>
<blockquote>
<p>最常用的将Python中的字典与Json字符串进行转换的两个方法是</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = json.loads(data_str)  <span class="comment"># 将json字符串转为字典</span></span><br><span class="line"></span><br><span class="line">data_str = json.dumps(data)  <span class="comment"># 将字典转为json字符串</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码中是将字典转为字符串之后打印出来，但大家注意代码中的写法是<code>json.dumps(data, indent=2)</code>，这时因为<code>json.dumps</code>可以传入很多参数，如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.dumps(obj, skipkeys=<span class="literal">False</span>, ensure_ascii=<span class="literal">True</span>, check_circular=<span class="literal">True</span>, allow_nan=<span class="literal">True</span>, cls=<span class="literal">None</span>, indent=<span class="literal">None</span>, separators=<span class="literal">None</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, default=<span class="literal">None</span>, sort_keys=<span class="literal">False</span>, **kw)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>无论对于Python的内置方法时候第三方库，我们在调用其方法的时候，都可以通过跳转的方式，去进入到其源码中去看到他的实现逻辑，这里最常做的就是去看这些方法的注释以及参数说明。</p>
</blockquote>
<blockquote>
<p>Tips: 常见的vscode或者Pycharm都可以通过快捷键的方式去进行跳转，windows可以按住Ctrl+单击即可跳转，mac的话按住command+单击即可跳转。</p>
</blockquote>
<blockquote>
<p>这里我们跳转到<code>json.dumps</code>方法中去看看它的参数注释，但我们本着没用到就先忽略的原则，我们只了解其中的<code>indent</code>参数即可，注释如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If ``indent`` is a non-negative integer, then JSON array elements and object members will be pretty-printed with that indent level. An indentlevel of 0 will only insert new lines. ``None`` is the most compact representation.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">友情翻译如下：如果indent是一个非负整数，那么JSON数组或者对象成员将会被带着缩进层级优雅的打印出来，一个为0的缩进只会插入换行符，而当其为None时，JSON只会被最紧凑的表示出来。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以通过注释可以理解为，<code>indent</code>其实就是帮助我们将json字符串好看的打印出来的参数，只要是正整数即可，大家可以自己去尝试不同的正整数打印出的结果。</p>
</blockquote>
<p>现在我们已经了解了如何初始化一个地域，并且将其信息打印出来，但有一点需要注意的是，当程序结束后，我们的数据源<code>data</code>就会消失，当我们下次再次运行程序时，我们的数据源<code>data</code>仍然时空的。这里就涉及到数据的持久化。</p>
<blockquote>
<p><strong>Tips：持久化</strong></p>
</blockquote>
<blockquote>
<p>因为Python程序运行过程中定义的所有变量，都只会存在于程序运行时计算机为其分配的内存空间里，此处设计到计算机组成原理的相关知识，我们会在番外篇中提到。而持久化的含义就是将数据永久的保存在磁盘上，这样我们每次都可以从磁盘上去读取数据。</p>
</blockquote>
<blockquote>
<p>Python中持久化数据的方式有很多种，而且在实际的企业应用中，肯定是将这些数据保存在数据库中，但因为我们目前还没有涉及到数据库的知识，且数据量较小，我们就暂且将其保存在文本文件中即可。这里我们仍然通过Python内置的json库来做数据的持久化和读取。</p>
</blockquote>
<blockquote>
<p>json库中还有两个常见的方法是</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = json.load(f)  <span class="comment"># 从文件中读取内容并转为字典</span></span><br><span class="line"></span><br><span class="line">json.dump(data, d)  <span class="comment"># 将字典存到文件中</span></span><br></pre></td></tr></table></figure>

<ul>
<li><blockquote>
<p>json数据的持久化如下</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w+&quot;</span>)</span><br><span class="line"></span><br><span class="line">json.dump(data, f)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<ul>
<li><blockquote>
<p>json数据的读取如下</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r+&quot;</span>)</span><br><span class="line"></span><br><span class="line">data = json.load(f)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h4 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a><strong>划重点</strong></h4><p>这里需要考虑一个特殊情况，当我们传入的<code>region</code>已经存在的时候会发生什么，比如有一个不太熟悉资产的同学使用了这个脚本，或者地域信息太多你自己也忘记已经存在哪些地域，那么这时候如果使用初始化功能去初始化一个已存在的地域时，这个地域的信息是不是就被清楚掉了，所以这里还需要补充一个判断条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> region <span class="keyword">in</span> data:    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;region %s already exists&quot;</span> % region)    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>这里用到了一个条件判断，可以直接用 <code>if key in dict</code>的方式去判断字典中是否已存在这个键，当存在时我们就打印提示信息，并直接通过<code>return</code>退出该函数。</p>
<p>这里还用到了格式化字符串的操作，当我们的一个字符串中某个值为变量时，我们可以用上面的方式去表达，这里的<code>%s</code>表示字符，与之对应的还有<code>%d</code>表示整数，<code>%f</code>表示浮点数等，具体的其他格式化方法我们会在番外篇中提到。</p>
<blockquote>
<p><strong>Tips： 函数返回值</strong></p>
</blockquote>
<blockquote>
<p>Python中的函数必然存在返回值，返回值可以是一个，也可以是多个，当函数中没有任何<code>return</code>语句时，函数的返回值即为<code>None</code>，当我们想要在指定地方显示的退出函数时可以直接用<code>return</code>，这时函数的返回值也为<code>None</code>。</p>
</blockquote>
<blockquote>
<p>当存在多个返回值时，可以直接使用<code>return a, b</code>，比如：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():    </span><br><span class="line"></span><br><span class="line">    a = <span class="number">1</span>    </span><br><span class="line"></span><br><span class="line">    b = <span class="number">2</span>    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">res = foo()  <span class="comment"># 这时的 res 值是一个元组类型， 输出结果为 (1, 2)a, b = foo()  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是用到了Python中的解包写法，解包的写法可以运用于Python的任何可迭代对象，比如 </span></span><br><span class="line"></span><br><span class="line">&gt; my_list1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">&gt; a, b = my_list  <span class="comment"># 最终的结果 a 为 1， b 为 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以 a, b = foo() 等价于 </span></span><br><span class="line"></span><br><span class="line">res = foo()</span><br><span class="line"></span><br><span class="line">a, b = res</span><br></pre></td></tr></table></figure>

<p>所以CMDB初始化地域的完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">region</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> region <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;region %s already exists&quot;</span> % region)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data[region] = &#123;<span class="string">&quot;idc&quot;</span>: region, <span class="string">&quot;switch&quot;</span>: &#123;&#125;, <span class="string">&quot;router&quot;</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>细心的读者可能会发现怎么持久化的操作不太一样，这里是用到了一个Python中的语法糖，<code>with... as</code>，这样可以在对文件进行操作时，可以避免最后手动执行<code>f.close()</code>，具体<code>with...as</code>的原理我们会在番外篇中提到，这里大家先记住即可。</p>
<p>那么我们对于源码的解读这一节就先到这里，我们这一节最主要的是需要去学习培养正确的编程思维，学会在阅读源码前如何思考，如何带着思考去拆解源码。后面的章节我们会继续阅读其他功能模块，带领大家更进一步的探索Python的世界。</p>
<h2 id="篇后语"><a href="#篇后语" class="headerlink" title="篇后语"></a><strong>篇后语</strong></h2><blockquote>
<p>最近听到了一个词叫做”知识的诅咒“，含义大概是，当你对某一个知识了解较深时，就无法准确的向别人解释清楚这个知识，因为你总是假设别人也和你一样有相同的知识背景。所以我在向大家传递Python的相关知识的时候，我其实有在刻意的避开这种诅咒，我写这个系列的本意也是想让没有接触过编程的同学能够更为通俗易懂的了解编程，并且上手写出自己真正需要的代码。所以如果大家对于我的讲解顺序或者逻辑有什么疑问和建议，也欢迎提出。</p>
</blockquote>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.4 自动化运维新手村-Python基础-4</title>
    <url>/posts/4d38a3a4.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li><p>对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇；</p>
</li>
<li><p>对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇；</p>
</li>
<li><p>已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇；</p>
</li>
<li><p>即了解Python，又了解CMDB的读者，可以出门左转，看下一篇。</p>
</li>
</ul>
<p>上一节我带领读者们在阅读源码前进行了一系列思考，培养了一下大家的编程思想，并且紧接着阅读了CMDB v1.0.py的部分源码，那今天我们开篇就不再过多赘述，接上一节直接上干货。</p>
<span id="more"></span>

<h2 id="上干货"><a href="#上干货" class="headerlink" title="上干货"></a><strong>上干货</strong></h2><h3 id="添加资产信息"><a href="#添加资产信息" class="headerlink" title="添加资产信息"></a><strong>添加资产信息</strong></h3><p>在初始化好地域信息之后，我们首先要做的就是添加资产信息了</p>
<ol>
<li>按照我们上节课所讲，先要思考一下实现这个功能有哪些地方需要注意：</li>
</ol>
<ul>
<li>添加什么样的信息？</li>
<li>将信息添加到哪里，如何定位到要添加的路径？</li>
<li>如何把更新的数据持久化？</li>
</ul>
<ol>
<li>这里我先依次给大家解答一下：</li>
</ol>
<ul>
<li>因为我们数据源是以<code>JSON</code>的格式存储在文本文件中，所以必须保证我们添加的信息也是<code>json</code>格式</li>
<li><code>JSON</code>格式的数据源对应的是Python中的字典，所以字典是可以根据键进行索引的，那么我们可以通过多个键的排列去依次进行查找定位字典的位置，比如可以是<code>key1/key2/key3</code>的形式</li>
<li>数据的持久化依然选择通过<code>JSON</code>的方式将数据持久化到文本文件中</li>
</ul>
<ol>
<li>我们已经基本有了实现添加资产信息的思路，现在要做的就是将思路更进一步细化到可实现的伪代码：</li>
</ol>
<ul>
<li>我们需要定义一个<code>add()</code>函数来实现这个功能，并且这个函数需要接收两个参数，分别是要添加的信息和信息要更新到的指定路径，那么我们的函数签名应该是<code>add(attrs, path)</code></li>
</ul>
<blockquote>
<p>这里的<code>attrs</code>是属性attributes的缩写，在写代码的过程中希望大家培养为变量起一个合适规范的名字的好习惯，初学者尽量避免使用拼音来给变量或函数命名，应该使用能表明变量含义的命名方式。</p>
</blockquote>
<ul>
<li>我们传入的<code>attrs</code>必须是一个json格式的字符串，传入的<code>path</code>必须是一个通过<code>/</code>分隔的字符串</li>
<li>通过<code>path</code>去按层级定位数据源中的指定位置，通过字典的赋值将<code>attrs</code>添加到数据源中</li>
<li>通过<code>json.load</code>和<code>json.dump</code>做数据持久化</li>
</ul>
<ol>
<li>接下来就是需要写出一份能实现上述功能的伪代码，如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">path, attrs</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断attrs的合法性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> attrs <span class="keyword">is</span> valid</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将attrs解析成Python类型</span></span><br><span class="line"></span><br><span class="line">    attrs = parse_attrs()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从文本文件中读取数据源</span></span><br><span class="line"></span><br><span class="line">    data = read_file()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分割path路径</span></span><br><span class="line"></span><br><span class="line">    seg = path.split()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据路径定位数据源的指定位置</span></span><br><span class="line"></span><br><span class="line">    target_path = position_data()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将attrs添加到指定路径</span></span><br><span class="line"></span><br><span class="line">    data[target_path] = attrs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将数据保存到文本文件</span></span><br><span class="line"></span><br><span class="line">    write_file(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印数据源</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<ol>
<li>那么最终添加资产信息的源代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 判断attrs的合法性</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;add operation must have attrs arg&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>: <span class="comment"># 将attrs解析成Python类型</span></span><br><span class="line"></span><br><span class="line">        attrs = json.loads(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;input attribute is an invalid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f: <span class="comment"># 从文本文件中读取数据源</span></span><br><span class="line"></span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    path_seg = path.split(<span class="string">&quot;/&quot;</span>) <span class="comment"># 分割path路径</span></span><br><span class="line"></span><br><span class="line">    target_path = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, seg <span class="keyword">in</span> <span class="built_in">enumerate</span>(path_seg[<span class="number">1</span>:]): <span class="comment"># 根据路径定位数据源的指定位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(path_seg)-<span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> seg <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s already exists in %s, please use update operation&quot;</span> %</span><br><span class="line"></span><br><span class="line">                      (seg, path))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            target_path[seg] = attrs <span class="comment"># 将attrs添加到指定路径</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        target_path = target_path[seg]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f: <span class="comment"># 将数据保存到文本文件</span></span><br><span class="line"></span><br><span class="line">        json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>)) <span class="comment"># 打印数据源</span></span><br></pre></td></tr></table></figure>

<p>很多读者可能第五步有点儿懵，有种刚学会<code>1+1=2</code>就跳到高等代数微积分的感觉，但其实把上述代码的每一部分单独拿出来还都是比较好理解的。</p>
<ul>
<li>判断<code>attrs</code>的合法性并将<code>attrs</code>解析成Python类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;add operation must have attrs arg&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:  <span class="comment"># 将attrs解析成Python类型</span></span><br><span class="line"></span><br><span class="line">    attrs = json.loads(attrs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;input attribute is an invalid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>这一步在解析参数的同时也是在判断<code>attrs</code>的合法性，因为我们要求输入的<code>attrs</code>参数不能为<code>None</code>且必须是一个json类型的字符串，那么我们理论上就可以通过<code>json.loads</code>将其进行解析，如果解析失败那么就说明该参数不是合法的json，就需要退出该函数；如果<code>attrs</code>为合法的json，那么我们就可以将其解析为Python中的数据类型应用于下面的代码中。关于<code>try...except</code>的详细讲解我们会在番外篇中提到。</p>
<blockquote>
<p>Tips Python中<code>None</code>的判断</p>
</blockquote>
<blockquote>
<p>在Python中判断一个变量是否是<code>None</code>的写法不是 <code>if var == None</code>而是<code>if var is None</code>，这里我们推荐大家使用第二种方法，具体关于等于判断的区别我们会在番外篇中提到。</p>
</blockquote>
<ul>
<li>从文件中读取数据源</li>
</ul>
<p>这一步就是运用我们上节课所讲的内容，此处不再赘述</p>
<ul>
<li>分割<code>path</code>路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path_seg = path.split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>:]  <span class="comment"># 分割path路径</span></span><br></pre></td></tr></table></figure>

<p>这里就是运用到Python中对字符串的操作，<code>str.split()</code>用于分割字符串，通过传入分隔符，可以将字符串按分隔符切分成数组返回，所以这里的<code>path_seg</code>就是一个路径的数组，我们只需要根据这个数组，一层一层的定位到数据源的指定位置即可。这里同时运用到了数组切片的原理，因为我们的路径假设为<code>/region/idc/switch</code>的格式，所以按照<code>/</code>切割后，路径数组为<code>[&quot;&quot;, &quot;region&quot;, &quot;idc&quot;, &quot;switch&quot;]</code>，第一个元素为空字符串，所以通过<code>path_seg[1:]</code>的方式只取第二个到最后一个的路径元素。</p>
<ul>
<li>根据路径定位数据源的指定位置并将<code>attrs</code>添加到指定路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target_path = data</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, seg <span class="keyword">in</span> <span class="built_in">enumerate</span>(path_seg): <span class="comment"># 根据路径定位数据源的指定位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(path_seg)-<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> seg <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s already exists in %s, please use update operation&quot;</span> % (seg, path))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        target_path[seg] = attrs <span class="comment"># 将attrs添加到指定路径</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    target_path = target_path[seg]</span><br></pre></td></tr></table></figure>

<p>这一块可能是一个难点，需要大家对循环的有一定的理解，首先我们先定义一个目标路径的变量<code>target_path</code>，它一开始等于整个data的最外层，在后面的循环中它会不断的更新；在循环语句中用到了一个Python的语法糖<code>enumerate()</code>，通过传入一个可迭代对象(此处为我们的路径数组)，可以对于下标和内容同时进行循环遍历，所以<code>for idx, seg in enumerate(path_seg[1:])</code>这里的<code>idx</code>和<code>seg</code>分别表示路径数组中某一段路径的下标和内容。</p>
<p>这里向大家说明一下循环语句的本质原理，循环其实就是有一个可以重复的操作不停的在执行，当达到某一个边界条件时就退出循环，所以一般的循环语句都会存在边界条件，如果没有边界条件我们就称其为死循环。</p>
<p>我们上述代码块的边界条件就是遍历完整个路径数组，在每次遍历的时候对<code>data</code>一层一层的取值并返回，直到我们遍历到路径数组的最后一个元素（也就是其下标<code>idx == len(path_seg)-1</code>，之所以 <code>-1</code>是因为下标是从<code>0</code>开始的，所以数组的长度会比最后一个下标大<code>1</code>），这时候我们判断这个路径元素是否存在于当前位置，如果存在则说明不可以进行添加，直接通过<code>return</code>退出函数，如果不存在则我们通过字典赋值的方式将<code>attrs</code>添加到该位置，并通过<code>break</code>结束循环。</p>
<blockquote>
<p><strong>Tips: break与continue</strong></p>
</blockquote>
<blockquote>
<p>对于刚接触编程的读者可能不太清楚break与continue的区别，break可以理解为直接退出这个循环，不管这个循环有没有到达边界条件；而continue则是跳过此次循环，如果还没有达到边界条件则继续进行下一次循环。如下代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 输出 1 3   </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br><span class="line"></span><br><span class="line"> <span class="comment"># 输出 1</span></span><br></pre></td></tr></table></figure>

<p>上面的描述可能会有些晦涩难懂，下面我们通过<code>Debug</code>的方式看看每次循环时候的变量值就会清晰很多。</p>
<p>假设我们已经执行了语句<code>python cmdb-v1.0.py init beijing</code>，这时我们的数据源如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;beijing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;idc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;switch&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;router&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>那么这时候我们执行</p>
<p><code>python cmdb-v1.0.py add /beijing/switch/10.0.0.1 &#39;&#123;\&quot;ip\&quot;: \&quot;10.0.0.1\&quot;, \&quot;role\&quot;: \&quot;asw\&quot;&#125;&#39;进行</code>调试</p>
<p><code>/beijing/switch/10.0.0.1</code>就是我们要指定的路径</p>
<p><code>&#39;&#123;\&quot;ip\&quot;: \&quot;10.0.0.1\&quot;, \&quot;role\&quot;: \&quot;asw\&quot;&#125;&#39;</code>就是我们要添加的信息，这里的信息是一个json格式的字符串</p>
<ol>
<li>在还没有开始循环前的各变量值如下</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/07/YujyWKrGqwLF7Oz.png" alt="img"></p>
<p>此时的<code>target_path = &#123;&quot;beijing&quot;: &#123;&quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: &#123;&#125;, &quot;router&quot;: &#123;&#125;&#125;&#125;</code></p>
<ol>
<li>第一次循环结束后各变量值如下</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/07/Q58rzW4SjhOTM6P.png" alt="img"></p>
<p>此时的<code>seg = &quot;beijing&quot;</code> <code>target_path = &#123;&quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: &#123;&#125;, &quot;router&quot;: &#123;&#125;&#125;</code></p>
<ol>
<li>第二次循环结束后各变量值如下</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/07/QDxHJRqs6krLfvB.png" alt="img"></p>
<p>此时的<code>seg = &quot;switch&quot;</code> <code>target_path = &#123;&quot;idc&quot;: &quot;beijing&quot;, &quot;switch&quot;: &#123;&#125;, &quot;router&quot;: &#123;&#125;&#125;</code></p>
<ol>
<li>当最后一次循环时</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/07/xXruqSYtLZNFGDU.png" alt="img"></p>
<p>此时<code>seg = &quot;10.0.0.1&quot;</code> <code>targe_path = &#123;&#125;</code>，<code>idc</code>与<code>path_seg</code>长度相等，且<code>seg</code>原先不存在，所以可以将<code>attrs</code>更新到<code>target_path</code>上去。</p>
<p>根据上面一步一步的调试，我们可以清晰的看到每次循环中<code>seg</code>和<code>target_path</code>的变化，其实<code>target_path</code>是一个指针，它最开始指向字典的最外层，随着一次次的循环，它根据<code>seg</code>层层递进，直到指向目标路径，这时候将<code>attrs</code>添加上去就完成了最终操作。</p>
<p>最后的数据如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;beijing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;idc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;switch&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;10.0.0.1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asw&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;router&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这一节我们就先讲到这里，这次我们主要讲解了添加资产信息的详细源码，看起来虽然代码不长，但实际上需要注意的思想和需要新手朋友们注意的知识点还是有很多，希望大家可以自己亲自去调试运行一下，仔细体会一下每一次循环过程中变量的变化。一起期待我们下一节的继续讲解。</p>
<h2 id="篇后语"><a href="#篇后语" class="headerlink" title="篇后语"></a>篇后语</h2><p>其实这一节除了代码细节的讲解之外，我们在阅读源码前的五个步骤是更为关键的部分。根</p>
<p>据我上面五个步骤的讲解，大家可以再次发现，在编程的过程中，前一到四步可以说是最终代码成型的地基，并且上面的四个步骤在进行的过程中并不需要我们真正掌握哪一门具体的编程语言，而是需要我们充分利用编程的思想，将要解决的问题逐步拆解；第五步才是真正需要利用代码实现，而且我们选择的Python是较为容易上手的语言，这也是对刚接触编程的朋友来说比较友好的。</p>
<p>最后希望大家能够在跟随我一步一步学习的过程中培养起良好的编程思想。��好的编程思想。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.5 自动化运维新手村-Python基础-5</title>
    <url>/posts/3a3f9332.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li><p>对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇；</p>
</li>
<li><p>对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇；</p>
</li>
<li><p>已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇；</p>
</li>
<li><p>即了解Python，又了解CMDB的读者，可以出门左转，看下一篇。</p>
</li>
</ul>
<p>上一节可能对刚开始编程的读者朋友们有一点挑战，其中涉及到通过循环来对复杂数据结构的修改，但只要大家认真理解了上一节的内容，这一节的内容就会感觉简单很多，这一节<strong>我们接着阅读剩余的对CMDB进行删改查的代码部分</strong>。</p>
<span id="more"></span>

<h2 id="上干货"><a href="#上干货" class="headerlink" title="上干货"></a><strong>上干货</strong></h2><p>在讲解删改查之前，我们需要再次回顾一下前两节的代码，看看有没有什么可以优化的地方。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">region</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> region <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;region %s already exists&quot;</span> % region)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data[region] = &#123;<span class="string">&quot;idc&quot;</span>: region, <span class="string">&quot;switch&quot;</span>: &#123;&#125;, <span class="string">&quot;router&quot;</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;add operation must have attrs arg&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        attrs = json.loads(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;input attribute is an invalid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    path_seg = path.split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    target_path = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, seg <span class="keyword">in</span> <span class="built_in">enumerate</span>(path_seg):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(path_seg)-<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> seg <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s already exists in %s, please use update operation&quot;</span> %</span><br><span class="line"></span><br><span class="line">                      (seg, path))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            target_path[seg] = attrs</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        target_path = target_path[seg]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        data = json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>仔细的读者可能之前就已经发现，我们的初始化地域功能和新增资产信息功能都有对数据源的存取操作，而且看起来好像代码完全一样，那么在代码的重构原则中有涉及到，<strong>如果一段代码在两处及以上地方重复编写，那么就需要将其重构为单独的方法</strong>。</p>
<p>这个的意思就是说我们对数据源的存取已经有两处都使用了，而且可预见的是在之后的删改查中也会使用，那么我们就<strong>需要将其单独抽象为一个函数</strong>，这样就可以被不同的地方重复调用，重构后代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_file</span>(<span class="params">data</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">region</span>):</span><br><span class="line"></span><br><span class="line">    data = read_file()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> region <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;region %s already exists&quot;</span> % region)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data[region] = &#123;<span class="string">&quot;idc&quot;</span>: region, <span class="string">&quot;switch&quot;</span>: &#123;&#125;, <span class="string">&quot;router&quot;</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    write_file(data)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;add operation must have attrs arg&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        attrs = json.loads(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;input attribute is an invalid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data = read_file()</span><br><span class="line"></span><br><span class="line">    path_seg = path.split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    target_path = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, seg <span class="keyword">in</span> <span class="built_in">enumerate</span>(path_seg):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(path_seg)-<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> seg <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s already exists in %s, please use update operation&quot;</span> %</span><br><span class="line"></span><br><span class="line">                      (seg, path))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            target_path[seg] = attrs</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        target_path = target_path[seg]</span><br><span class="line"></span><br><span class="line">    write_file(data)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>大家可以看到，已经完成的代码会随着<strong>合理的重构优化而减少</strong>，因为我们会避免掉冗余的代码块，所以编程<strong>绝不是看谁写的行数多谁就会更牛X</strong>。</p>
<h4 id="更新资产信息"><a href="#更新资产信息" class="headerlink" title="更新资产信息"></a><strong>更新资产信息</strong></h4><p>同样的更新资产信息的功能我们也需要<strong>五步法进行思考和实践</strong></p>
<ol>
<li><strong>先要思考一下实现这个功能有哪些地方需要注意：</strong></li>
</ol>
<ul>
<li>更新什么样的信息？</li>
<li>如何定位到要更新的路径？</li>
</ul>
<ol>
<li><strong>这里我先依次给大家解答一下：</strong></li>
</ol>
<ul>
<li>如何定位到要更新的路径这里我们在上一节介绍过，还不太理解的读者可以看上一节内容</li>
<li>我们要更新的信息的类型是一个需要注意的地方，因为我们的信息可以是字典格式，也可以是字符串或数组</li>
</ul>
<ol>
<li><strong>现在要做的就是将思路更进一步细化到可实现的伪代码：</strong></li>
</ol>
<ul>
<li>我们需要定义一个<code>update()</code>函数来实现这个功能，并且这个函数需要接收两个参数，分别是要更新的信息和信息要更新到的指定路径，那么我们的函数签名应该是<code>update(path, attrs)</code></li>
<li>我们传入的<code>attrs</code>必须是一个JSON格式的字符串，传入的<code>path</code>必须是一个通过<code>/</code>分隔的字符串</li>
<li>通过<code>path</code>去按层级定位数据源中的指定位置，通过字典的赋值将<code>attrs</code>更新到数据源指定位置上</li>
<li>通过<code>json.load</code>和<code>json.dump</code>做数据持久化</li>
</ul>
<ol>
<li><strong>接下来就是需要写出一份能实现上述功能的伪代码，如下：</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">update</span>(path, attrs):</span><br><span class="line"></span><br><span class="line">    # 判断attrs的合法性</span><br><span class="line"></span><br><span class="line">    if attrs <span class="keyword">is</span> valid</span><br><span class="line"></span><br><span class="line">    # 将attrs解析成Python类型</span><br><span class="line"></span><br><span class="line">    attrs <span class="operator">=</span> parse_attrs()</span><br><span class="line"></span><br><span class="line">    # 从文本文件中读取数据源</span><br><span class="line"></span><br><span class="line">    data <span class="operator">=</span> read_file()</span><br><span class="line"></span><br><span class="line">    # 分割path路径</span><br><span class="line"></span><br><span class="line">    seg <span class="operator">=</span> path.split()</span><br><span class="line"></span><br><span class="line">    # 根据路径定位数据源的指定位置</span><br><span class="line"></span><br><span class="line">    target_path <span class="operator">=</span> position_data()</span><br><span class="line"></span><br><span class="line">    # 将attrs更新到指定路径</span><br><span class="line"></span><br><span class="line">    data[target_path] <span class="operator">=</span> attrs</span><br><span class="line"></span><br><span class="line">    # 将数据保存到文本文件</span><br><span class="line"></span><br><span class="line">    write_file(data)</span><br><span class="line"></span><br><span class="line">    # 打印数据源</span><br><span class="line"></span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>

<p>大家可以发现更新和添加的逻辑十分相似，事实上在<strong>实际的其他增删改查场景中，更新和添加也都是如此</strong>。</p>
<ol>
<li><strong>最终更新资产信息的代码如下：</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 判断attrs的合法性</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;add operation must have attrs arg&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        attr_json = json.loads(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;attributes is not valid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data = read_file()</span><br><span class="line"></span><br><span class="line">    target_path = data</span><br><span class="line"></span><br><span class="line">    path_seg = path.split(<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, seg <span class="keyword">in</span> <span class="built_in">enumerate</span>(path_seg[<span class="number">1</span>:]):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(path_seg)-<span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> seg <span class="keyword">not</span> <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;update path is not exists in data, please use add function&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(attr_json) != <span class="built_in">type</span>(target_path[seg]):</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;update attributes and target_path attributes are different type.&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(attr_json, <span class="built_in">dict</span>):</span><br><span class="line"></span><br><span class="line">                target_path[seg].update(attr_json)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(attr_json, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">                target_path[seg].extend(attr_json)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                target_path[seg] = attr_json</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            target_path = target_path[seg]</span><br><span class="line"></span><br><span class="line">    write_file(data)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p><strong>更新有两个关键点需要大家注意一下：</strong></p>
<p><strong>5.1 在更新操作时，我们是对数据源中已存在的路径进行更新，这时候就涉及到数据的安全性，如果</strong><code>**attrs**</code><strong>为</strong><code>**None**</code><strong>可能会造成将原有信息清除。</strong></p>
<p>判断<code>attrs</code>的合法性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 判断attrs的合法性</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;add operation must have attrs arg&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>我们首先要保证的就是<code>attrs</code>这个参数不能为<code>None</code>，<code>**None**</code><strong>是Python中的一个表示空的变量类型</strong>，所以如果我们没有从命令行获取到<code>attrs</code>时，那么我们的程序应该给出提示，这里我是打印了一行提醒，要求添加资产的操作必须有<code>attrs</code>参数，然后直接<code>return</code>退出函数</p>
<p><strong>5.2 第二点就是对于更新信息的类型，在添加功能中由于是在原先不存在的路径上新增信息，所以我们无需考虑</strong><code>**attrs**</code><strong>的类型，直接利用字典的特性进行赋值即可；但更新时，由于路径上已经存在数据，所以我们就需要对其类型做较为详细的判断。</strong></p>
<p><strong>更新属性</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> seg <span class="keyword">not</span> <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;update path is not exists in data, please use add function&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(attr_json) != <span class="built_in">type</span>(target_path[seg]):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;update attributes and target_path attributes are different type.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(attr_json, <span class="built_in">dict</span>):</span><br><span class="line"></span><br><span class="line">    target_path[seg].update(attr_json)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">isinstance</span>(attr_json, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">    target_path[seg].extend(attr_json)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">    target_path[seg] = attr_json</span><br></pre></td></tr></table></figure>

<ul>
<li>需要判断要更新的路径是否在数据源中存在，如果不存在的话就需要使用添加的功能进行添加</li>
<li>需要对数据源中指定路径的类型和<code>attrs</code>的类型进行比较，如果类型不同也不可以进行更新</li>
<li>数据源中指定路径的类型是字典的话不可以直接赋值，这样会将原先的属性信息抹除，这里需要用到字典的一个特性<code>dict.update()</code>，这个功能接收一个参数，可以将两个字典合并，并且用参数字典中的信息更新原始字典中的信息。</li>
<li>如果源路径上的信息类型是数组，那么我们就需要将要更新的<code>attrs</code>添加到原来的信息上，这里用到了数组的一个特性<code>list.extend()</code>，这个功能接收一个参数，可以将参数数组合并到原始数组后面。</li>
</ul>
<blockquote>
<p><strong>Tips: extend 和 append</strong></p>
</blockquote>
<blockquote>
<p>关于数组的这两个方法是平时经常使用到的，通过例子大家就可以很好的理解用法：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">my_list = [1, 2, 3]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">new_list = [4, 5]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">my_list.append(new_list)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">my_list</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出 [1, 2, 3, [4, 5]]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">my_list.extend(new_list)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">my_list</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现，<code>append</code>是将某个元素整体添加到了原始数组的末尾，而<code>extend</code>是将新的数组整合到原始数组末尾，并且通过查看这两个方法参数也可以看出区别</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, __<span class="built_in">object</span>: _T</span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># append 方法可以接收传入任意类型的参数，因为这个方法只是将参数添加到了原始数组末尾</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self, __iterable: Iterable[_T]</span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># extend 方法要求传入的参数必须是一个可迭代类型，因为这个方法会去迭代参数中的所有元素，将其整合到原始数组末尾</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果源路径上的信息类型不是字典也不是数组就可以直接赋值</li>
</ul>
<p>到目前为止更新属性的功能也已经讲解完了，更新和添加大体上的逻辑类型，<strong>但更新中用到了大量了逻辑判断</strong>，关于判断语句还有一个需要和读者们讲解的地方，比如以上面更新方法中的多个逻辑判断为例，很多刚接触编程的读者可能会这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> seg <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">type</span>(attr_json) == <span class="built_in">type</span>(target_path[seg]):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(attr_json, <span class="built_in">dict</span>):</span><br><span class="line"></span><br><span class="line">        target_path[seg].update(attr_json)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(attr_json, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">         target_path[seg].extend(attr_json)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        target_path[seg] = attr_json</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;update attributes and target_path attributes are different type.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;update path is not exists in data, please use add function&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过这样<strong>多层次的</strong><code>**if...else...**</code><strong>嵌套</strong>，虽然也可以实现相同的功能，但对于<strong>代码的可读性上会是很大的灾难，并且多层嵌套对于后期逻辑的修改也是十分困难的</strong>，所以我们在编程的同时一定要尽力避免这种多层的嵌套。</p>
<p>一般常用的标准是<strong>对于循环语句和判断语句不要存在三层及以上的嵌套</strong>。那么当我们遇到上面的这种情况时，我们可以参照我给出的代码示例，先<strong>去判断非法逻辑，如果命中非法逻辑则直接抛出异常或者退出函数</strong>，这样一个简单的改动对代码的可读性和可维护性都会大大提高。</p>
<p>这一节我们又<strong>着重复习了一次五步法</strong>，并且对于更新功能的逻辑做了详细的解读，本来想把删除和查询也一起在这一节讲解，但又担心知识点太多，大家一时不太容易接受，之后我就不会再带着大家去一步一步的练习五步法，但这是一个熟能生巧的过程，<strong>希望读者朋友们能在自己实践的过程中潜移默化的使用它，我们下一节见。</strong></p>
<h2 id="篇后语"><a href="#篇后语" class="headerlink" title="篇后语"></a><strong>篇后语</strong></h2><p>​    不知道大家在这几篇的学习中有没有发现，<strong>不管是在编程还是阅读源码前的逻辑梳理都十分的重要</strong>，而且代码中的很多部分都是对一些边界case的处理，所以对于伪代码的抽象也可以帮助我们更好的去理解复杂的业务逻辑。但<strong>这些边界case对于代码的健壮性又起到了关键作用</strong>，所以读者朋友们在编程的同时，也应该去培养对于边界case的敏感度，从<strong>不同维度去预判代码或者业务逻辑可能出现的逻辑，并提前规避它。</strong></p>
<p>​    除此之外，虽然很多读者朋友是刚接触编程，但我们<strong>仍然从编程思维的养成和源码的阅读上，向大家普及一些更深入的东西</strong>，比如重构的原则，和多层嵌套的优雅处理等，所以我的本意是能够将这些知识在刚开始学习的时候就耳濡目染的让大家去了解，而<strong>不是说新手就应该死记硬背一些基础的方法和规范，这对于学习来说反而会适得其反</strong>，所以希望大家能在阅读文章的同时仔细去感受体会。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.6 自动化运维新手村-Python基础-6</title>
    <url>/posts/a336c288.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li>对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇；</li>
<li>对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇；</li>
<li>已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇；</li>
<li>即了解Python，又了解CMDB的读者，可以出门左转，看下一篇。</li>
</ul>
<span id="more"></span>

<p>前面几节我们完成了CMDBv1.0版本最难的部分的讲解，这节内容我们就带领大家一次将<strong>删除和查询功能分析完成</strong>。话不多说上干货。</p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a><strong>代码优化</strong></h2><p>之前我们的新增和更新信息的功能中都有对<code>attrs</code>做校验和解析，那么我们是不是可以将其抽象成一个新的函数，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_parse</span>(<span class="params">attrs</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 判断attrs的合法性</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;attributes is None&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        attrs = json.loads(attrs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;attributes is not valid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    attrs = check_parse(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    attrs = check_parse(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>恭喜我们的代码又成功减少几行</p>
<h3 id="删除资产信息"><a href="#删除资产信息" class="headerlink" title="删除资产信息"></a><strong>删除资产信息</strong></h3><p>这一节我们就省略五步法的一些步骤，只对最关键的功能进行一下思考</p>
<ul>
<li>在任何场景中一旦涉及到删除功能，就需要<strong>慎之又慎</strong>，绝不能多删误删，不然可能就要背锅走人了，那么我们在删除资产信息时需要注意什么呢，其实有时候为了保险期间我们<strong>会尽量使用更新去代替删除</strong>，但有一些多余的属性信息又不得不删除。</li>
<li>那么如果我们删除的路径上是一个字符串或者数字还比较简单，如果是一个字典，或者是一个数组，就需要<strong>格外注意</strong>了。</li>
<li>另外就是对于我们的参数，我们是否需要同时传入<code>path</code>和<code>attrs</code>。</li>
</ul>
<p>源代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    attrs = check_parse(attrs)</span><br><span class="line"></span><br><span class="line">    path_seg = path.split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    data = read_file()</span><br><span class="line"></span><br><span class="line">    target_path = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, seg <span class="keyword">in</span> <span class="built_in">enumerate</span>(path_seg):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> seg <span class="keyword">not</span> <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;delete target path not in data.&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(path_seg)-<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line"></span><br><span class="line">                target_path.pop(seg)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(attrs, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> attr <span class="keyword">in</span> attrs:</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> attr <span class="keyword">not</span> <span class="keyword">in</span> target_path[seg]:</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;attr %s not in target_path&quot;</span> % attr)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">isinstance</span>(target_path[seg], <span class="built_in">dict</span>):</span><br><span class="line"></span><br><span class="line">                    target_path[seg].pop(attr)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(target_path[seg], <span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">                  target_path[seg].remove(attr)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        target_path = target_path[seg]</span><br><span class="line"></span><br><span class="line">    write_file(data)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>这里首先仍然是对传入的属性值做解析，我们为什么不像<code>add</code>和<code>update</code>一样复用<code>check_parse()</code>方法，当解析到的<code>attrs</code>为<code>None</code>时就退出函数呢?</p>
<p>这里是因为我们的删除功能，可以不传<code>attrs</code>参数，有时候我们的目的就是直接删除数据源中的这个路径下的所有属性，那么就只需要传入<code>path</code>即可。</p>
<p><strong>在查找指定路径的时候我们同样也做了优化，如下</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, seg <span class="keyword">in</span> <span class="title function_">enumerate</span>(path_seg):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> seg not <span class="keyword">in</span> <span class="attr">target_path</span>:</span><br><span class="line"></span><br><span class="line">        <span class="title function_">print</span>(<span class="string">&quot;delete target path not in data.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><strong>可以和之前定位路径的代码做一下对比：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, seg <span class="keyword">in</span> <span class="title function_">enumerate</span>(path_seg):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="title function_">len</span>(path_seg)-<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> seg not <span class="keyword">in</span> <span class="attr">target_path</span>:</span><br><span class="line"></span><br><span class="line">          <span class="title function_">print</span>(<span class="string">&quot;delete path is not exists in datan&quot;</span>)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>我们之前在定位路径时，对<code>path</code>做了分割，只有在<code>seg</code>为<code>path_seg</code>的最后一个元素时才去判断是否这个<code>seg</code>在<code>target_path</code>上，这样就会导致程序运行<strong>很多无用的循环逻辑</strong>。</p>
<p>优化之后我们在每次循环的一开始就对<code>seg</code>做了判断，因为如果被分割开的<code>path_seg</code>中任何一段<code>seg</code>不在数据源路径中时，那么整段<code>path</code>就必然不可能在数据源中定位到，<strong>所以我们一旦检测到当前的</strong><code>**seg**</code><strong>不在</strong><code>**target_path**</code><strong>时就可以直接退出函数</strong></p>
<p><strong>删除功能中的核心代码块如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> idx == <span class="built_in">len</span>(path_seg)-<span class="number">1</span>: <span class="comment"># 循环中定位到指定路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line"></span><br><span class="line">        target_path.pop(seg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(attrs, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> attr <span class="keyword">in</span> attrs:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> attr <span class="keyword">not</span> <span class="keyword">in</span> target_path[seg]:</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;attr %s not in target_path&quot;</span> % attr)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(target_path[seg], <span class="built_in">dict</span>):</span><br><span class="line"></span><br><span class="line">                target_path[seg].pop(attr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(target_path[seg], <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">                target_path[seg].remove(attr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>删除属性主要分为三个部分：</p>
<p>1.当我们没有传入要删除的<code>attrs</code>时，我们<strong>默认删除该路径下的所有内容</strong>，这里用到的操作是字典的删除功能<code>dict.pop()</code>，这个方法要求传入一个字典的键值，键值如果不存在会抛出异常，但由于我们在每次循环时都判断了<code>seg</code>是否在<code>target_path</code>中，所以程序运行到这里的话，这个路径就必然是存在的，那么我们通过<code>target_path.pop(seg)</code>就可以将该路径下面的属性全部删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> not <span class="attr">attrs</span>:    </span><br><span class="line"></span><br><span class="line">    target_path.<span class="title function_">pop</span>(seg)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips: 安全性</p>
</blockquote>
<blockquote>
<p>其实我们考虑到数据的安全性，应该在删除指定路径的全部属性时做一个判断，因为如果是忘记了输入<code>attrs</code>而造成了误删，那可能直接就一个P1了，所以我们可以<strong>这里将</strong><code>**attrs**</code><strong>传入一个</strong><code>**all**</code><strong>或者类似的标志，来表示确定删除指定路径下的全部属性</strong>。</p>
</blockquote>
<p>2.当我们的指定路径下是一个字典并且传入的属性<code>attrs</code>是一个数组的时候，我们就去遍历<code>attrs</code>，将其元素一次从<code>target_path</code>下删除，这里有注意点就是我们在上面已经提到，<code>dict.pop()</code>必须传入字典中存在的键，所以我们在循环<code>attrs</code>时，需要<strong>先判断这个要删除的元素是否存在，如果不存在则使用</strong><code>**continue**</code><strong>跳过</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="title function_">isinstance</span>(attrs, list):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> <span class="attr">attrs</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> attr not <span class="keyword">in</span> target_path[seg]:</span><br><span class="line"></span><br><span class="line">            <span class="title function_">print</span>(<span class="string">&quot;attr %s not in target_path&quot;</span> % attr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_">isinstance</span>(target_path[seg], dict):</span><br><span class="line"></span><br><span class="line">            target_path[seg].<span class="title function_">pop</span>(attr)</span><br></pre></td></tr></table></figure>

<p>\3. 当我们的指定路径下是一个数组，并且传入的属性<code>attrs</code>也是一个数组的时候，<strong>我们仍然通过遍历</strong><code>**attrs**</code><strong>的方式，将</strong><code>**attrs**</code><strong>中的元素依次从指定路径的数组下面移除</strong>，从数组中删除元素使用到了方法<code>list.remove()</code>，这个方法同样要求传入数组中已存在的元素，如果传入的元素不存在则会抛出异常。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="title function_">isinstance</span>(attrs, list):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> attr <span class="keyword">in</span> <span class="attr">attrs</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> attr not <span class="keyword">in</span> target_path[seg]:</span><br><span class="line"></span><br><span class="line">            <span class="title function_">print</span>(<span class="string">&quot;attr %s not in target_path&quot;</span> % attr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_">isinstance</span>(target_path[seg], dict):</span><br><span class="line"></span><br><span class="line">            target_path[seg].<span class="title function_">remove</span>(attr)</span><br></pre></td></tr></table></figure>

<h3 id="查询资产信息"><a href="#查询资产信息" class="headerlink" title="查询资产信息"></a><strong>查询资产信息</strong></h3><p>终于到了增删改查的最后一个方法，其实查找是这四个方法中<strong>最为简单的，只需要定位到指定路径然后输出就好了</strong>，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">path</span>):</span><br><span class="line"></span><br><span class="line">    path_seg = path.split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    data = read_file()</span><br><span class="line"></span><br><span class="line">    target_path = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, seg <span class="keyword">in</span> <span class="built_in">enumerate</span>(path_seg):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> seg <span class="keyword">not</span> <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;get path is not exists in data&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(path_seg)-<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        target_path = target_path[seg]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(target_path, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>不知道读者朋友们有没有觉得这段代码很眼熟，有没有触动你想要重构之前代码的想法。</p>
<h2 id="完整重构："><a href="#完整重构：" class="headerlink" title="完整重构："></a><strong>完整重构：</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> read</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_file</span>(<span class="params">data</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_parse</span>(<span class="params">attrs</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 判断attrs的合法性</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;attributes is None&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        attrs = json.loads(attrs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;attributes is not valid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">locate_path</span>(<span class="params">data, path</span>):</span><br><span class="line"></span><br><span class="line">    target_path = data</span><br><span class="line"></span><br><span class="line">    path_seg = path.split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> path_seg[:-<span class="number">1</span>]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> seg <span class="keyword">not</span> <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;update path is not exists in data, please use add function&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        target_path = target_path[seg]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target_path, path_seg[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">region</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> region <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;region %s already exists&quot;</span> % region)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data[region] = &#123;<span class="string">&quot;idc&quot;</span>: region, <span class="string">&quot;switch&quot;</span>: &#123;&#125;, <span class="string">&quot;router&quot;</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    attrs = check_parse(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    target_path, last_seg = locate_path(data, path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> last_seg <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s already exists in %s, please use update operation&quot;</span> % (last_seg, path))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    target_path[last_seg] = attrs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.json&quot;</span>, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        data = json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">path, attrs</span>):</span><br><span class="line"></span><br><span class="line">    attrs = check_parse(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    data = read_file()</span><br><span class="line"></span><br><span class="line">    target_path, last_seg = locate_path(data, path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(attrs) != <span class="built_in">type</span>(target_path[last_seg]):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;update attributes and target_path attributes are different type.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(attrs, <span class="built_in">dict</span>):</span><br><span class="line"></span><br><span class="line">        target_path[last_seg].update(attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(attrs, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">        target_path[last_seg].extend(attrs)</span><br><span class="line"></span><br><span class="line">        target_path[last_seg] = <span class="built_in">list</span>(<span class="built_in">set</span>(target_path[last_seg]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        target_path[last_seg] = attrs</span><br><span class="line"></span><br><span class="line">    write_file(data)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    attrs = check_parse(attrs)</span><br><span class="line"></span><br><span class="line">    data = read_file()</span><br><span class="line"></span><br><span class="line">    target_path, last_seg = locate_path(data, path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line"></span><br><span class="line">        target_path.pop(last_seg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(attrs, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> attr <span class="keyword">in</span> attrs:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> attr <span class="keyword">not</span> <span class="keyword">in</span> target_path[last_seg]:</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;attr %s not in target_path&quot;</span> % attr)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(target_path[last_seg], <span class="built_in">dict</span>):</span><br><span class="line"></span><br><span class="line">                target_path[last_seg].pop(attr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(target_path[last_seg], <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">                target_path[last_seg].remove(attr)</span><br><span class="line"></span><br><span class="line">    write_file(data)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(data, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">path</span>):</span><br><span class="line"></span><br><span class="line">    data = read_file()</span><br><span class="line"></span><br><span class="line">    target_path, last_seg = locate_path(data, path)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(json.dumps(target_path[last_seg], indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    operations = [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line"></span><br><span class="line">    args = sys.argv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;please input operation and args&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> args[<span class="number">1</span>] == <span class="string">&quot;init&quot;</span>:</span><br><span class="line"></span><br><span class="line">            init(args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;add&quot;</span>:</span><br><span class="line"></span><br><span class="line">            add(*args[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;get&quot;</span>:</span><br><span class="line"></span><br><span class="line">            get(args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;update&quot;</span>:</span><br><span class="line"></span><br><span class="line">            update(*args[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;delete&quot;</span>:</span><br><span class="line"></span><br><span class="line">            delete(*args[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;operation must be one of get,update,delete&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>经过我们一起不懈的努力，终于一行一行的读完了CMDBv1.0.py的源代码，理解了对资产信息增删改查的详细逻辑，并且在阅读源码的过程中逐步培养起良好的编程规范和编程思维，这对于大家以会起到至关重要的作用。</p>
<p>那么我们到此还没有结束，下一节我们会将CMDBv1.0利用<strong>面向对象</strong>的思想再次重构为CMDBv1.5，到时候将会是从<strong>函数式编程到面向对象编程</strong>的一个大的飞跃，敬请期待。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.7 自动化运维新手村-Python基础-面向对象1</title>
    <url>/posts/e40a4156.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p> 首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li>对CMDB很了解但<strong>对于Python还没有上手</strong>的读者，强烈建议阅读前面几篇；</li>
<li>对Python了解较少<strong>只能写出简单脚本的读者</strong>，强烈建议阅读此篇；</li>
<li>已经可以熟练写出Python脚本，但<strong>对CMDB不是很了解的读者</strong>，建议阅读此篇；</li>
<li>即了解Python，又了解面向对象，可以出门左转，看下一篇。</li>
</ul>
<p>相信大家通过前几节的学习，对于Python已经有了一定的了解，并且也对CMDBv1.0的代码比较熟悉了。</p>
<p>我们这一节将迎来一个重头戏，这是所有学习编程的人的必经之路，那就是<strong>面向对象编程</strong>。在<strong>Python基础-2</strong>一节中，简短的提及到了面向对象这个概念，今天我们就来一探究竟。</p>
<span id="more"></span>

<h2 id="面向过程与面向对象的区别"><a href="#面向过程与面向对象的区别" class="headerlink" title="面向过程与面向对象的区别"></a><strong>面向过程与面向对象的区别</strong></h2><p>其实不管是计算机专业的同学还是转型刚接触编程的朋友，在刚了解到面向对象这个名词时都很懵x，说实话我大学里刚学习的时候也是这样。</p>
<p>所以我尽量让大家少走弯路，用很通俗易懂的方式，再结合CMDB的场景为大家一次性讲解清楚什么叫面向对象。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>\1. 面向过程是直接将解决问题的步骤分析出来，然后用函数把步骤一步一步实现，然后再依次调用就可以了；</p>
<p>\2. 面向对象是将构成问题的事物，分解成若干个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在解决问题过程中的行为。</p>
<p>上面两点是面向过程和面向对象的学术性的概念，在我看来，这两者本质的区别其实是看待问题的<strong>维度</strong>不同，并且程序员在解决问题时所扮演的<strong>角色</strong>也不同。</p>
<h3 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a><strong>本质区别</strong></h3><h4 id="维度"><a href="#维度" class="headerlink" title="维度"></a><strong>维度</strong></h4><p>​    1.1 面向过程要求我们从纵向看问题，将问题一步一步拆解然后去依次实现它们</p>
<p>​    1.2 面向对象要求我们从横向看问题，以整体的角度看待问题中存在的事物，这些事物就是对象</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h4><p>​    2.1 在通过面向过程的方法编写代码的时候，我们是一个士兵，是一个执行者，做的就是实现每一个步骤</p>
<p>   2.2 而以面向对象的方法编写代码时，我们更像一个元帅，纵观全局起到指挥作用。</p>
<h3 id="结合场景"><a href="#结合场景" class="headerlink" title="结合场景"></a><strong>结合场景</strong></h3><p>\1. CMDBv1.0就是一个十分经典的面向过程思维进行编程的例子，我们将CMDB要实现的基本功能进行了拆分，分为增删改查，然后一个一个函数去实现它们。</p>
<p>\2. 而今天就是要以面向对象的思维方式去解决CMDB的这些需求。</p>
<h2 id="面向对象方式看CMDB"><a href="#面向对象方式看CMDB" class="headerlink" title="面向对象方式看CMDB"></a><strong>面向对象方式看CMDB</strong></h2><p>目前已知初版的CMDB主要是需要增删改查这些基本功能，那我们就对这个场景进行分析，大家可以先想一想其中涉及到哪些对象，它们分别需要具备什么属性和方法？</p>
<h3 id="资产对象"><a href="#资产对象" class="headerlink" title="资产对象"></a><strong>资产对象</strong></h3><p>整个CMDB的数据源，它被称为资产对象</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a><strong>属性</strong></h5><p>   1.1 可执行操作：对资产对象目前可执行的操作包括新建地域以及增删改查</p>
<p>   1.2 数据源版本：每对数据源做一次操作都需要给数据源的变更版本做一个记录</p>
<p>   1.3 更新时间：每次对数据源中的数据做修改的时候都需要记录下更新的时间</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h5><p>​    2.1 新建地域</p>
<p>​    2.2 增加资产信息</p>
<p>​    2.3 删除资产信息</p>
<p>​    2.4 修改资产信息</p>
<p>​    2.5 查询资产信息</p>
<h3 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a><strong>存储对象</strong></h3><p>数据源存储在什么地方，相当于存储介质，也是一个对象</p>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a><strong>属性</strong></h5><p>   1.1 存储介质类型：当前数据源的存储介质是文本文件，之后可能还会存储在不同的数据库里</p>
<p>   1.2 存储的名称：当前是文本文件的文件名，之后可能还会是数据库的URI连接地址</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a><strong>方法</strong></h5><p>​    2.1存储</p>
<p>​    2.2 读取</p>
<h3 id="参数对象"><a href="#参数对象" class="headerlink" title="参数对象"></a><strong>参数对象</strong></h3><p>从哪里获取要执行的操作参数，这也是一个对象</p>
<h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a><strong>属性</strong></h5><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a><strong>方法</strong></h5><p>   2.1 解析参数：目前是通过命令行传入参数去进行解析，之后可能会通过http请求或其他方式传入参数</p>
<h2 id="Python-面向对象"><a href="#Python-面向对象" class="headerlink" title="Python 面向对象"></a><strong>Python 面向对象</strong></h2><p>之前文章也有提到，Python本身就是一个面向对象的语言，Python中的<strong>一切变量都是对象</strong>，在Python中创建一个对象的方法也很简单，在这之前我们需要了解一些面向对象的基本概念。</p>
<p>但这些概念真的很多，对于刚接触面向对象的读者来说十分不友好，所以<strong>本着用不到就先不学的原则</strong>，我就先挑几个重要的给大家列一下，具体其他的概念我会在番外篇中提到。</p>
<h4 id="类-Class"><a href="#类-Class" class="headerlink" title="类(Class)"></a><strong>类(Class)</strong></h4><p>用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
<h4 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a><strong>数据成员</strong></h4><p>类变量或者实例变量, 用于处理类及其实例对象的相关的数据。</p>
<h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a><strong>实例化</strong></h4><p>创建一个类的实例，类的具体对象。</p>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a><strong>方法</strong></h4><p>类中定义的函数。</p>
<h2 id="CMDBv1-5"><a href="#CMDBv1-5" class="headerlink" title="CMDBv1.5"></a><strong>CMDBv1.5</strong></h2><p>上面介绍了一堆思想和概念，现在结合CMDB更为深入的讲解一下关于面向对象中的一些概念</p>
<p>\1. 很多读者可能还是不太理解类和对象的关系，通俗的讲<strong>类其实就是一个抽象的东西，而对象就是把这个类具象化</strong>了。那么在CMDB里如何体现呢，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, store_type, store_uri</span>):</span><br><span class="line"></span><br><span class="line">        self.store_type = store_type <span class="comment"># 存储介质类型</span></span><br><span class="line"></span><br><span class="line">        self.store_uri = store_uri <span class="comment"># 存储的名称</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self, data</span>): <span class="comment"># 存储方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>) -&gt; <span class="built_in">dict</span>:  <span class="comment"># 读取方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>大家可以看到这里定义了一个<code>Store</code>类，那么这个类有什么作用呢，它其实就是一个抽象的对象，因为我们上面提到我们的存储对象包含了一些属性和方法。</p>
<p>也就是说<strong>不管最终这个CMDB的数据源存在哪里，存什么数据，读什么数据，我们都不关心，这个</strong><code>**Store**</code><strong>类的作用就是定义一个抽象的存储对象，告诉大家只要你是CMDB的存储对象，那你都应该长我</strong><code>**Store**</code><strong>类这个样子</strong>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">file_store = Store(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;data.json&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这行代码所做的就是<strong>实例化对象的操作</strong>，通俗的讲就是我根据之前定义的抽象的<code>Store</code>类，创建了一个真正的可以用于我存储和读取数据源的一个对象，这个对象就是<code>file_store</code>，之后我就可以通过这个<code>file_store</code>去对我真正的数据源做一些操作。</p>
<p><strong>所以本质上类和对象的关系就是抽象和具象的关系。</strong></p>
<p>\2. 大家现在大概了解了Python中类的定义和对象的创建，我们<strong>暂且先不对定义类和实例化过程中代码的细节是如何实现的。</strong></p>
<p>这一节主要是让大家能够对使用面向对象的思维解决CMDB的基本需求有一个总体的认知，现在可以仿照上面<code>Store</code>类来定义出其他的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMDB</span>:</span><br><span class="line"></span><br><span class="line">    operations = [<span class="string">&quot;init&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;get&quot;</span>]</span><br><span class="line"></span><br><span class="line">    version = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    update_time = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, op, args</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self, region</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, path, attrs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, path, attrs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, path, attrs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, path, attrs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Params</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, args</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<p>我们目前就已经定义好了三个类分别对应三个对象，并且定义好了它们应该具有的属性和方法，现在就可以去统筹的组织调用它们</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    cmd_params = Params() <span class="comment"># 实例化从命令行获取参数的对象</span></span><br><span class="line"></span><br><span class="line">    op, args = cmd_params.parse(sys.argv) <span class="comment"># 使用参数对象的解析方法解析出要做的操作和具体的参数</span></span><br><span class="line"></span><br><span class="line">    file_store = Store(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;data.json&quot;</span>) <span class="comment"># 实例化一个文件存储的存储对象</span></span><br><span class="line"></span><br><span class="line">    data = file_store.read() <span class="comment"># 使用存储对象的读取操作读出数据源的内容</span></span><br><span class="line"></span><br><span class="line">    cmdb = CMDB(data) <span class="comment"># 传入读出的数据源实例化一个CMDB的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> op <span class="keyword">not</span> in cmdb.operation: <span class="comment"># 判断参数对象解析出的操作是否在CMDB对象的操作属性内</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span>(<span class="string">&quot;%s cmdb operation is invalid&quot;</span> % op) <span class="comment"># 如果不在则打印错误提示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        cmdb.execute(op, args) <span class="comment"># 传入参数对象解析出的操作和具体参数，调用CMDB对象的执行操作方法</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>上面的内容主要就是对于使用面向对象的思维去解决CMDB基本需求的一个范例，大家可能心里会有很多疑问，这个<strong>面向对象看起来这么复杂繁琐，而且代码量看似也没有比面向过程的更少，反而有可能更多，为什么还要脱裤子放x去使用它呢？</strong></p>
<p>其实主要有两点：</p>
<ol>
<li>因为<strong>面向对象在本质上是与面向过程完全不同的思维方式</strong>，当我们面对简单问题的时候可能会看起来面向过程更顺手，写起来更方便。</li>
</ol>
<p>但一旦涉及到略微复杂的场景，就无法通过面向过程的方式去把这个复杂的问题一步一步拆开，然后去按顺序实现它，有时候也<strong>因为复杂的场景他本身就不是过程性的</strong>，所以自然也就不适合用面向过程的方式去解决。</p>
<ol>
<li>当使用面向对象的思维去解决一个问题的时候，我们最终的方案是一个<strong>相对开放且可扩展的。</strong></li>
</ol>
<p>比如，CMDB中的存储对象，目前使用的是最简单的文件存储，后续可能会扩展到数据库存储（甚至扩展到不同的数据库类型）。如果不把其作为一个对象看待，将会使代码变得杂乱无章，难以维护；而如果将其看作一个对象，并且定义好了存储对象应该有的属性和方法，则可以使用继承和多态（面向对象的特性后续会提到）的方式去扩充原先使用的存储方式。</p>
<p>并且在一个复杂的场景中，类似需要可扩展的对象会有更多，所以<strong>面向对象的思维是在编程的路上必不可少的一个技能</strong>。</p>
<p>最后希望大家认真体会今天的内容，下一节我们一起来阅读CMDBv1.5完整的代码，更进一步的了解面向对象的实践，敬请期待。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.8 自动化运维新手村-Python基础-面向对象2</title>
    <url>/posts/7d0310ec.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li><p>对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇；</p>
</li>
<li><p>对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇；  </p>
</li>
<li><p>已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇；  </p>
</li>
<li><p>即了解Python，又了解CMDB的读者，可以出门左转，看下一篇。</p>
</li>
</ul>
<p><strong>面向对象</strong>是所有刚接触编程的朋友都会遇到的一个大坎，但这个坎如果过不去，但就这辈子只能是个<strong>脚本小子</strong>，而一旦迈过这个坎，那<strong>编程世界的大门才算正式为你敞开</strong>。</p>
<p>上一讲我带领大家用面向对象的思想来重新设计了CMDB v1.0，虽然面向对象中还有诸多概念，包括<strong>封装，继承和多态</strong>，但暂时先不去深入那么多，具体的细节我会另开一个番外来讲解。</p>
<p><strong>对于刚接触编程的同学来说我们只要初步掌握这种思想即可，相信随着我们后续的深入学习，大家会越来越能体会到面向对象思想在程序设计上的精妙之处</strong>。</p>
<span id="more"></span>

<h2 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a><strong>类（Class）</strong></h2><p>我们已经知道面向对象是一种思想，那么在面向对象中最重要的就是类，并且在很多主流的编程语言中都存在类的概念，而Python又被称为<strong>所有变量皆对象</strong>，下面就详细探究一下<strong>Python中的类</strong>。</p>
<h3 id="类是对象的模版，对象是类的实例化"><a href="#类是对象的模版，对象是类的实例化" class="headerlink" title="类是对象的模版，对象是类的实例化"></a><strong>类是对象的模版，对象是类的实例化</strong></h3><p>这句话是大家必须要最先理解的。类是一种蓝图，是同一类型对象的抽象，比如定义一个Student类</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, name, age</span>):</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params"><span class="variable language_">self</span></span>):</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;%s is studying&quot;</span> % <span class="variable language_">self</span>.name)</span><br></pre></td></tr></table></figure>

<p>这个类具有name和age属性和study方法，那么这就表明定义的学生都抽象就是都应该具有名字和年龄，并且都会学习。</p>
<p>那么这时候就可以用这个抽象的类去实例化出很多学生</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ethan</span> = Student(<span class="string">&quot;ethan&quot;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="attribute">ethan</span>.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ethan</span>.study() # 输出 ethan is studying</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">allen</span> = Student(<span class="string">&quot;allen&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="attribute">allen</span>.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">allen</span>.study() # 输出 allen is studying</span><br></pre></td></tr></table></figure>

<p>上述代码就表示用学生<strong>类</strong>实例化出了两个学生<strong>对象</strong>，分别是ethan和allen，他们都具有各自的<strong>名字和年龄属性</strong>，并且都具备<strong>学习的方法</strong>。</p>
<h3 id="Python类的语法"><a href="#Python类的语法" class="headerlink" title="Python类的语法"></a><strong>Python类的语法</strong></h3><h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a><strong>定义类</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>以Student类为例，Python中定义一个类的关键字是<code>class</code>，<code>class</code>后面跟类名然后加<code>:</code>，一般类名的首字母大写，这里省略了<code>(Object)</code>，这是属于继承的概念，我们番外篇中再讲。</p>
<h4 id="实例化类"><a href="#实例化类" class="headerlink" title="实例化类"></a><strong>实例化类</strong></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ethan = Student()</span><br></pre></td></tr></table></figure>

<p>直接通过<code>类名()</code>就可以实例化一个类</p>
<h4 id="初始化类"><a href="#初始化类" class="headerlink" title="初始化类"></a><strong>初始化类</strong></h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, name, age</span>):</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br></pre></td></tr></table></figure>

<p>\1. <strong><strong>init</strong>()是所有类都有的一个函数，它始终在实例化类时执行，可以把它看作是初始化类的方法，例如</strong>：</p>
<p> <code>ethan = Student()</code>就是默认调用了<code>Student</code>的<code>__init__()</code>的方法</p>
<p>\2. <strong><strong>init</strong>()可以自己定义参数，这样在实例化类时就不能通过简单的</strong><code>**Student()**</code><strong>来操作，而必须传入相应的参数，例如：</strong></p>
<p>例如<code>ethan = Student(&quot;ethan&quot;, 18)</code></p>
<p>\3. <strong><strong>init</strong>()第一个参数必须是</strong><code>**self**</code><strong>，它表示创建的实例本身</strong>，例如：</p>
<p>创建<code>ethan</code>时，初始化函数里就可以通过<code>self.name = name</code>来给创建的<code>ethan</code>的实例属性赋值</p>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><strong>实例方法</strong></h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"><span class="variable language_">self</span>, name, age</span>):</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params"><span class="variable language_">self</span></span>):</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;%s is studying&quot;</span> % <span class="variable language_">self</span>.name)</span><br></pre></td></tr></table></figure>

<p><code>study是Student</code>的一个实例方法，该方法必须在实例化这个类后才能被调用，例如：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ethan</span> = Student(<span class="string">&quot;ethan&quot;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="attribute">ethan</span>.study()</span><br></pre></td></tr></table></figure>

<p>但假如直接调用 <code>Student.study</code>则会报错</p>
<p>\1. <strong>实例方法的特征为第一个参数必须为</strong><code>**self**</code>，上面已经提到<code>self</code>表示创建的实例本身，所以可想而之必须将类实例化之后才能被调用。</p>
<p><strong>2. 可以在实例方法中直接使用</strong><code>**self**</code><strong>中的属性</strong>，如上面代码中的<code>print(&quot;%s is studying&quot; % self.name)</code></p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h4><p>通过上面的例子大家可以看出<code>**self**</code><strong>的作用域为整个实例对象</strong>，也就是说只要将<code>Student</code>这个类实例化为对象后，<strong>这个</strong><code>**self**</code><strong>就会存在于整个实例对象中。</strong></p>
<h2 id="CMDB-v1-5源码阅读"><a href="#CMDB-v1-5源码阅读" class="headerlink" title="CMDB v1.5源码阅读"></a><strong>CMDB v1.5源码阅读</strong></h2><p>在经过上述基本的类的语法讲解之后，就可以开始尝试着看源码了，虽然Python中还有和类相关的很多用法，但了解大概之后细节就可以边看边学。</p>
<h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a><strong>存储类</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span>:</span><br><span class="line"></span><br><span class="line">    version = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    update_time = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, store_type, store_uri</span>):</span><br><span class="line"></span><br><span class="line">        self.store_type = store_type <span class="comment"># 存储介质类型</span></span><br><span class="line"></span><br><span class="line">        self.store_uri = store_uri <span class="comment"># 存储介质的路径</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self, data</span>):  <span class="comment"># 存储方法</span></span><br><span class="line"></span><br><span class="line">        data[<span class="string">&quot;version&quot;</span>] = (Store.version <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        data[<span class="string">&quot;update_time&quot;</span>] = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.store_uri, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">            json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):  <span class="comment"># 读取方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.store_uri, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">            data = json.load(f)</span><br><span class="line"></span><br><span class="line">            Store.version = data.pop(<span class="string">&quot;version&quot;</span>)</span><br><span class="line"></span><br><span class="line">            Store.update_time = data.pop(<span class="string">&quot;update_time&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    file_path = os.path.join(os.path.dirname(__file__), <span class="string">&quot;data.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    file_store = Store(<span class="string">&quot;FILE&quot;</span>, file_path) <span class="comment"># 实例化一个文件存储的存取对象</span></span><br></pre></td></tr></table></figure>

<p>上面这个类就是上一节提到的<strong>存储类</strong>，可以用它实例化出可以提供文件存取功能的存储对象（这里做了相应的优化，将数据源版本和数据更新时间属性归属到了存储类中）</p>
<p>先从入口函数看起</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    file_path = <span class="built_in">os</span>.<span class="built_in">path</span>.join(<span class="built_in">os</span>.<span class="built_in">path</span>.dirname(__file__), <span class="string">&quot;data.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">    file_store = Store(<span class="string">&quot;FILE&quot;</span>, file_path) # 实例化一个文件存取的存储对象</span><br></pre></td></tr></table></figure>

<p>上述代码表示实例化了一个文件存取对象，并且在实例化时需要传入存储介质的类型以及存取的文件路径</p>
<p>在实例化好对象后就可以去调用对象的实例方法，如下：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> = file_store.read() # 调用实例对象的read方法获取<span class="type">CMDB</span>的数据</span></span><br><span class="line"></span><br><span class="line"><span class="title">print</span>(<span class="class"><span class="keyword">data</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">file_store</span>.write(<span class="class"><span class="keyword">data</span>) # 调用实例对象的write方法保存数据</span></span><br></pre></td></tr></table></figure>

<h3 id="参数类"><a href="#参数类" class="headerlink" title="参数类"></a><strong>参数类</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Params</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, operations</span>):</span><br><span class="line"></span><br><span class="line">        self.operations = operations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, args</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;please input operation and args, operations: %s&quot;</span> % <span class="string">&quot;,&quot;</span>.join(self.operations))</span><br><span class="line"></span><br><span class="line">        operation = args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        params = args[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operation, params</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    operations = [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;init&quot;</span>]</span><br><span class="line"></span><br><span class="line">    cmd_params = Params(operations) <span class="comment"># 实例化从命令行获取参数的对象</span></span><br><span class="line"></span><br><span class="line">    op, args = cmd_params.parse(sys.argv) <span class="comment"># 使用参数对象的解析方法解析出要做的操作和具体的参数</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的类是<strong>参数类</strong>，这个类可以提供参数解析方法，解析命令行参数。</p>
<p>\1. <code>cmd_params = Params(operations)</code>首先是实例化参数类，并传入CMDB中允许操作的方法。</p>
<p>\2. <code>op, args = cmd_params.parse(sys.argv)</code>是调用实例对象的<code>parse</code>方法，判断命令行传入的操作是否合法，并且返回操作名称和该操作的<code>params</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>相信大家看到这里应该对面向对象还有Python的类和实例不会那么发怵了，其实这就是一个从易到难的过程，我们后续会继续阅读剩余的源码，带大家更深入的了解Python的类。</p>
<h2 id="篇后语"><a href="#篇后语" class="headerlink" title="篇后语"></a><strong>篇后语</strong></h2><p>读者朋友们需要注意的一个重点是，不管是数据结构这种底层原理还是面向对象这种上层思想，都是<strong>适用于所有的编程语言</strong>，并且这些通用性的知识对我们的编程起着<strong>奠基和指引作用</strong>。</p>
<p>所以我给大家讲解时并不是单纯的教会大家怎么写Python，而是要教给对编程感兴趣或者有需求的朋友一种<strong>在编程领域泛之四海而皆准的方式和理念</strong>。所以我一开始都会先构造一个场景，然后带领大家去感受用编程解决问题的思想，最后告诉大家用Python究竟应该如何来实现它。</p>
<p>希望大家可以理解，<strong>磨刀不误砍柴工，慢即是快</strong>。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.9 自动化运维新手村-Python基础-面向对象3</title>
    <url>/posts/a04207a.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li>对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读前面几篇；</li>
<li>对Python了解较少只能写出简单脚本的读者，强烈建议阅读此篇；</li>
<li>已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇；</li>
<li>即了解Python，又了解CMDB的读者，可以出门左转，看下一篇。</li>
</ul>
<p>上一讲我们已经可以说已经摸到点儿Python中面向对象的门道了，虽然说<strong>只摸到一点儿</strong>，但这也足够支撑我们开启后面的学习，</p>
<p>今天我们就继续深入到CMDBv1.5的源码中。</p>
<span id="more"></span>

<h2 id="CMDB-v1-5源码阅读"><a href="#CMDB-v1-5源码阅读" class="headerlink" title="CMDB v1.5源码阅读"></a><strong>CMDB v1.5源码阅读</strong></h2><h3 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a><strong>类的关系</strong></h3><p>首先来看完整的入口函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        file_path = os.path.<span class="title function_ invoke__">join</span>(os.path.<span class="title function_ invoke__">dirname</span>(__file__), <span class="string">&quot;data.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">        file_store = <span class="title function_ invoke__">Store</span>(<span class="string">&quot;FILE&quot;</span>, file_path) <span class="comment"># 实例化一个文件存储的存储对象</span></span><br><span class="line"></span><br><span class="line">        cmdb = <span class="title function_ invoke__">CMDB</span>(file_store) <span class="comment"># 传入读出的数据源实例化一个CMDB的对象</span></span><br><span class="line"></span><br><span class="line">        cmd_params = <span class="title function_ invoke__">Params</span>(cmdb.operations) <span class="comment"># 实例化从命令行获取参数的对象</span></span><br><span class="line"></span><br><span class="line">        op, args = cmd_params.<span class="title function_ invoke__">parse</span>(sys.argv) <span class="comment"># 使用参数对象的解析方法解析出要做的操作和具体的参数</span></span><br><span class="line"></span><br><span class="line">        result = cmdb.<span class="title function_ invoke__">execute</span>(op, args) <span class="comment"># 传入参数对象解析出的操作和具体参数，调用CMDB对象的执行操作方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span>(result)</span><br><span class="line"></span><br><span class="line">    except <span class="built_in">Exception</span> <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span>(e)</span><br></pre></td></tr></table></figure>

<p>CMDBv1.5完整的代码中包括了三个类，分别是<code>Params参数类</code>，<code>Store存取类</code>以及<code>CMDB类</code>， 通过入口函数中类的实例化以及参数的传递可以看出三个对象之间的关系。</p>
<ul>
<li>先实例化存取类负责数据的读取和保存</li>
<li>再实例化CMDB类，并将存取对象传入CMDB类中，负责具体操作时对数据的读写</li>
<li>最后实例化参数类，解析命令行参数，并将解析结果传入CMDB类的实例方法中</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/08/JmTtGDEV4rgvs9L.png" alt="img"></p>
<h3 id="CMDB类"><a href="#CMDB类" class="headerlink" title="CMDB类"></a><strong>CMDB类</strong></h3><p>今天的重头戏就是CMDB中最重要的类的实现，首先来看CMDB类的实例化</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmdb = CMDB(file_store) <span class="comment"># 传入读出的数据源实例化一个CMDB的对象</span></span><br></pre></td></tr></table></figure>

<p>实例化的方法还是和之前讲的一样，但这里传入的参数比较特别，传入的是一个实例对象，将已经实例化过的存取对象传入到CMDB的实例中，这样可以在之后的其他操作中很方便的通过<strong>存取对象</strong>进行数据的读写。</p>
<blockquote>
<p>Tips</p>
</blockquote>
<blockquote>
<p>这里用到了类之间的组合，这属于一种编程规范：在面向对象的过程中，尽量避免不必要的继承，而是要多使用对象的组合。</p>
</blockquote>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a><strong>属性</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMDB</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, store</span>):</span><br><span class="line"></span><br><span class="line">        self.store = store</span><br><span class="line"></span><br><span class="line">        self.operations = self.methods()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">methods</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        ops = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">dir</span>(self): <span class="comment"># 获取self变量的所有属性和方法</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> m.startswith(<span class="string">&quot;__&quot;</span>) <span class="keyword">or</span> m.endswith(<span class="string">&quot;__&quot;</span>): <span class="comment"># 过滤掉内置属性和方法</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">callable</span>(<span class="built_in">getattr</span>(self, m)): <span class="comment"># 过滤掉属性</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            ops.append(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ops</span><br></pre></td></tr></table></figure>

<p>CMDB类具有两个属性，一个是存取对象，另一个就是允许执行的操作，存取对象是通过<code>__init__()</code>函数在实例化类的时候传入的，而允许执行的操作需要我们调用自身类中的一个实例方法去获取。</p>
<p>\1. <code>dir()</code>这个方法不知道大家是否还有印象，在之前的文章中提到过，由于Python中所有变量皆对象，可以用过<code>dir()</code>这个方法获取到某个变量具有的所有属性和方法，所以这里通过<code>dir(self)</code>来获取实例对象所有的属性和方法，并循环去进行判断。</p>
<p>2.在Python的类中，一般会将内置的属性前会加<code>__</code>，而内置的方法前后都会加<code>__</code>，所以在每次循环时，通过判断这个变量名是否以<code>__</code>开头或结尾，便可以过滤出内置的属性和方法。</p>
<p>\3. <code>callable()</code>函数会返回一个<code>bool</code>值，可以判断传入的参数是否是可被调用的，如果返回True就说明传入的参数是一个函数。</p>
<p>\4. <code>getattr(obj, name)</code>函数可以传入一个对象和一个字符串，会根据传入的name返回obj中对应的属性或方法</p>
<p>综上，CMDB类就包含两个属性，分别是store对象，和允许执行的operations，这两个属性都会在实例化CMDB类的时候确定。</p>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><strong>实例方法</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMDB</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, store</span>):</span><br><span class="line"></span><br><span class="line">        self.store = store</span><br><span class="line"></span><br><span class="line">        self.operations = self.methods()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, op, args</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> op <span class="keyword">not</span> <span class="keyword">in</span> self.operations:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;%s is not valid CMDB operation, should is %s&quot;</span> % (op, <span class="string">&quot;,&quot;</span>.join(self.operations)))</span><br><span class="line"></span><br><span class="line">        method = <span class="built_in">getattr</span>(self, op)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method(*args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self, region</span>):</span><br><span class="line"></span><br><span class="line">        data = self.store.read()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> region <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;region %s already exists&quot;</span> % region)</span><br><span class="line"></span><br><span class="line">        data[region] = &#123;<span class="string">&quot;idc&quot;</span>: region, <span class="string">&quot;switch&quot;</span>: &#123;&#125;, <span class="string">&quot;router&quot;</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">        self.store.save(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> region</span><br></pre></td></tr></table></figure>

<p>\1. 上一讲已经提到，类的实例方法是类必须实例化之后才能被调用的，且第一个参数必须是<code>self</code>，CMDB的已知操作分别是<code>init(), add(), delete(), update(), get()</code>，这些都应该是实例方法，用法也都几乎一样。</p>
<p>\2. <code>execute(self, op, args)</code>函数是在CMDB类中额外新增一个功能，它要求传入要执行的操作和操作所需的参数。</p>
<p>这个函数的功能是作为CMDB统一对外暴露的入口，执行增删改查的操作都通过这个函数来进行，主要目的是为了增加整个CMDB类的<strong>可扩展性</strong>。大家可以参照之前没有重构过的代码进行比较一下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> args[<span class="number">1</span>] == <span class="string">&quot;init&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="attribute">init</span>(args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="attribute">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;add&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="attribute">add</span>(*args[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="attribute">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;get&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="attribute">get</span>(args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="attribute">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;update&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="attribute">update</span>(*args[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="attribute">elif</span> args[<span class="number">1</span>] == <span class="string">&quot;delete&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="attribute">delete</span>(*args[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="attribute">else</span>:</span><br><span class="line"></span><br><span class="line">    <span class="attribute">print</span>(<span class="string">&quot;operation must be one of get,update,delete&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>同样是调用CMDB的增删改查操作，原先需要写很多的判断逻辑，并且这些函数的调用方式也都是相同的，所以完全可以把这个调用抽象成一个<code>execute()</code>方法，<strong>直接根据</strong><code>**operation**</code><strong>的名字去调用对应的函数即可</strong>。</p>
<p>再假设如果<strong>后续新增了其他对CMDB的操作</strong>，那么如果用<code>if...else..</code>的方式是不是每次都需要去修改代码，这其实就是<strong>扩展性不够好的体现</strong>，现在重构过之后使用<code>execute()</code>方法，则完全可以不用修改额外的代码，大家可以仔细体会一下。</p>
<p>\3. <code>init(self, region)</code>这个函数是CMDB初始化地域的函数，大家注意与<code>__init__()</code>区分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self, region</span>):</span><br><span class="line"></span><br><span class="line">    data = self.store.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> region <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;region %s already exists&quot;</span> % region)</span><br><span class="line"></span><br><span class="line">    data[region] = &#123;<span class="string">&quot;idc&quot;</span>: region, <span class="string">&quot;switch&quot;</span>: &#123;&#125;, <span class="string">&quot;router&quot;</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    self.store.save(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> region</span><br></pre></td></tr></table></figure>

<p>初始化地域包括另外的增删改查操作，<strong>逻辑都与重构之前的一模一样</strong>，唯一一点需要改动的地方就是，原先在面向过程编程的时候，对于数据的读写都是通过直接调用<code>read_file()</code>或者<code>write_data()</code>函数，但现在需要通过存取对象来实现。</p>
<p>在实例化CMDB类的时候就已经将存取类通过参数传递给了CMDB对象，所以<code>self.store</code>此刻就已经是存取对象，可以直接通过<code>self.store.read()</code>或者<code>self.store.save()</code>来实现数据的读写功能。</p>
<p>\4. 大家可以参照<code>init()</code>的方法改写一下其他的增删改查操作，将原先的函数改写为实例方法</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h4><p>Python中除了<strong>实例方法</strong>还有<strong>静态方法</strong>和<strong>类方法</strong>，这三种方法在用法上会有所区别，但并没有明确的规定说我这个方法必须定义成实例方法或必须定义成静态方法。</p>
<p>定义成什么类型的方法更多的基于场景的分析，以及编程的习惯，更多关于这三种方法类型的区别会在番外篇中做出解释，因为此处只用到了静态方法，所以就暂时先讲解静态方法的语法和使用。</p>
<p><strong>静态方法的语法为在方法的上面增加一行</strong><code>**@staticmethod**</code><strong>，这属于Python中的装饰器，装饰器也会单独在番外篇中详细讲解，也是属于Python中的一大特点。</strong></p>
<p>除了加了一个标识为静态方法的装饰器以外，静态方法并不需要传入<code>self</code>参数，因为静态方法的特点就是该方法<strong>不属于任何类或者实例对象</strong>，它是<strong>静态的</strong>，它只是因为这个方法从面向对象的角度来说，可以让它放在CMDB类中，但它本身并不需要引用到任务与该类或者该类的实例相关的其他属性或方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMDB</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_parse</span>(<span class="params">attrs</span>): </span><br><span class="line"></span><br><span class="line">         <span class="comment"># 检查参数的合法性</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            attrs = json.loads(attrs)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;attributes is not valid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate_path</span>(<span class="params">data, path</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据path定位到data的位置</span></span><br><span class="line"></span><br><span class="line">        target_path = data</span><br><span class="line"></span><br><span class="line">        path_seg = path.split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> seg <span class="keyword">in</span> path_seg[:-<span class="number">1</span>]:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> seg <span class="keyword">not</span> <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;location path is not exists in data, please use add function&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            target_path = target_path[seg]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target_path, path_seg[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>大家可以根据之前的讲解了解到，检查参数的合法性以及根据path定位到data中相应的位置，这两个方法都是相对比较独立的功能。</p>
<p>并且从上面代码中也可以看出，这两个函数并<strong>不依赖任何其他第三方库或者具体的业务逻辑</strong>，这种函数我们一般称之为<strong>干净的函数</strong>。</p>
<p>如果后面我们需要在多处应用到相同的<strong>干净的函数</strong>，那么就可以将这些干净的函数单独写在一个文件中，供其他地方import调用，这样很多<strong>干净的函数</strong>就组成了一个<strong>工具包</strong>。</p>
<p>但基于目前CMDB的场景，将这两个函数归到CMDB类中也是十分合适的。</p>
<p>因为静态方法不需要传入<code>self</code>，并且它<strong>本身也与实例对象无关</strong>，<strong>它只是形式上归属于CMDB类</strong>，所以可以直接通过<code>CMDB.check_parse()</code>来调用，如下面的<code>add()</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMDB</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, path, attrs</span>):</span><br><span class="line"></span><br><span class="line">        attrs = CMDB.check_parse(attrs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> attrs:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;attrs is invalid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        data = self.store.read()</span><br><span class="line"></span><br><span class="line">        target_path, last_seg = CMDB.locate_path(data, path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> last_seg <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;%s already exists in %s, please use update operation&quot;</span> % (last_seg, path))</span><br><span class="line"></span><br><span class="line">        target_path[last_seg] = attrs</span><br><span class="line"></span><br><span class="line">        self.store.save(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attrs</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>根据上面的讲解，大家基本已经可以自己写出完整的CMDB类了，但我这里还是给大家附上重构后<strong>全部的源代码。</strong></p>
<p>希望大家可以自己先根据我上面的讲解自行重构，然后再与我给出的代码做对比，这样才能发现你的思路上可以优化的地方，说不定你能重构出更优雅的代码，到时候希望我们可以互相多多交流，分享思路。 </p>
<p><strong>温馨提示：篇尾彩蛋</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span>:</span><br><span class="line"></span><br><span class="line">    version = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    update_time = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, store_type, store_uri</span>):</span><br><span class="line"></span><br><span class="line">        self.store_type = store_type <span class="comment"># 存储介质类型</span></span><br><span class="line"></span><br><span class="line">        self.store_uri = store_uri <span class="comment"># 存储介质的路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self, data</span>):  <span class="comment"># 存储方法</span></span><br><span class="line"></span><br><span class="line">        data[<span class="string">&quot;version&quot;</span>] = (Store.version <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        data[<span class="string">&quot;update_time&quot;</span>] = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.store_uri, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">            json.dump(data, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):  <span class="comment"># 读取方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.store_uri, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">            data = json.load(f)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">                Store.version = data.pop(<span class="string">&quot;version&quot;</span>)</span><br><span class="line"></span><br><span class="line">                Store.update_time = data.pop(<span class="string">&quot;update_time&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMDB</span>:</span><br><span class="line"></span><br><span class="line">    version = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    update_time = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, store</span>):</span><br><span class="line"></span><br><span class="line">        self.store = store</span><br><span class="line"></span><br><span class="line">        self.operations = self.methods()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">methods</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        ops = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">dir</span>(self):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> m.startswith(<span class="string">&quot;__&quot;</span>) <span class="keyword">or</span> m.endswith(<span class="string">&quot;__&quot;</span>):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">callable</span>(<span class="built_in">getattr</span>(self, m)):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            ops.append(m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ops</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, op, args</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> op <span class="keyword">not</span> <span class="keyword">in</span> self.operations:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;%s is not valid CMDB operation, should is %s&quot;</span> % (op, <span class="string">&quot;,&quot;</span>.join(self.operations)))</span><br><span class="line"></span><br><span class="line">        method = <span class="built_in">getattr</span>(self, op)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method(*args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self, region</span>):</span><br><span class="line"></span><br><span class="line">        data = self.store.read()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> region <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;region %s already exists&quot;</span> % region)</span><br><span class="line"></span><br><span class="line">        data[region] = &#123;<span class="string">&quot;idc&quot;</span>: region, <span class="string">&quot;switch&quot;</span>: &#123;&#125;, <span class="string">&quot;router&quot;</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">        self.store.save(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> region</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, path, attrs</span>):</span><br><span class="line"></span><br><span class="line">        attrs = CMDB.check_parse(attrs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;attrs is invalid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        data = self.store.read()</span><br><span class="line"></span><br><span class="line">        target_path, last_seg = CMDB.locate_path(data, path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> last_seg <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;%s already exists in %s, please use update operation&quot;</span> % (last_seg, path))</span><br><span class="line"></span><br><span class="line">        target_path[last_seg] = attrs</span><br><span class="line"></span><br><span class="line">        self.store.save(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, path, attrs=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">        attrs = CMDB.check_parse(attrs)</span><br><span class="line"></span><br><span class="line">        data = self.store.read()</span><br><span class="line"></span><br><span class="line">        target_path, last_seg = CMDB.locate_path(data, path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> last_seg <span class="keyword">not</span> <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;%s is not in data&quot;</span> % path)</span><br><span class="line"></span><br><span class="line">            target_path.pop(last_seg)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(attrs, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> attr <span class="keyword">in</span> attrs:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> attr <span class="keyword">not</span> <span class="keyword">in</span> target_path[last_seg]:</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;attr %s not in target_path&quot;</span> % attr)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(target_path[last_seg], <span class="built_in">dict</span>):</span><br><span class="line"></span><br><span class="line">                    target_path[last_seg].pop(attr)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(target_path[last_seg], <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">                    target_path[last_seg].remove(attr)</span><br><span class="line"></span><br><span class="line">        self.store.save(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, path, attrs</span>):</span><br><span class="line"></span><br><span class="line">        attrs = CMDB.check_parse(attrs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;attrs is invalid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        data = self.store.read()</span><br><span class="line"></span><br><span class="line">        target_path, last_seg = CMDB.locate_path(data, path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(attrs) != <span class="built_in">type</span>(target_path[last_seg]):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;update attributes and target_path attributes are different type.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(attrs, <span class="built_in">dict</span>):</span><br><span class="line"></span><br><span class="line">            target_path[last_seg].update(attrs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(attrs, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">            target_path[last_seg].extend(attrs)</span><br><span class="line"></span><br><span class="line">            target_path[last_seg] = <span class="built_in">list</span>(<span class="built_in">set</span>(target_path[last_seg]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            target_path[last_seg] = attrs</span><br><span class="line"></span><br><span class="line">        self.store.save(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, path</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;/&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> path:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;please input valid path&quot;</span>)</span><br><span class="line"></span><br><span class="line">        data = self.store.read()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">&quot;/&quot;</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> json.dumps(data, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            target_path, last_seg = CMDB.locate_path(data, path)</span><br><span class="line"></span><br><span class="line">            ret = target_path[last_seg]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;path %s is invalid&quot;</span> % path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> json.dumps(ret, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_parse</span>(<span class="params">attrs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> attrs <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 判断attrs的合法性</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            attrs = json.loads(attrs)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> attrs</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;attributes is not valid json string&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">locate_path</span>(<span class="params">data, path</span>):</span><br><span class="line"></span><br><span class="line">        target_path = data</span><br><span class="line"></span><br><span class="line">        path_seg = path.split(<span class="string">&quot;/&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> seg <span class="keyword">in</span> path_seg[:-<span class="number">1</span>]:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> seg <span class="keyword">not</span> <span class="keyword">in</span> target_path:</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;location path is not exists in data, please use add function&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            target_path = target_path[seg]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target_path, path_seg[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Params</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, operations</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        self.operations = operations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, args</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;please input operation and args, operations: %s&quot;</span> % <span class="string">&quot;,&quot;</span>.join(self.operations))</span><br><span class="line"></span><br><span class="line">        operation = args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        params = args[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operation, params</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        file_path = os.path.join(os.path.dirname(__file__), <span class="string">&quot;data.json&quot;</span>)</span><br><span class="line"></span><br><span class="line">        file_store = Store(<span class="string">&quot;FILE&quot;</span>, file_path) <span class="comment"># 实例化一个文件存储的存储对象</span></span><br><span class="line"></span><br><span class="line">        cmdb = CMDB(file_store) <span class="comment"># 传入读出的数据源实例化一个CMDB的对象</span></span><br><span class="line"></span><br><span class="line">        cmd_params = Params(cmdb.operations) <span class="comment"># 实例化从命令行获取参数的对象</span></span><br><span class="line"></span><br><span class="line">        op, args = cmd_params.parse(sys.argv) <span class="comment"># 使用参数对象的解析方法解析出要做的操作和具体的参数</span></span><br><span class="line"></span><br><span class="line">        result = cmdb.execute(op, args) <span class="comment"># 传入参数对象解析出的操作和具体参数，调用CMDB对象的执行操作方法</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<h2 id="篇后语"><a href="#篇后语" class="headerlink" title="篇后语"></a><strong>篇后语</strong></h2><p>平时经常会有朋友问我，并且我也在知乎或者其他论坛上看到有人提问<strong>有没有好的Python的学习资料，有没有系统的学习Python的方法</strong>，其实对此我有一些自己的看法，我觉得问这样问题的朋友肯定是想要学习的，<strong>但什么是真正的学习可能鲜有人清楚</strong></p>
<p>\1. 学习本质上分为两种：<strong>记忆和泛化</strong>。</p>
<p>记忆顾名思义就是把一些固定的知识记住，比如一年有多少天这种知识。但学习编程语言很明显不属于记忆，它应该属于泛化的范畴。</p>
<p>\2. 泛化又分为两种：<strong>指令学习和归纳学习</strong>。</p>
<p>- 指令学习就是提供一个知识点，比如time库中的时间格式转换函数，你这时候需要的就是把这个指令记住，然后在不停的使用这个函数转换时间的过程中去真正掌握它。</p>
<p>- 归纳学习则更多的是需要你根据某个知识点去触类旁通的解决更多的问题，比如我们学习了面向对象的思想，我带领大家去用这个思想实现CMDB，那你是否真的掌握了这个知识呢？<strong>这就要看你是不是可以用这样的思想去解决其他的问题</strong>，所以归纳学习会更具有难度，他需要你去不停的用新的问题来验证你是否真的学会了这个知识点。</p>
<p>在之前的直播答疑中有的朋友问起我<strong>需不需要刻意去背一些库函数的用法</strong>，我当时给的答案是<strong>肯定的，需要去背</strong>，因为他很明显属于指令学习的一种，但我还说了一句话：如果你能更多的去使用他，熟悉了之后你就会有一种感觉，在面对陌生的函数的时候也可以更快速的掌握，这就又是<strong>指令学习到归纳学习的转换</strong>。</p>
<p><strong>所以如果一上来就希望有一本大而全的Python书籍或者资料，且不说有没有这样的书籍，倘若真的有，你拿到了也并不一定就表示你可以学会Python。</strong></p>
<p>因为学习Python是一种泛化学习，需要你在获取新的知识点的过程中去用它解决实际更多的问题，不然就只能是停留在纸上谈兵的阶段。这也是为什么我的文章不愿意一点一点的去挨个讲知识点，我更愿意用从实际的场景出发，教会大家如何用具体的知识点去解决问题。</p>
<p>但更深一层的是虽然我是从实际的场景讲解运用知识点，但仍然是我带领大家去思考的，所以作为读者你<strong>仍然需要用去亲自实践它</strong>，这次的篇后语略微长了些，但更多的是希望告诉大家一些学习方法和理念，能对学习任何技能都起到帮助作用。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.10 自动化运维新手村-Web框架序篇</title>
    <url>/posts/d3018aab.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先大家需要先想清楚，<strong>为什么一定要学Web框架</strong>，有的朋友会觉得运维中最常用的应该是脚本，<strong>我只要脚本写的溜，能提高工作效率就好了</strong>。</p>
<p>但假设有一天你的同事也遇到了相同的场景，那你的脚本要直接拷贝给他吗？如果有一天你通过脚本解决的是一个需要跨部门合作的痛点，那你是不是也可以把执行脚本的权限交给对方呢？</p>
<p>答案当然是否定的，自动化运维最大的意义是通过<strong>自动化来将从工作效率实现从量变到质变的提升</strong>，那如何提升呢，我觉得<strong>Web应用</strong>就是一个很好的方式。</p>
<span id="more"></span>

<h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a><strong>Web应用</strong></h2><p>很多朋友喜欢研究应用软件，比如在Windows上启动的一个应用程序，通过应用界面去点击操作，这样的<strong>应用属于C&#x2F;S架构</strong>，即Client&#x2F;Server架构，但有一个显著的弊端就是应用<strong>必须针对系统开发</strong>，Windows系统下的软件，在Linux下就无法使用，并且<strong>安装，变更，维护的难度</strong>都很大。</p>
<p>但针对自动化运维来说，我比较<strong>推荐构建Web应用</strong>，即B&#x2F;S(Browser&#x2F;Server)架构，服务端维护Server应用，用户只需要通过浏览器即可访问，<strong>B&#x2F;S应用分布性强、维护方便、开发简单并且共享性强</strong>。</p>
<p>所以<strong>当想要从脚本小子更近一步的时候，学习Web应用几乎就是必经之路</strong>。B&#x2F;S的完整应用如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/08/6784Saxw1PAfmyN.png" alt="img"></p>
<p>对于搞运维的朋友应该能很好的理解Web应用的底层原理，实际上Web应用就是在<strong>Server端监听了一个端口</strong>，然后<strong>浏览器通过Socket套接字和服务端进行信息交互</strong>。</p>
<p>Server端监听端口可以用Python很方便的实现，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_server</span>(<span class="params">ip, port, app</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理套接字通信</span></span><br><span class="line"></span><br><span class="line">    sock = socket.socket()</span><br><span class="line"></span><br><span class="line">    sock.bind((ip, port))</span><br><span class="line"></span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Starting development server at http://%s:%s/&#x27;</span> %(ip,port))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        conn, addr = sock.accept()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1、接收浏览器发来的请求信息</span></span><br><span class="line"></span><br><span class="line">        recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2、将请求信息直接转交给application处理，得到返回值</span></span><br><span class="line"></span><br><span class="line">        res = app(recv_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3、向浏览器返回消息（此处并没有按照http协议返回）</span></span><br><span class="line"></span><br><span class="line">        conn.send(res)</span><br><span class="line"></span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app</span>(<span class="params">environ</span>):  <span class="comment"># 代表application</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    make_server(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8008</span>, app)</span><br></pre></td></tr></table></figure>

<p>在客户端浏览器输入：<a href="http://127.0.0.1:8008/">http://127.0.0.1:8008</a> 会报错，这是因为简易的Server端<strong>只提供了传输层的信息交互</strong>，而浏览器与服务端通信是使用<strong>七层HTTP协议</strong>，所以服务端返回给浏览器的信息需要符合HTTP协议的标准，才能被浏览器正确的解析。</p>
<h2 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a><strong>Web框架</strong></h2><p>实际上开发人员可以通过<strong>自己拼接返回数据的格式使其符合HTTP协议的定</strong>义，但很多复杂且固定的东西其实完全可以抽象出来，我们只需要<strong>关注接受请求后的业务逻辑处理即可</strong>，比如只关注上例中的app。</p>
<p><strong>处理消息的收发，以及对于HTTP协议报文的解析和封装属于WSGI</strong>(Web Server Gateway Interface)需要做的事情，具体关于WSGI的详细讲解会在番外篇中提到，大家暂时只需要理解WSGI的基本作用即可。</p>
<p>除了处理消息和解析HTTP协议之外，一个Server端还需要在存在多个业务逻辑时，定义不同的函数，将其与不同的URL关联，这就涉及到<strong>路由的映射</strong>；还有对于<strong>前端HTML的支持</strong>，<strong>数据库扩展和其他中间件的支持</strong>。</p>
<p>上述的诸多功能都属于业务逻辑之外的，所以我们无需完全自己实现，可以直接使用开源的Web框架。</p>
<p>目前Python语言中比较主流的Web框架有<strong>Flask和Django</strong>，很多朋友也都询问过我到底是学习Flask还是Django，这篇文章我就从我个人的使用感受来给大家<strong>分析一下这两个框架的优劣以及适用的场景</strong>。</p>
<h2 id="Flask-vs-Django"><a href="#Flask-vs-Django" class="headerlink" title="Flask vs Django"></a><strong>Flask vs Django</strong></h2><p>首先需要声明，我们只是单纯的对比两个框架的优缺点和适用的场景，并不存在捧一踩一的意思，大家根据我的介绍理智判断即可。</p>
<p>先大致介绍一下Django和Flask</p>
<h4 id="Django"><a href="#Django" class="headerlink" title="Django"></a><strong>Django</strong></h4><blockquote>
<p>Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。 </p>
</blockquote>
<blockquote>
<p>使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务。</p>
</blockquote>
<blockquote>
<p>Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式，MVC 模式使后续对程序的修改和扩展简化。</p>
</blockquote>
<h4 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a><strong>Flask</strong></h4><blockquote>
<p>Flask是基于Python的微框架 。</p>
</blockquote>
<blockquote>
<p>Flask是由奥地利开发商Armin Ronacher于2010年4月1日发布的。 </p>
</blockquote>
<blockquote>
<p>微框架意味着Flask旨在保持其重量轻和简单但仍然可以进行高度扩展。</p>
</blockquote>
<blockquote>
<p>Flask的真正力量在于它非常灵活，具有十分活跃和丰富的社区提供各种扩展以供Flask应用进行集成。Flask本身不对设计模式做出硬性要求，开发人员十分容易上手。</p>
</blockquote>
<p>下面从几个重要特征来对这两个框架做一个较为详细的对比：</p>
<ul>
<li><strong>上手难度</strong></li>
<li><strong>社区活跃度</strong></li>
<li><strong>灵活性</strong></li>
<li><strong>功能性</strong></li>
<li><strong>开发速度</strong></li>
</ul>
<h4 id="上手难度"><a href="#上手难度" class="headerlink" title="上手难度"></a><strong>上手难度</strong></h4><p>从上手难易程度来说，我不得不说<strong>Flask要比Django好太多</strong>。</p>
<ul>
<li>Flask只需要几行代码就可以启动一个Web应用的后端，并开始编写自己想要的路由函数。</li>
<li>而相比之下，刚接触编程的朋友甚至会直接卡在Django启动后端这一步，并且启动之后Django自带的诸多目录让新手常常眼花缭乱。</li>
</ul>
<h4 id="社区活跃度"><a href="#社区活跃度" class="headerlink" title="社区活跃度"></a><strong>社区活跃度</strong></h4><p><strong>不少顶级网站使用Django和Flask</strong>，一些由Django开发的知名项目（Bitbucket，Eventbrite， Instagram的，Pinterest等）和Flask开发的知名项目（Netflix，Twilio，Uber）。</p>
<ul>
<li>Django和Flask都属于在诸多Python的Web框架中脱颖而出的选手，它们的<strong>社区活跃度可以说不相上下</strong>，Github上会有各种各样的使用Django搭建的个人网站项目或者更为复杂的系统；</li>
<li>而Github上同样也有对于Flask的各种第三方扩展，几乎可以让开发人员集成任何想要的扩展功能。</li>
</ul>
<h4 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a><strong>灵活性</strong></h4><p>我认为这两个框架<strong>最大的差异就是灵活性，没有之一</strong>。</p>
<ul>
<li><p>Flask是一个扩展性很好的Web框架，可以使用各种第三方的扩展工具来灵活地开发Web应用程序。对于经验较少的开发人员，Flask可以<strong>让你简洁的实现自己想要的功能，不必受到框架本身的各种限制</strong>；对于经验丰富的开发人员可以自由地插入和使用他们喜欢的库和数据库。总的来说Flask框架<strong>很少会强制开发人员使用什么，这也是我最中意Flask的一点</strong>。</p>
</li>
<li><p>Django <strong>可以在不使用太多第三方库和工具的条件下开发各种优秀的Web应用程序</strong>。但是，Django缺少部分对模块优化的空间，因此开发人员使用内置功能创建Web应用程序，这意味着<strong>如果想要修改Django一些默认的设定或者规则会比较困难</strong>。</p>
</li>
</ul>
<h4 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a><strong>功能性</strong></h4><p>功能性是<strong>Flask与Django相比十分欠缺的，这块Flask不得不自认弟弟</strong>。</p>
<ul>
<li><p>Django可以为Web应用程序开发<strong>提供了管理面板，数据库界面，目录结构和ORM的全方位体验</strong>，所以Django对于快速构建一个Web应用来说是不二之选。</p>
</li>
<li><p>相比，Flask的功能性并不体现在开箱即用上，Flask<strong>本质上并不缺少功能性，只是这些功能都需要开发人员自己来集成</strong>。</p>
</li>
</ul>
<h4 id="开发速度"><a href="#开发速度" class="headerlink" title="开发速度"></a><strong>开发速度</strong></h4><p>两者在适合框架自身的场景下都有<strong>极佳的开发速度</strong>。</p>
<ul>
<li>Django框架可为<strong>复杂的Web应用程序</strong>提供快速的开发速度。由于它具有全部功能，提供所有必要工具。</li>
<li>Flask的简单性使经验丰富的开发人员可以在<strong>短时间内完成较小的应用程序</strong>。</li>
</ul>
<h4 id="对比图"><a href="#对比图" class="headerlink" title="对比图"></a><strong>对比图</strong></h4><p>有两张十分生动的图可以描述Django和Flask之间的区别：</p>
<p><img src="https://s2.loli.net/2023/04/08/3BZJwaYWrjS4z16.png" alt="img"></p>
<p><img src="https://s2.loli.net/2023/04/08/e2Qw59nhPikYKUd.png" alt="img"></p>
<h2 id="自动化运维使用什么？"><a href="#自动化运维使用什么？" class="headerlink" title="自动化运维使用什么？"></a><strong>自动化运维使用什么？</strong></h2><p>通过上述的几个因素对比，大家应该可以看出来，框架<strong>本身并没有优劣之分，只有适不适合之分</strong>。但对于自动化运维来说，从个人角度出发<strong>我更推荐使用Flask</strong>，下面同样也从上述因素来说明我推荐Flask的原因：</p>
<h3 id="上手难度-1"><a href="#上手难度-1" class="headerlink" title="上手难度"></a><strong>上手难度</strong></h3><p>相信很多读者都是从事运维工作的，不管是网络运维还是系统运维或者应用运维，大多都对于编程不是特别熟悉，所以<strong>上手难度对于大家来说是最先遇到的难题，所以Flask具有最小化构建Web应用的能力，必然是刚接触编程的朋友的首选。</strong></p>
<h3 id="社区活跃度-1"><a href="#社区活跃度-1" class="headerlink" title="社区活跃度"></a><strong>社区活跃度</strong></h3><p>目前Django和Flask在社区活跃度上都已经足够好，并且有十分全面的文档以及各种项目供大家学习。</p>
<h3 id="灵活性-1"><a href="#灵活性-1" class="headerlink" title="灵活性"></a><strong>灵活性</strong></h3><p>灵活性<strong>是我选择Flask的最重要的因素</strong>，自动化运维领域中，更多的是对于机器设备的操作，以及各种自动化脚本的调用，所以Django在使用ORM快捷地对数据库的增删改查方面的优势就难以体现，<strong>反倒由于“大而全”而显得“臃肿”</strong>。</p>
<h3 id="功能性-1"><a href="#功能性-1" class="headerlink" title="功能性"></a><strong>功能性</strong></h3><p>Django最引以为傲的功能性在自动化运维的体现上我个人认为也不是十分明显，因为运维领域很多<strong>数据的展示都需要做定制化处理</strong>，对于开发经验较少的朋友来说Django很多内置集成的页面也无法复用。</p>
<h3 id="开发速度-1"><a href="#开发速度-1" class="headerlink" title="开发速度"></a><strong>开发速度</strong></h3><p>对于从事运维工作的朋友，如果只是想将自己的自动化脚本以API的形式提供给其他用户，<strong>那么Django就有一种“杀鸡用牛刀”的感觉。而Flask小巧灵活的特性正好十分契合这种需求</strong>。</p>
<p>在后续学习到更多自动化运维方面的技巧之后，可以将任务调度和数据采集分析等集成到Flask应用中，并且<strong>还可以自己灵活的设计系统的架构</strong>，这对于Django来说都会比较困难。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>对于普通的工人来说将<strong>毛坯房装修为城市综合体会有一定的难度</strong>，但我会在今后一步一步的指引大家并且相信大家在日后的不断学习下，会慢慢的具备这样的能力，构建起自己的自动化运维系统。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>1.11 自动化运维新手村-初见Flask</title>
    <url>/posts/4e4793c3.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>在Web框架序篇中，主要分析了一下Flask和Django各自的适用场景，最终的结论是，更倾向于推荐大家使用Flask，所以接下来的专题内容都会围绕Flask进行展开。</p>
<p>当然，讲解的风格仍然是延续我们一直以来秉承的思想，那就是<strong>从场景出发，先学习迫切需要用到的那部分知识，用不到的先不学</strong>，最近还新造了一个词叫<strong>最小化上手范围（Minimize Range）</strong>，就是指想要完成一个需求所需要的最小化的知识范围。</p>
<p>现在正式开始Flask的讲解</p>
<span id="more"></span>

<h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a><strong>Flask</strong></h2><p>Flask作为一个轻量级Web框架，那就先发挥一下他”轻“的优势，我们快速与之前的CMDB专题进行结合，抛弃掉原先通过命令行对数据源进行增删改查的方式，而是通过API请求来进行操作。</p>
<h3 id="启动Flask"><a href="#启动Flask" class="headerlink" title="启动Flask"></a><strong>启动Flask</strong></h3><p>启动Flask的代码其实只需要几行（是真的几行），如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>先在环境中安装好Flask的第三方包，通常执行<code>pip install flask</code>即可，之后就可以在命令行输入<code>python app.py</code>启动Flask项目。</p>
<p>启动之后的输出如下：</p>
<p>这里的输出一共有六行，就包括了五个知识点，但这里只讲最后两个，其他在番外篇和后续的章节中会讲到（因为暂时用不到）。</p>
<p><code>Running on http://127.0.0.1:5000/</code>这行表示Flask应用此时已经监听了本地的<code>127.0.0.1</code>地址和<code>5000</code>端口</p>
<p>通过<code>app.run()</code>函数的参数注释可以看出，该函数接受的前两个参数分别是<code>host</code>和<code>port</code>，当没有传这两个参数的时候默认值设为<code>127.0.0.1</code>和<code>5000</code></p>
<p>现在已经可以通过浏览器对这个网址进行访问了，但打开浏览器输入上述网址之后页面如下：</p>
<p>Not Found是HTTP状态码中的404错误，表示访问的链接资源不存在。这是因为我们只是启动了一个后端应用并监听了一个socket，并没有定义任何路由函数。</p>
<h3 id="新增路由"><a href="#新增路由" class="headerlink" title="新增路由"></a><strong>新增路由</strong></h3><p>现在新增部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>正常在修改代码之后需要停止程序并重新启动，但通过传入<code>debug</code>参数，可以在保存代码后动态加载让改动直接生效。</p>
<p>刷新页面后如下：</p>
<p><img src="https://s2.loli.net/2023/04/08/ifZQYtmLoMvD2WV.png" alt="img"></p>
<p>这里的<code>@app.route(&quot;/&quot;)</code>是Python中的<strong>装饰器语法</strong>，关于装饰器的详解，后续会在番外篇中提到，大家暂时只需要了解在一个普通的函数上面加上一行<code>@app.route</code>会把<strong>该函数注册到Flask的路由中</strong>。</p>
<p>而<code>app.route(&quot;/&quot;)</code>传的参数就是URL中去掉IP和端口号之后的Path路径。Flask的路由大家可以理解为一个<strong>字典，保存了Path对应的函数</strong>，这样当通过URL访问Flask后端应用的时候，就可以根据URL的Path找到对应函数去调用，然后返回数据。</p>
<h3 id="结合CMDB"><a href="#结合CMDB" class="headerlink" title="结合CMDB"></a><strong>结合CMDB</strong></h3><p>现在，将之前的CMDB代码<code>cmdb.py</code>以及数据文件<code>data.json</code>，放在<code>app.py</code>同级目录下，按照第二步的方式就可以新增几个路由分别对应CDMB的增删改查功能。</p>
<p>首先在<code>cmdb.py</code>中新增一个函数，能够让Flask调用到CMDB的实例对象，如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmdb.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmdb_handler</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        file_store = Store(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;data.json&quot;</span>) <span class="comment"># 实例化一个文件存储的存储对象</span></span><br><span class="line"></span><br><span class="line">        cmdb = CMDB(file_store) <span class="comment"># 传入读出的数据源实例化一个CMDB的对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cmdb</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;get cmdb handler failed, err: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

<p>在<code>app.py</code>中导入创建CMDB实例对象的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> cmdb <span class="keyword">import</span> cmdb_handler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMDB_HANDLER = cmdb_handler()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;查询CMDB&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(<span class="string">&quot;get&quot;</span>, path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/init&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;初始化地域&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(<span class="string">&quot;get&quot;</span>, region)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;添加信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(<span class="string">&quot;get&quot;</span>, path, attr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/update&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;修改信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(<span class="string">&quot;get&quot;</span>, path, attr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/delete&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;删除信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(<span class="string">&quot;get&quot;</span>, path, attr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码有一个需要注意的地方就是<code>@app.route(&quot;/init&quot;, methods=[&quot;POST&quot;])</code>，路由装饰器可以传入另外一个参数<code>methods</code>，<strong>这个参数会对HTTP请求的方式做出限制。</strong></p>
<p><code>methods=[&quot;POST&quot;]</code>表示该URL只接收POST请求，该参数不传时默认允许<code>GET</code>方法。</p>
<p>默认浏览器中<strong>输入网址访问属于对该URL发起GET请求</strong>，如果发起请求的方式与后端路由允许接收的方式不匹配，会发生如下图现象</p>
<p><img src="https://s2.loli.net/2023/04/08/lDkURzpbXZ9Br4x.png" alt="img"></p>
<blockquote>
<p><strong>Tips</strong></p>
</blockquote>
<blockquote>
<p>此处需要说明，<strong>不同框架对于请求方法的限制处理方式不同。</strong></p>
</blockquote>
<blockquote>
<p>Flask中只要请求的URL与路由定义的名称相同即可匹配成功，匹配成功后Flask会再对请求的Method做校验，判断请求方式与路由允许的接收方式是否一致，如果不一致则直接返回Method Not Allowed。</p>
</blockquote>
<blockquote>
<p>但在其他框架中，如Golang的Web框架，是将路由的名称和允许接收的请求方式组合后同时去和收到的HTTP请求做对比，如果不匹配就会报出404 Not Found错误。</p>
</blockquote>
<blockquote>
<p><strong>也就是说 Flask是通过名称来唯一定义一个路由，而其他框架则是用名称和Method来唯一定义一个路由。</strong></p>
</blockquote>
<h3 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a><strong>接收参数</strong></h3><p>细心的朋友可能发现，上述代码中调用CMDB的功能时，需要传入一些参数，但Flask应用中并没有定义这些参数</p>
<h4 id="GET请求参数"><a href="#GET请求参数" class="headerlink" title="GET请求参数"></a><strong>GET请求参数</strong></h4><p>CMDB查询功能的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;查询CMDB&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(<span class="string">&quot;get&quot;</span>, path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>由于我们是HTTP请求方式，所以上述代码中的<code>path</code>参数需要从HTTP请求中获取，这里是GET请求，通常GET请求的传参方式为</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http</span>://ip:port/path?key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure>

<p>HTTP请求的参数会经过Flask框架的处理，将参数存放在<code>request.args</code>中，<code>request.args</code>是一个字典，所以代码可以修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;查询CMDB&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    path = request.args.get(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;/&quot;</span>) <span class="comment"># 如果没有传path参数，则path默认为 /</span></span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(<span class="string">&quot;get&quot;</span>, [path])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h4 id="POST请求参数"><a href="#POST请求参数" class="headerlink" title="POST请求参数"></a><strong>POST请求参数</strong></h4><p>在CMDB中新增数据的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;添加信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(<span class="string">&quot;get&quot;</span>, [path, attr])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出，这个路由<strong>只允许接收POST请求</strong>。其实目前对于GET请求，或者必须要用POST请求，并没有明确的区分，或者准确的说<strong>就是没有区分，任何功能都可以通过GET请求来实现，这个我们会在番外篇中详细讲解。</strong></p>
<p>但由于在CMDB中添加信息时，需要传入的内容是json字符串，放在GET请求的参数中存在转义问题和可读性问题，所以我们这里采用POST请求来处理。</p>
<p>POST请求可以接受的参数可以有很多种类型，类型由HTTP请求Headers中的<code>content-type</code>字段定义，常用的有<code>application/json</code>或者<code>application/x-www-form-urlencoded</code>，我们这里暂且采用前者，代码修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/add&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;添加信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    path = request.get_json().get(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">    attr = request.get_json().get(<span class="string">&quot;attr&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(<span class="string">&quot;add&quot;</span>, [path, attr])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这一章节主要介绍了以下几个内容：</p>
<p>1.Flask的启动</p>
<p>2.路由函数的定义</p>
<p>3.HTTP参数的获取</p>
<p>4.Web应用与CMDB的结合</p>
<p>这些都还只是Flask的冰山一角，我们下一章节会针对这次的代码做出更进一步的改进，敬请期待。</p>
<h2 id="篇后语"><a href="#篇后语" class="headerlink" title="篇后语"></a><strong>篇后语</strong></h2><p>大家可以看到，我们只应用了Flask的及其有限的知识，并且没有应用到特别复杂的项目架构，部分知识也没有十分深入的探索，实际上就可以完成很多需求，这就是我开头提到的<strong>最小化上手范围</strong>；这也十分符合编程的理念：不要过度设计，不要提早重构。</p>
<p>Flask目前有很多官方的文档，也有许多讲解十分全面的书籍。我个人也十分赞同可以系统的去学习某个技术，但平时知乎上经常有人提问我看了很多书为什么还是不会写代码，诸如此类的问题，其实这也是大多数编程经验较少的朋友都会遇到的一个问题：<strong>懂得太多</strong>。</p>
<p><strong>这里的“懂”和“多”都是加引号的</strong>，因为如果真的懂，那必然是一个好事情，同样如果真的懂得多，也是个好事情。</p>
<p>但问题在于部分朋友对于很多知识点并不是真的懂，同样也就造成了多的错觉，因为确实也看了不少，这就涉及到了我之前在<a href="https://xzsh9e8v26.feishu.cn/docs/doccnguKivWomvANT8SMbBjfMNh">自动化运维新手村-Python基础-面向对象3</a> 的篇后语中提到的：<strong>指令学习和归纳学习</strong>，没看过的朋友可以点链接去看看。</p>
<p>阅读书籍或文档中的知识讲解本质上属于指令学习，学到的是知识点，但学习编程是一种归纳学习，需要将学会的知识点不停的运用，<strong>去反复并且多角度的验证这个知识点是具有实操性的</strong>，最终才能叫做“学会它”。</p>
<p>所以有的朋友看完书之后就会有一种感觉，这么多知识点我都知道了，但还是不会写代码，工作中遇到需求还是无法下手，根本原因就是知识点在脑子中堆积太多，但无法消化。</p>
<p>所以为了避免从入门到放弃，希望大家切记<strong>慢既是快</strong>。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>1.15 自动化运维新手村-ORM入门</title>
    <url>/posts/be12ef7b.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>到目前为止，自动化运维新手村中已经讲解了Python的基本数据类型及其操作，并且将其应用于一个简易的CMDB场景下；</p>
<p>除此之外还介绍了一个主流的Web框架——Flask，并且本着最小上手范围的原则，已经可以通过向后端API发起请求的方式，对CMDB进行增删改查，而且还有了更为健壮的异常处理和更为安全的认证鉴权。</p>
<p><strong>但有一个比较重要的内容始终没有提，这也是在后续的自动化运维中一定会用到的知识，那就是数据库</strong>。</p>
<p>今天的章节，就对我们的后端应用进行改造，不管是用户信息还是CMDB信息，一律不再通过文件进行存储，而是使用关系型数据库来实现数据的读写。</p>
<span id="more"></span>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><p>数据库其实可以笼统地理解为<strong>可以支撑大批量数据进行存取的应用程序。</strong></p>
<p>数据本身又分为<strong>关系型数据和非关系型数据</strong>，比如后端应用的用户信息，都具有用户名，密码，角色等信息，所以它们都是属于结构相同的关系型数据，但现在为止，我们CMDB的数据就属于非关系型数据，因为并没有强制的规定每台设备应该具有什么字段，而是通过一个json来实现灵活的信息读写。</p>
<p>那与之对应的数据库也就分为<strong>关系型数据库和非关系型数据库</strong>，这两者之间存在着比较大的差异，因为它们在底层实现上需要根据关系型数据或非关系型数据来做出不同的性能优化，实现更快的数据读写性能。<strong>但这两种数据库并不存在优劣之分，只存在适用的场景不同之分。</strong></p>
<p>大家经常听到的MySQL、Oracle就属于关系型数据库，而Mongo、Redis就属于非关系数据库。</p>
<p>我们这一章节就使用MySQL来作为数据库提供数据的存取能力，但并不会十分深入的讲解关系型数据库的底层原理以及各种范式，这些如果有必要的话会在番外篇中提到。</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a><strong>MySQL</strong></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p>
<p>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点如下：</p>
<p>1.数据以二维表格的形式出现</p>
<p>2.许多的行和列组成一张表</p>
<p>3.若干的表单组成Database</p>
<p>例如我们的CMDB的数据结构如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;Beijing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;idc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;switch&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;10.0.0.1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;csw&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Eth1/1/0&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Eth1/1/1&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>之所以一开始将数据结构定义成非关系型最主要的一个原因是为了匹配讲解Python的几大基本数据类型。但作为设备资产数据，其实大多数时候它们的字段都是已经固定的，所以这一章节就将非关系型数据“打平”，将其转为关系型数据，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;10.0.0.1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Beijing&quot;</span><span class="punctuation">,</span> <span class="string">&quot;R01&quot;</span><span class="punctuation">,</span> <span class="string">&quot;C01&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Cisco&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Nexus9000&quot;</span><span class="punctuation">,</span> <span class="string">&quot;BJ-R01-C01-N9K-00-00-01&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CSW&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;10.0.0.2&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Beijing&quot;</span><span class="punctuation">,</span> <span class="string">&quot;R01&quot;</span><span class="punctuation">,</span> <span class="string">&quot;C02&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Cisco&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Nexus9000&quot;</span><span class="punctuation">,</span> <span class="string">&quot;BJ-R01-C01-N9K-00-00-02&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CSW&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;10.0.0.3&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Beijing&quot;</span><span class="punctuation">,</span> <span class="string">&quot;R01&quot;</span><span class="punctuation">,</span> <span class="string">&quot;C03&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Cisco&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Nexus9000&quot;</span><span class="punctuation">,</span> <span class="string">&quot;BJ-R01-C01-N9K-00-00-03&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CSW&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>显而易见上面的数据是一个二维数组，即二维表格，那么他按理说就是可以存在MySQL里的，但在存进去之前需要先创建一个表结构，这个表结构包含了，这一张二维表中有几列，每一列的名称，数据类型，数据长度，默认值，注释等等信息，<strong>只有定义出一个表结构后，数据才能有存放的“容器”</strong>。</p>
<h3 id="表结构操作"><a href="#表结构操作" class="headerlink" title="表结构操作"></a><strong>表结构操作</strong></h3><p>安装和连接MySQL的过程，省略不提。</p>
<p><strong>其实MySQL的常用的操作并不多，无非是对表结构的增删改查（DDL），和对表数据的增删改查（DML）。</strong></p>
<p>创建一个数据库的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE python_ops;</span><br></pre></td></tr></table></figure>

<p>使用一个数据库的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE python_ops;</span><br></pre></td></tr></table></figure>

<p>创建设备表的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `devices` (</span><br><span class="line"></span><br><span class="line">    `id` <span class="type">INT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `ip` <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;ip地址&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `idc` <span class="type">VARCHAR</span>(<span class="number">32</span>) COMMENT <span class="string">&#x27;机房&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `<span class="type">row</span>` <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;机柜行&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `<span class="keyword">column</span>` <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;机柜列&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `vendor` <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;厂商&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `model` <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;型号&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `hostname` <span class="type">VARCHAR</span>(<span class="number">128</span>) COMMENT <span class="string">&#x27;主机名&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `role` <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;角色&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p><strong>关于表结构中的字段，有很多数据类型，较为常用的有 VARCHAR、INT、TEXT、TIMESTAMP、DATETIME、具体的使用会在用到的时候再进行具体讲解。</strong></p>
<p>创建好后查看表结构的SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">DESC devices;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/08/zvunkoSTsDcbmHZ.png" alt="img"></p>
<h3 id="表数据操作"><a href="#表数据操作" class="headerlink" title="表数据操作"></a><strong>表数据操作</strong></h3><p>通过<code>desc</code>查看的只是表的结构，目前<code>devices</code>表中仍然没有数据。</p>
<p><code>SELECT * FROM devices;</code> 查询<code>devices</code>表的SQL语句</p>
<p><img src="https://s2.loli.net/2023/04/08/GiaRBuOoUTHAqkr.png" alt="img"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> devices (`ip`, `idc`, `<span class="type">row</span>`, `<span class="keyword">column</span>`, `vendor`, `model`, `hostname`, `role`) <span class="keyword">VALUES</span> </span><br><span class="line"></span><br><span class="line">(&quot;10.0.0.1&quot;, &quot;Beijing&quot;, &quot;R01&quot;, &quot;C01&quot;, &quot;Cisco&quot;, &quot;Nexus9000&quot;, &quot;BJ-R01-C01-N9K-00-00-01&quot;, &quot;CSW&quot;),</span><br><span class="line"></span><br><span class="line">(&quot;10.0.0.2&quot;, &quot;Beijing&quot;, &quot;R01&quot;, &quot;C02&quot;, &quot;Cisco&quot;, &quot;Nexus9000&quot;, &quot;BJ-R01-C01-N9K-00-00-02&quot;, &quot;CSW&quot;),</span><br><span class="line"></span><br><span class="line">(&quot;10.0.0.3&quot;, &quot;Beijing&quot;, &quot;R01&quot;, &quot;C03&quot;, &quot;Cisco&quot;, &quot;Nexus9000&quot;, &quot;BJ-R01-C01-N9K-00-00-03&quot;, &quot;CSW&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/08/tKXIouCpyG9BUmi.png" alt="img"></p>
<p><strong>有一个需要注意的地方就是SQL语句中关于数据库名，表名，字段名在使用时最好加上反引号，这样可以避免与数据库内置的关键字冲突。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这一章节主要对数据库的基本概念做了一个简介，也是我们使用Web应用与数据库交互的前置条件，下一章节便会开始讲解如何使用Flask框架完成数据的增删改查。</p>
<h2 id="篇后语"><a href="#篇后语" class="headerlink" title="篇后语"></a><strong>篇后语</strong></h2><p>可能部分有基础的朋友对Flask或者Django有一定的了解，这些Web框架会提供一些封装好的方法，通过代码中定义数据模型，来自动创建表结构。</p>
<p>但我并不推荐这种方式，我觉得单从运维的角度来说，应该有一个理念，那就是不该存在任何黑盒操作，很明显通过一条指定就直接建好表结构这就属于黑盒操作，对于一些还没有数据库基础的朋友来说，虽然短时间内可以按照流程走通，长期来看绝对是<strong>弊大于利</strong>。</p>
<p>一键式的操作存在的意义，<strong>一是可以让已经完全熟悉原理的人节省重复的步骤，提高效率；二是可以让完全不懂的人不必在意底层实现进行无脑操作</strong>。但对于还处在正在学习自动化运维阶段的朋友来说，一定要有一个想法就是坚决不做第二种人。</p>
<p>我一直提倡的理念<strong>最小上手范围，是指学习并运用有限但必要的知识来解决面对的场景，并不提倡在知识匮乏的情况下，通过一些奇技淫巧来一步登天。</strong></p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>1.17 自动化运维新手村-Flask-ORM增删改查</title>
    <url>/posts/f690c1a9.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>上一章节，已经是正式在我们的后端应用中引入了MySQL数据库，并使用了Flask-SQLAlchemy作为ORM框架，来更方便的对数据库进行读写，增删改查是数据库的基本操作，今天这一章节就在对原先的后端做兼容MySQL改造的同时，也对“删、改、查”做一个详细的讲解</p>
<span id="more"></span>

<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a><strong>重构</strong></h2><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a><strong>模型定义</strong></h3><p>上一章节在<code>models.py</code>中定义了<code>Devices</code>模型，现在将它放在<code>app.py</code>中，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> text, DateTime, Numeric</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&quot;mysql+pymysql://root:root@127.0.0.1:3306/ops?charset=utf8&quot;</span></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">&#x27;devices&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>, comment=<span class="string">&quot;自增主键&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ip = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;IP地址&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hostname = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;主机名&quot;</span>)</span><br><span class="line"></span><br><span class="line">    idc = db.Column(db.String(<span class="number">32</span>), comment=<span class="string">&quot;机房&quot;</span>)</span><br><span class="line"></span><br><span class="line">    row = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    column = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜列&quot;</span>)</span><br><span class="line"></span><br><span class="line">    vendor = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;厂商&quot;</span>)</span><br><span class="line"></span><br><span class="line">    model = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;型号&quot;</span>)</span><br><span class="line"></span><br><span class="line">    role = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;角色&quot;</span>)</span><br><span class="line"></span><br><span class="line">    created_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.run(host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>以上示例代码中为了突出本章节重点内容，暂时省略掉了之前的权限认证部分。</p>
<p>有的朋友可能会有疑问，为什么不能将<code>Devices</code>放在<code>models.py</code>中，然后在<code>app.py</code>中将其import进来，这是因为，目前路由函数和<code>app</code>变量以及<code>db</code>变量的定义都写在<code>app.py</code>中，而<code>Devices</code>类又需要用到<code>db</code>变量，这样会造成<code>app.py</code>和<code>models.py</code>文件的循环引用。</p>
<p>关于如何合理规划数据库模型与路由函数以及<code>app</code>变量的挂载，我们会在后续的Flask工厂化内容中详细讲解。</p>
<h3 id="Python字典与模型转换"><a href="#Python字典与模型转换" class="headerlink" title="Python字典与模型转换"></a>Python字典与模型转换</h3><p>上一章节中提到，通过模型进行添加数据记录的方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = Devices(ip=<span class="string">&quot;10.0.0.1&quot;</span>, hostname=<span class="string">&quot;BJ-R01-C01-N9K-00-00-01&quot;</span>, idc=<span class="string">&quot;Beijing&quot;</span>, row=<span class="string">&quot;R01&quot;</span>, column=<span class="string">&quot;C01&quot;</span>, vendor=<span class="string">&quot;Cisco&quot;</span>, model=<span class="string">&quot;Nexus9000&quot;</span>, role=<span class="string">&quot;CSW&quot;</span>)</span><br><span class="line"></span><br><span class="line">db.session.add(device)</span><br><span class="line"></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure>

<p><code>Devices</code>是数据模型（表结构），将其实例化就可以得到一个<code>device</code>对象，相当于是数据库中的一行记录。</p>
<p>那么现在路由函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line"></span><br><span class="line">    data = request.get_json()</span><br><span class="line"></span><br><span class="line">    device = Devices(ip=data.get(<span class="string">&quot;ip&quot;</span>), hostname=data.get(<span class="string">&quot;hostname&quot;</span>), idc=data.get(<span class="string">&quot;idc&quot;</span>), row=data.get(<span class="string">&quot;row&quot;</span>), column=data.get(<span class="string">&quot;column&quot;</span>), verdor=data.get(<span class="string">&quot;vendor&quot;</span>), model=data.get(<span class="string">&quot;model&quot;</span>), role=data.get(<span class="string">&quot;role&quot;</span>))</span><br><span class="line"></span><br><span class="line">    db.session.add(device)</span><br><span class="line"></span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK&#125;</span><br></pre></td></tr></table></figure>

<p>上述路由函数中通过一个个指定属性值的方式来对<code>Devices</code>记录进行初始化，显然这样做不太优雅，我们可以在<code>Devices</code>类中增加一个方法来实现字典类型到<code>Devices</code>模型的转换，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">&#x27;devices&#x27;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_model</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">        device = Devices() <span class="comment"># 实例化一个device对象</span></span><br><span class="line"></span><br><span class="line">        columns = [c.name <span class="keyword">for</span> c <span class="keyword">in</span> cls.__table__.columns] <span class="comment"># 获取Devices模型定义的所有列属性的名字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items(): <span class="comment"># 遍历传入kwargs的键值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> columns: <span class="comment"># 如果键包含在列名中，则为该device对象赋加对应的属性值</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">setattr</span>(device, k, v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> device</span><br></pre></td></tr></table></figure>

<p>上述代码在<code>Devices</code>类中新增了一个类方法，类方法的主要功能就是将<code>kwargs</code>转换为<code>device</code>对象，具体逻辑已通过注释给出。</p>
<blockquote>
<p>类方法是用在该方法只与类本身有关联，而与类的实例无关的时候。</p>
</blockquote>
<blockquote>
<p>通俗的说就是类方法的第一个参数是<code>cls</code>，表示类本身，而实例方法的第一个参数是<code>self</code>表示类的实例；这里的<code>cls</code>和<code>self</code>都可以重命名，并没有强制要求。</p>
</blockquote>
<blockquote>
<p>关于类方法和实例方法这里不做过多解释，大家可以通过这一章节的示例代码仔细体会，也可以下来自行多做研究。</p>
</blockquote>
<p>这里使用了一个Python中的小技巧——列表推导式，其实也可以简单的理解为就是将循环写在了一行里面，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">columns = [c.name <span class="keyword">for</span> c <span class="keyword">in</span> cls.__table__.columns]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line">columns = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cls.__table__.columns:</span><br><span class="line"></span><br><span class="line">    columns.append(c.name)</span><br></pre></td></tr></table></figure>

<p>对应的还有字典推导式，在后面的代码中会有示例。</p>
<p>在有了这个类方法后，路由函数就可以大大简化，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line"></span><br><span class="line">    data = request.get_json()</span><br><span class="line"></span><br><span class="line">    device = Devices.to_model(**data)</span><br><span class="line"></span><br><span class="line">    db.session.add(device)</span><br><span class="line"></span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK&#125;</span><br></pre></td></tr></table></figure>

<p>通过Postman发起请求结果如下图：</p>
<p><img src="https://s2.loli.net/2023/04/08/pTytFJuWLY3O84f.png" alt="img"></p>
<h3 id="模型与Python字典转换"><a href="#模型与Python字典转换" class="headerlink" title="模型与Python字典转换"></a><strong>模型与Python字典转换</strong></h3><p>既然在增加数据时需要将字典转换成ORM模型，那么在查询数据时同样也需要将ORM模型转换为字典，方便对其进行后续的操作。</p>
<p>新增使用Flask-SQLAlchemy进行查询所有设备记录的路由函数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/get&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 查询CMDB &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    devices = Devices.query.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> device <span class="keyword">in</span> devices:</span><br><span class="line"></span><br><span class="line">        res.append(&#123;<span class="string">&quot;id&quot;</span>: device.<span class="built_in">id</span>, <span class="string">&quot;ip&quot;</span>: device.ip, <span class="string">&quot;hostname&quot;</span>: device.hostname, <span class="string">&quot;idc&quot;</span>: device.idc, <span class="string">&quot;row&quot;</span>: device.row, <span class="string">&quot;column&quot;</span>: device.column, <span class="string">&quot;vendor&quot;</span>: device.vendor, <span class="string">&quot;model&quot;</span>: device.model, <span class="string">&quot;role&quot;</span>: device.role&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;data&quot;</span>: res&#125;)</span><br></pre></td></tr></table></figure>

<p>在查询数据时先通过<code>model.query</code>获取到对数据表的操作句柄，之后再使用额外的查询条件对数据进行过滤查询，上述代码中直接使用了<code>all()</code>方法，来获取数据表的所有记录。</p>
<p>通过ORM模型查询到的记录都是模型的实例对象，而接口返回数据时，无法对实例对象做JSON序列化处理，所以需要将其手动转换为字典后再返回；但上述代码中的转换逻辑过于繁琐，可以通过在ORM模型类中增加一个方法来实现模型对象与Python字典的互相转换，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">&#x27;devices&#x27;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;c.name: <span class="built_in">getattr</span>(self, c.name) <span class="keyword">for</span> c <span class="keyword">in</span> self.__table__.columns&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中增加了一个实例方法来实现转换功能，大家可以思考一下为什么模型转字典用的是实例方法，而字典转模型用的是类方法？</p>
<p>这里还用到了前文提到的字典推导式，同样字典推导式也可以理解为将字典的循环代码写到了一行，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;c.name: <span class="built_in">getattr</span>(self, c.name) <span class="keyword">for</span> c <span class="keyword">in</span> self.__table__.columns&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line">res = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> self.__table__.columns:</span><br><span class="line"></span><br><span class="line">    res[c.name] = <span class="built_in">getattr</span>(self, c.name)</span><br></pre></td></tr></table></figure>

<p>现在有了模型到字典的转换方法之后，查询的路由函数简化如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/get&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 查询CMDB &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    res = [d.to_dict() <span class="keyword">for</span> d <span class="keyword">in</span> Devices.query.<span class="built_in">all</span>()]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;data&quot;</span>: res&#125;)</span><br></pre></td></tr></table></figure>

<p>通过Postman发起请求结果如下图：</p>
<p>从查询结果可以看出，已经可以顺利查询出所有记录，但红框处的时间却不是比较易读的时间格式，这是因为在进行模型到字典转化的过程中，并没有对时间类型做单独处理，所以现在修改<code>Device.to_dict()</code>方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> DateTime, Numeric</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Device</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        res = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> self.__table__.columns:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(col.<span class="built_in">type</span>, DateTime): <span class="comment"># 判断类型是否为DateTime</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">getattr</span>(self, col.name): <span class="comment"># 判断实例中该字段是否有值</span></span><br><span class="line"></span><br><span class="line">                    value = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 进行格式转换</span></span><br><span class="line"></span><br><span class="line">                    value = <span class="built_in">getattr</span>(self, col.name).strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(col.<span class="built_in">type</span>, Numeric): <span class="comment"># 判断类型是否为Numeric</span></span><br><span class="line"></span><br><span class="line">                value = <span class="built_in">float</span>(<span class="built_in">getattr</span>(self, col.name)) <span class="comment"># 进行格式转换</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 剩余的直接取值</span></span><br><span class="line"></span><br><span class="line">                value = <span class="built_in">getattr</span>(self, col.name)</span><br><span class="line"></span><br><span class="line">            res[col.name] = value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>修改后，通过Postman发起请求结果如下图：</p>
<h3 id="查询分页"><a href="#查询分页" class="headerlink" title="查询分页"></a><strong>查询分页</strong></h3><p>ORM的查询有非常多的过滤方法和功能，文章中无法一一对其进行列举，只列举几个常用的供大家参考，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询所有设备</span></span><br><span class="line"></span><br><span class="line">Devices.query.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询有多少台设备</span></span><br><span class="line"></span><br><span class="line">Devices.query.count()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询第1个设备</span></span><br><span class="line"></span><br><span class="line">Devices.query.first()</span><br><span class="line"></span><br><span class="line">Devices.query.get(<span class="number">1</span>) <span class="comment"># 根据id查询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询id为4的设备[3种方式]</span></span><br><span class="line"></span><br><span class="line">Devices.query.get(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">Devices.query.filter_by(<span class="built_in">id</span>=<span class="number">4</span>).<span class="built_in">all</span>() <span class="comment"># 简单查询 使用关键字实参的形式来设置字段名</span></span><br><span class="line"></span><br><span class="line">Devices.query.<span class="built_in">filter</span>(Devices.<span class="built_in">id</span> == <span class="number">4</span>).<span class="built_in">all</span>() <span class="comment"># 复杂查询 使用恒等式等其他形式来设置条件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询主机名结尾字符为g的所有设备[开始 / 包含]</span></span><br><span class="line"></span><br><span class="line">Devices.query.<span class="built_in">filter</span>(Devices.hostname.endswith(<span class="string">&quot;g&quot;</span>)).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">Devices.query.<span class="built_in">filter</span>(Devices.hostname.startswith(<span class="string">&quot;w&quot;</span>)).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">Devices.query.<span class="built_in">filter</span>(Devices.hostname.contains(<span class="string">&quot;n&quot;</span>)).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line">Devices.query.<span class="built_in">filter</span>(Devices.hostname.like(<span class="string">&quot;%n%g&quot;</span>)).<span class="built_in">all</span>() <span class="comment"># 模糊查询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询对应厂商和设备类型所有设备</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> and_</span><br><span class="line"></span><br><span class="line">Devices.query.<span class="built_in">filter</span>(and_(Devices.model == <span class="string">&quot;Cisco&quot;</span>, Devices.vendor == <span class="string">&quot;Nexus9000&quot;</span>)).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有设备按id从大到小排序, 取前5个</span></span><br><span class="line"></span><br><span class="line">Devices.query.order_by(Devices.<span class="built_in">id</span>.desc()).limit(<span class="number">5</span>).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页查询, 查询第2页的数据, 每页10个,</span></span><br><span class="line"></span><br><span class="line">pn = Devices.query.paginate(page=<span class="number">2</span>, per_page=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pn.items 获取该页的数据 pn.total 获取总共有多少条数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态条件查询</span></span><br><span class="line"></span><br><span class="line">filters = &#123;Devices.<span class="built_in">id</span> &gt;=<span class="number">15</span>, Device.hostname!=<span class="string">&#x27;&#x27;</span>&#125; 可以在filters中添加或减少条件</span><br><span class="line"></span><br><span class="line">Devices.query.<span class="built_in">filter</span>(*filters).<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure>

<h2 id="删除和修改"><a href="#删除和修改" class="headerlink" title="删除和修改"></a><strong>删除和修改</strong></h2><p>删除和修改的功能相对来说较为简单，无非是在进行操作之前先通过查询条件将数据过滤出来，然后再进行删除或修改操作，具体实现大家可以看完整重构后的代码。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> http <span class="keyword">import</span> HTTPStatus</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> text, DateTime, Numeric</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&quot;mysql+pymysql://root:root@127.0.0.1:3306/ops?charset=utf8&quot;</span></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">&#x27;devices&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>, comment=<span class="string">&quot;自增主键&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ip = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;IP地址&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hostname = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;主机名&quot;</span>)</span><br><span class="line"></span><br><span class="line">    idc = db.Column(db.String(<span class="number">32</span>), comment=<span class="string">&quot;机房&quot;</span>)</span><br><span class="line"></span><br><span class="line">    row = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    column = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜列&quot;</span>)</span><br><span class="line"></span><br><span class="line">    vendor = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;厂商&quot;</span>)</span><br><span class="line"></span><br><span class="line">    model = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;型号&quot;</span>)</span><br><span class="line"></span><br><span class="line">    role = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;角色&quot;</span>)</span><br><span class="line"></span><br><span class="line">    created_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    updated_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), server_onupdate=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;修改时间&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        res = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> self.__table__.columns:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(col.<span class="built_in">type</span>, DateTime):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">getattr</span>(self, col.name):</span><br><span class="line"></span><br><span class="line">                    value = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                    value = <span class="built_in">getattr</span>(self, col.name).strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(col.<span class="built_in">type</span>, Numeric):</span><br><span class="line"></span><br><span class="line">                value = <span class="built_in">float</span>(<span class="built_in">getattr</span>(self, col.name))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                value = <span class="built_in">getattr</span>(self, col.name)</span><br><span class="line"></span><br><span class="line">            res[col.name] = value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_model</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">        device = Devices()</span><br><span class="line"></span><br><span class="line">        columns = [c.name <span class="keyword">for</span> c <span class="keyword">in</span> cls.__table__.columns]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> columns:</span><br><span class="line"></span><br><span class="line">                <span class="built_in">setattr</span>(device, k, v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> device</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/get&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 查询CMDB &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    page_size = request.args.get(<span class="string">&quot;pageSize&quot;</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    page = request.args.get(<span class="string">&quot;page&quot;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    devices = Devices.query.paginate(page=page, per_page=page_size)</span><br><span class="line"></span><br><span class="line">    res = [d.to_dict() <span class="keyword">for</span> d <span class="keyword">in</span> devices.items]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;data&quot;</span>: res, <span class="string">&quot;total&quot;</span>: devices.total&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line"></span><br><span class="line">    data = request.get_json()</span><br><span class="line"></span><br><span class="line">    device = Devices.to_model(**data)</span><br><span class="line"></span><br><span class="line">    db.session.add(device)</span><br><span class="line"></span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;data&quot;</span>: device.to_dict()&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/update&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>():</span><br><span class="line"></span><br><span class="line">    data = request.get_json()</span><br><span class="line"></span><br><span class="line">    Devices.query.filter_by(<span class="built_in">id</span>=data.pop(<span class="string">&quot;id&quot;</span>)).update(data)</span><br><span class="line"></span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/delete&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line"></span><br><span class="line">    data = request.get_json()</span><br><span class="line"></span><br><span class="line">    Devices.query.filter_by(<span class="built_in">id</span>=data.get(<span class="string">&quot;id&quot;</span>)).delete()</span><br><span class="line"></span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.run(host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前为止，已经对ORM框架有了初步的认识，并且在我们的后端应用中集成了Flask-SQLAlchemy插件，完成了资产数据增删改查的改造，重构过程中也涉及到了一些Python进阶的知识点，希望大家可以在阅读的过程中仔细体会。</p>
<p>这次只是一个基本的重构，关于路由函数接收的参数和异常的处理也并没有做到很完善，大家可以先自己尝试修改，在下一章节中，我会新增一个端口表，来丰富资产数据，并且讲解ORM的关联查询，同时给出更为完善的代码。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>1.18 自动化运维新手村-Flask-ORM关联查询</title>
    <url>/posts/771bf9cc.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>到目前为止，Flask集成ORM扩展到基本操作，已经算是接近尾声了，上一章节已经将单表数据的增删改查，做了十分详细的讲解，并且从Flask应用的日志中可以看出每个ORM操作对应的数据库SQL语句，能够更为清晰的看到程序模型到数据库之间的映射关系，让大家可以对MySQL有一个基本的了解。</p>
<p>但几乎所有的后端应用都不可能只存在单独的一张数据表，大多数情况下都是存在多张数据表，并且这些数据表之间都存在关联，可能是一对一，或者一对多，等等。那么今天这一章节我们就着重讲解一下如何使用Flask-SQLAlchemy进行多表关联查询，并逐步完善后端应用的参数及异常处理。</p>
<span id="more"></span>

<h2 id="一-x2F-一-到-多-x2F-多"><a href="#一-x2F-一-到-多-x2F-多" class="headerlink" title="一&#x2F;一 到 多&#x2F;多"></a><strong>一&#x2F;一 到 多&#x2F;多</strong></h2><p>数据库两张表之间的关系主要存在以下几种关系：</p>
<ol>
<li>一对一</li>
<li>一对多</li>
<li>多对多</li>
</ol>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a><strong>一对一</strong></h3><p>一对一是关系型数据库的两张表中较为普遍的映射关系，比如，设备信息表 - 设备详情表；</p>
<p>设备信息表中存储的设备基本信息包括<code>ip, hostname, idc, row, column, vendor, model, role</code>，那么一台设备除了具备这些基本信息外，可能还包含其他额外的信息，比如：资产号，最近一次启动时间，运行总时长，操作系统镜像版本，运行状态，过保时间，是否过保，Console口管理地址，IPv6管理地址，等等。</p>
<p>那么常用的做法就是将这些额外的信息单独建立一张设备详情表，一是避免原始表的数据列过多，二是基本信息和详细信息的查询频率也略有差异，并不是任何时候都需要将这些信息都查出来，所以建两张表是较为合适的做法。</p>
<p><img src="https://s2.loli.net/2023/04/08/9ucer428yMH3lsJ.png" alt="img"></p>
<p>如上图所示，略微调整了一下设备信息表，将部分字段放在了设备详情表中，并且在两张表中都增加<code>sn（资产号）</code>字段作为主键，来唯一标识一台设备，这是因为在堆叠交换机中，主备两台设备的IP是相同的，但资产号一直是可以保持唯一的。</p>
<p>所以将设备信息表和设备详情表通过资产号进行关联，形成一对一的关系。</p>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a><strong>一对多</strong></h3><p>一对多在关系型数据库中是最为普遍的映射关系，因为一对一在不考虑过滤数据库范式的情况下，可以将其合并成一张表。</p>
<p>一对多比较好理解的例子就是设备信息表与设备端口表之间的关系，设备信息表中的一行数据可以表示一台设备，而一台设备可以具有多个端口，这多个端口在端口表中存储为多行，所以两张表之间就形成了一对多关系，如下：</p>
<p><img src="https://s2.loli.net/2023/04/08/6FT5xoLmOzpRPDQ.png" alt="img"></p>
<p>如上图所示，设备端口表中需要有一列资产号字段，最终数据的内容中，多行端口信息的sn可能相同，这个sn就可以与设备进行关联。</p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a><strong>多对多</strong></h3><p>当两张表存在多对多关系时，通常的做法是额外新增一张中间表来进行关联，将一个多对多转换为两个多对一。</p>
<p>由于我们对后端应用中暂时没有多对多的场景，大家暂时只做初步的了解即可，如果十分感兴趣的朋友可以自行多做研究。</p>
<h2 id="Flask关联查询"><a href="#Flask关联查询" class="headerlink" title="Flask关联查询"></a><strong>Flask关联查询</strong></h2><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a><strong>定义模型</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">&quot;devices&quot;</span></span><br><span class="line"></span><br><span class="line">    sn = db.Column(db.String(<span class="number">128</span>), primary_key=<span class="literal">True</span>, comment=<span class="string">&quot;资产号&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ip = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;IP地址&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hostname = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;主机名&quot;</span>)</span><br><span class="line"></span><br><span class="line">    idc = db.Column(db.String(<span class="number">32</span>), comment=<span class="string">&quot;机房&quot;</span>)</span><br><span class="line"></span><br><span class="line">    vendor = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;厂商&quot;</span>)</span><br><span class="line"></span><br><span class="line">    model = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;型号&quot;</span>)</span><br><span class="line"></span><br><span class="line">    role = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;角色&quot;</span>)</span><br><span class="line"></span><br><span class="line">    created_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    updated_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), server_onupdate=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;修改时间&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceDetail</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename = <span class="string">&quot;device_detail&quot;</span></span><br><span class="line"></span><br><span class="line">    sn = db.Column(db.String(<span class="number">128</span>), db.ForeignKey(Devices.sn), primary_key=<span class="literal">True</span>, comment=<span class="string">&quot;资产号&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ipv6 = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;IPv6地址&quot;</span>)</span><br><span class="line"></span><br><span class="line">    console_ip = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;console地址&quot;</span>)</span><br><span class="line"></span><br><span class="line">    row = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    column = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜列&quot;</span>)</span><br><span class="line"></span><br><span class="line">    last_start = db.Column(db.DateTime(), comment=<span class="string">&quot;最近启动时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    runtime = db.Column(db.Integer, comment=<span class="string">&quot;运行时长&quot;</span>)</span><br><span class="line"></span><br><span class="line">    image_version = db.Column(db.String(<span class="number">128</span>), comment=<span class="string">&quot;镜像版本&quot;</span>)</span><br><span class="line"></span><br><span class="line">    over_warrant = db.Column(db.BOOLEAN, comment=<span class="string">&quot;是否过保&quot;</span>)</span><br><span class="line"></span><br><span class="line">    warrant_time = db.Column(db.DateTime(), comment=<span class="string">&quot;过保时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    created_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    updated_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), server_onupdate=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;修改时间&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ports</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename = <span class="string">&quot;ports&quot;</span></span><br><span class="line"></span><br><span class="line">    sn = db.Column(db.String(<span class="number">128</span>), db.ForeignKey(Devices.sn), primary_key=<span class="literal">True</span>, comment=<span class="string">&quot;资产号&quot;</span>)</span><br><span class="line"></span><br><span class="line">    port_id = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, primary_key=<span class="literal">True</span>, comment=<span class="string">&quot;端口ID&quot;</span>)</span><br><span class="line"></span><br><span class="line">    port_name = db.Column(db.String(<span class="number">64</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;端口名称&quot;</span>)</span><br><span class="line"></span><br><span class="line">    port_type = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;端口类型&quot;</span>)</span><br><span class="line"></span><br><span class="line">    bandwidth = db.Column(db.Integer, comment=<span class="string">&quot;端口速率&quot;</span>)</span><br><span class="line"></span><br><span class="line">    link_status = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;链路状态&quot;</span>)</span><br><span class="line"></span><br><span class="line">    admin_status = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;管理状态&quot;</span>)</span><br><span class="line"></span><br><span class="line">    interface_ip = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;端口IP&quot;</span>)</span><br><span class="line"></span><br><span class="line">    vlan_id = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;端口所属VLAN&quot;</span>)</span><br><span class="line"></span><br><span class="line">    created_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    updated_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), server_onupdate=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;修改时间&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a><strong>创建数据表</strong></h3><p>三张表的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> devices (</span><br><span class="line"></span><br><span class="line">        sn <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;资产号&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        ip <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;IP地址&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        hostname <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主机名&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        idc <span class="type">VARCHAR</span>(<span class="number">32</span>) COMMENT <span class="string">&#x27;机房&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        vendor <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;厂商&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        model <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;型号&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        `role` <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;角色&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        created_at DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> ON_UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"></span><br><span class="line">        updated_at DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> ON_UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY (sn)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> device_detail (</span><br><span class="line"></span><br><span class="line">        sn <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;资产号&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        ipv6 <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;IPv6地址&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        console_ip <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;console地址&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        `<span class="type">row</span>` <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;机柜行&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        `<span class="keyword">column</span>` <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;机柜列&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        last_start DATETIME COMMENT <span class="string">&#x27;最近启动时间&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        runtime <span class="type">INTEGER</span> COMMENT <span class="string">&#x27;运行时长&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        image_version <span class="type">VARCHAR</span>(<span class="number">128</span>) COMMENT <span class="string">&#x27;镜像版本&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        over_warrant BOOL COMMENT <span class="string">&#x27;是否过保&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        warrant_time DATETIME COMMENT <span class="string">&#x27;过保时间&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        created_at DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> ON_UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"></span><br><span class="line">        updated_at DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> ON_UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY (sn),</span><br><span class="line"></span><br><span class="line">        <span class="keyword">FOREIGN</span> KEY(sn) <span class="keyword">REFERENCES</span> devices (sn)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ports (</span><br><span class="line"></span><br><span class="line">        sn <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;资产号&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        port_id <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;端口ID&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        port_name <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;端口名称&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        port_type <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;端口类型&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        bandwidth <span class="type">INTEGER</span> COMMENT <span class="string">&#x27;端口速率&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        link_status <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;链路状态&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        admin_status <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;管理状态&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        interface_ip <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;端口IP&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        vlan_id <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;端口所属VLAN&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        created_at DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> ON_UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"></span><br><span class="line">        updated_at DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> ON_UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY (sn, port_id),</span><br><span class="line"></span><br><span class="line">        <span class="keyword">FOREIGN</span> KEY(sn) <span class="keyword">REFERENCES</span> devices (sn)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="一对一-1"><a href="#一对一-1" class="headerlink" title="一对一"></a><strong>一对一</strong></h4><p>通常在主表中定义<code>relationship</code>，在附表中定义外键，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">&quot;devices&quot;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    detail = db.relationship(<span class="string">&quot;DeviceDetail&quot;</span>, uselist=<span class="literal">False</span>, backref=<span class="string">&quot;device&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceDetail</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename = <span class="string">&quot;device_detail&quot;</span></span><br><span class="line"></span><br><span class="line">    sn = db.Column(db.String(<span class="number">128</span>), db.ForeignKey(Devices.sn), primary_key=<span class="literal">True</span>, comment=<span class="string">&quot;资产号&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ol>
<li>上述代码中的<code>relationship</code>，是关联属性的意思，是SQLAlchemy提供给开发者快速引用外键模型的一个对象属性，本身并不存在于MySQL中；</li>
<li><code>relationship的</code>参数<code>backref</code>表示反向引用，通过外键模型查询主模型数据时的关联属性，通俗的讲就是在查<code>DeviceDetail</code>数据时，可以通过<code>backref</code>引用到<code>Devices</code>。</li>
<li><code>useList</code>表示关联模型是否为List，如果为False，则不使用列表，而使用变量。一对一关系中，需要设置relationship中的<code>uselist=Flase</code>。</li>
</ol>
<h4 id="一对多-1"><a href="#一对多-1" class="headerlink" title="一对多"></a><strong>一对多</strong></h4><p>通常在“一”表中定义<code>relationship</code>，在“多”表中定义外键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">&quot;devices&quot;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ports = db.relationship(<span class="string">&quot;Ports&quot;</span>, uselist=<span class="literal">True</span>, backref=<span class="string">&quot;device&quot;</span>, lazy=<span class="string">&#x27;dynamic&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>由于<code>Deviecs</code>表和<code>Ports</code>表之间为一对多，通过<code>Devices</code>会关联查询到一个或多个端口记录，所以需要将<code>useList</code>设为True</li>
<li>参数<code>backref</code>可以在<code>Ports</code>中自动创建一个<code>device</code>属性，作为<code>Devices</code>的反向引用</li>
<li>参数<code>lazy</code>决定了ORM框架何时从数据库中加载数据：</li>
</ol>
<p>  <code>lazy=&#39;subquery&#39;</code>，查询当前数据模型时，采用子查询(subquery)，把外键模型的属性也瞬间查询出来了。</p>
<p><code>lazy=True</code>或<code>lazy=&#39;select&#39;</code>，查询当前数据模型时，不会把外键模型的数据查询出来，只有操作到外键关联属性时，才进行连表查询数据</p>
<p><code>lazy=&#39;dynamic&#39;</code>，查询当前数据模型时，不会把外键模型的数据查询出来，只有操作到外键关联属性并操作外键模型具体属性时，才进行连表查询数据</p>
<h2 id="Flask改造"><a href="#Flask改造" class="headerlink" title="Flask改造"></a><strong>Flask改造</strong></h2><p>统一给三个模型都加上<code>to_dict()</code>和<code>to_model()</code>方法。</p>
<p>一对一获取设备详情的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/get_detail&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_detail</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 查询设备详情 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    sn = request.args.get(<span class="string">&quot;sn&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sn:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.BAD_REQUEST, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;must have sn arg&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        device = Devices.query.filter_by(sn=sn).first()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> device:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;data&quot;</span>: &#123;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">        res = &#123;**device.to_dict(), **device.detail.to_dict()&#125; <span class="comment"># 通过device类的detail属性获取DeviceDetail的实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;data&quot;</span>: res&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.INTERNAL_SERVER_ERROR, <span class="string">&quot;message&quot;</span>: <span class="built_in">str</span>(e)&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码中使用到了字典的一个小技巧，将多个字典合并可以使用<code>&#123;**dict1, dict2&#125;</code></p>
<p>一对一添加设备详情的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/add_devices&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_devices</span>():</span><br><span class="line"></span><br><span class="line">    data = request.get_json()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.BAD_REQUEST, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;must have sn arg&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(data, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">        data = [data]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        devices = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">            device = Devices.to_model(**d) <span class="comment"># 生成Device模型实例</span></span><br><span class="line"></span><br><span class="line">            device.detail = DeviceDetail.to_model(**d) <span class="comment"># 生成DeviceDetail模型实例，并赋值给device对象</span></span><br><span class="line"></span><br><span class="line">            devices.append(device) <span class="comment"># 插入数据库</span></span><br><span class="line"></span><br><span class="line">        db.session.add_all(devices)</span><br><span class="line"></span><br><span class="line">        db.session.commit()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.INTERNAL_SERVER_ERROR, <span class="string">&quot;message&quot;</span>: <span class="built_in">str</span>(e)&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/08/VQ1USWAcsOHd3jR.png" alt="img"></p>
<p>一对多添加端口的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_ports</span>():</span><br><span class="line"></span><br><span class="line">    data = request.get_json()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(data, <span class="built_in">list</span>):</span><br><span class="line"></span><br><span class="line">        data = [data]</span><br><span class="line"></span><br><span class="line">    sns = <span class="built_in">list</span>(<span class="built_in">set</span>([p.get(<span class="string">&quot;sn&quot;</span>, <span class="string">&quot;&quot;</span>) <span class="keyword">for</span> p <span class="keyword">in</span> data])) <span class="comment"># 获取传入端口参数中的资产号，并去重</span></span><br><span class="line"></span><br><span class="line">    devices = Devices.query.with_entities(Devices.sn).<span class="built_in">filter</span>(Devices.sn.in_(sns)).<span class="built_in">all</span>() <span class="comment"># 查询对应资产号的设备</span></span><br><span class="line"></span><br><span class="line">    exists_sn = [d.sn <span class="keyword">for</span> d <span class="keyword">in</span> devices] <span class="comment"># 获取数据库中已存在的资产号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        ports = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> p.get(<span class="string">&quot;sn&quot;</span>, <span class="string">&quot;&quot;</span>) <span class="keyword">not</span> <span class="keyword">in</span> exists_sn: <span class="comment"># 如果端口所属的设备不存在，则返回错误</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.INTERNAL_SERVER_ERROR, <span class="string">&quot;message&quot;</span>: p.get(<span class="string">&quot;sn&quot;</span>, <span class="string">&quot;&quot;</span>) + <span class="string">&quot; device is not exists&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">            ports.append(Ports.to_model(**p))</span><br><span class="line"></span><br><span class="line">        db.session.add_all(ports)</span><br><span class="line"></span><br><span class="line">        db.session.commit()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.INTERNAL_SERVER_ERROR, <span class="string">&quot;message&quot;</span>: <span class="built_in">str</span>(e)&#125;)</span><br></pre></td></tr></table></figure>

<p>如代码中注释，需要在添加端口前判断是否已存在该端口所属的设备，如果设备不存在则应该直接返回错误；</p>
<p>而实际上，即使不做这个判断，由于数据库中外键约束的存在，也会导致插入数据出错，但在接口编写时，应该遵循的原则是，将非法检查前置，避免压力集中在数据库上，这样有利于提高应用整体性能。 </p>
<p><img src="https://s2.loli.net/2023/04/08/JNgOjdC9k3tUo1F.png" alt="img"></p>
<p>一对多获取设备端口的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb/get_ports&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ports</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 查询设备端口 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    sn = request.args.get(<span class="string">&quot;sn&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sn:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.BAD_REQUEST, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;must have sn arg&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        device = Devices.query.filter_by(sn=sn).first()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> device:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;data&quot;</span>: &#123;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">        ports = [p.to_dict() <span class="keyword">for</span> p <span class="keyword">in</span> device.ports]</span><br><span class="line"></span><br><span class="line">        res = &#123;**device.to_dict(), <span class="string">&quot;ports&quot;</span>: ports&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;data&quot;</span>: res&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status_code&quot;</span>: HTTPStatus.INTERNAL_SERVER_ERROR, <span class="string">&quot;message&quot;</span>: <span class="built_in">str</span>(e)&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/08/Otk1joWb6J9Xcpu.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这一章节我们对Flask-SQLAlchemy中关联查询的方法做了较为详细的讲解，并且从数据库层面分析了一对一，一对多等关系，除此之外还实现了一对一&#x2F;多的查询和添加，其中使用到了一些较为Pythonic的语法和逻辑，需要大家慢慢消化。</p>
<p>最终整体的代码由于篇幅原因暂时就不放在文章中，如果有需要的朋友可以通过微信公众号加入读者交流群后获取。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>1.12 自动化运维新手村-Flask-请求处理</title>
    <url>/posts/d3770b06.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>上一章节主要给大家讲解了一下Flask的最小化上手范围，这一章节的内容仍然不会脱离这个“<strong>范围</strong>”，而是在这个“范围”中，让我们的代码变得<strong>更健壮，并且能够在生产环境中真正使用。</strong></p>
<span id="more"></span>

<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a><strong>POST请求</strong></h2><p>上一篇关于POST请求，提到的比较少，这里暂时放一张使用Postman发送POST请求的截图，大家可以模仿着使用，具体关于HTTP请求方法的讲解和<strong>关于更多GET，POST之间的对比，我们在番外篇中会详细讲解。</strong></p>
<h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a><strong>Flask</strong></h2><h3 id="精简路由"><a href="#精简路由" class="headerlink" title="精简路由"></a><strong>精简路由</strong></h3><p>上一章节在<code>cmdb.py</code>中新增了如下代码，来获取CMDB的实例化对象，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmdb.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmdb_handler</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        file_store = Store(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;data.json&quot;</span>) <span class="comment"># 实例化一个文件存储的存储对象</span></span><br><span class="line"></span><br><span class="line">        cmdb = CMDB(file_store) <span class="comment"># 传入读出的数据源实例化一个CMDB的对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cmdb</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;get cmdb handler failed, err: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

<p>同时新增了五个路由来分别处理对CMDB不同的操作，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/get&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/init&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/update&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/delete&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>但这些路由函数中都统一调用了<code>CMDB_HANDLER.execute()</code>这一个方法，那么是不是表明可以将这五个操作合成一个路由函数。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cmdb <span class="keyword">import</span> cmdb_handler, HTTPParams</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmdb</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作CMDB&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    operation = request.form.get(<span class="string">&quot;operation&quot;</span>)</span><br><span class="line"></span><br><span class="line">    region = request.form.get(<span class="string">&quot;region&quot;</span>)</span><br><span class="line"></span><br><span class="line">    path = request.form.get(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">    attr = request.form.get(<span class="string">&quot;attr&quot;</span>)</span><br><span class="line"></span><br><span class="line">    params = HTTPParams(CMDB_HANDLER.operations)</span><br><span class="line"></span><br><span class="line">    op, args = params.parse(operation=operation, path=path, attr=attr, region=region)</span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(op, [*args])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>经过重构后，抛弃掉原先使用路由PATH来区分对CMDB的操作类型，而是通过请求中新增一个参数<code>operation</code>来进行区分。</p>
<p>并且这里使用了一个新的类<code>HTTPParams</code>，之前我们提到过CMDB的面向对象方案中，有一个<code>Params</code>的类，用于处理操作CMDB的参数。</p>
<p>原始的<code>Params</code>是对命令行参数做解析，而现在就可以定义一个<code>HTTPParams</code>来继承<code>Params</code>，并重写<code>parse</code>函数即可，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HTTPParams</span>(<span class="title class_ inherited__">Params</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(kwargs) &lt; <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;please input operation and args, operations: %s&quot;</span> % <span class="string">&quot;,&quot;</span>.join(self.operations))</span><br><span class="line"></span><br><span class="line">        operation = kwargs.get(<span class="string">&quot;operation&quot;</span>)</span><br><span class="line"></span><br><span class="line">        region = kwargs.get(<span class="string">&quot;region&quot;</span>)</span><br><span class="line"></span><br><span class="line">        path = kwargs.get(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">        attr = kwargs.get(<span class="string">&quot;attr&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> operation <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> region <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># 处理init</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> operation, [region]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> attr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> operation, [path, attr]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> operation, [path] <span class="comment"># 处理get</span></span><br></pre></td></tr></table></figure>

<p>这里简单提一下，一个<strong>子类继承了父类，当子类没有实现__init__()方法的时候，会默认调用父类的__init__()方法。</strong></p>
<p>重写的<code>parse</code>方法中，对<code>init</code>和<code>get</code>操作分别做了特殊处理，以方便后续调用<code>cmdb.execute()</code>方法。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h3><p>目前为止，Flask后端应用的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> cmdb <span class="keyword">import</span> cmdb_handler, HTTPParams</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMDB_HANDLER = cmdb_handler()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmdb</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作CMDB&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    operation = request.form.get(<span class="string">&quot;operation&quot;</span>)</span><br><span class="line"></span><br><span class="line">    region = request.form.get(<span class="string">&quot;region&quot;</span>)</span><br><span class="line"></span><br><span class="line">    path = request.form.get(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">    attr = request.form.get(<span class="string">&quot;attr&quot;</span>)</span><br><span class="line"></span><br><span class="line">    params = HTTPParams(CMDB_HANDLER.operations)</span><br><span class="line"></span><br><span class="line">    op, args = params.parse(operation=operation, path=path, attr=attr, region=region)</span><br><span class="line"></span><br><span class="line">    ret = CMDB_HANDLER.execute(op, [*args])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">5000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>终于让代码又成功减少了很多行…</p>
</blockquote>
<p>在<code>HTTPParams</code>和<code>CMDB</code>中，对于异常情况都直接做了<code>raise Exception()</code>的处理，所以在发生异常时，这个错误会通过调用栈一直向上层抛出，这样会发生如下情况：</p>
<p><img src="https://s2.loli.net/2023/04/08/eZYbCo6fzIA7vED.png" alt="img"></p>
<p>HTTP的API请求会直接报出<code>500 Internal Server Error</code>，表示<strong>服务器端发生了错误</strong>，这样的情况很明显是<strong>不友好的</strong>。</p>
<p>因为后端程序中<strong>主动抛出的异常都属于我们可预见的异常</strong>，这时候从规范的角度讲都需要对其进行捕获，然后做出相应的处理，再通过API返回。</p>
<p>所以修改路由函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmdb</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作CMDB&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    operation = request.form.get(<span class="string">&quot;operation&quot;</span>)</span><br><span class="line"></span><br><span class="line">    region = request.form.get(<span class="string">&quot;region&quot;</span>)</span><br><span class="line"></span><br><span class="line">    path = request.form.get(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">    attr = request.form.get(<span class="string">&quot;attr&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        params = HTTPParams(CMDB_HANDLER.operations)</span><br><span class="line"></span><br><span class="line">        op, args = params.parse(operation=operation, path=path, attr=attr, region=region)</span><br><span class="line"></span><br><span class="line">        ret = CMDB_HANDLER.execute(op, [*args])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(e)</span><br></pre></td></tr></table></figure>

<p>现在将<code>attr</code>传入一个非法的json格式字符串，就会返回如下提示。</p>
<p><img src="https://s2.loli.net/2023/04/08/HDXfrISAiRCowTt.png" alt="img"></p>
<h3 id="接口返回处理"><a href="#接口返回处理" class="headerlink" title="接口返回处理"></a><strong>接口返回处理</strong></h3><p><strong>细心的朋友可能已经发现，不管是正常请求还是返回异常信息的请求，经过我们修改后Response的提示都是200 OK。</strong></p>
<p><img src="https://s2.loli.net/2023/04/08/TdpvEl6rytQf7Dx.png" alt="img"></p>
<blockquote>
<p>Tips</p>
</blockquote>
<blockquote>
<p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
</blockquote>
<blockquote>
<p>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.</p>
</blockquote>
<blockquote>
<p>HTTP&#x2F;1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p>
</blockquote>
<blockquote>
<p>1XX 提示信息 - 表示请求已被成功接收，继续处理</p>
</blockquote>
<blockquote>
<p>2XX 成功 - 表示请求已被成功接收，理解，接受</p>
</blockquote>
<blockquote>
<p>3XX 重定向 - 要完成请求必须进行更进一步的处理</p>
</blockquote>
<blockquote>
<p>4XX 客户端错误 - 请求有语法错误或请求无法实现</p>
</blockquote>
<blockquote>
<p>5XX 服务器端错误 - 服务器未能实现合法的请求</p>
</blockquote>
<p>通俗的来说，状态码其实就是表示此次<strong>HTTP请求的状态结果</strong>，很明显通过API对CMDB进行操作，不管后端程序操作成功，或者操作失败，都属于此次HTTP请求成功，所以这里是<code>200 OK</code>合情合理。</p>
<p>那么既然都是<code>200 OK</code>，又<strong>如何来区分到底是不是对CMDB操作成功了呢</strong>，这时候就可以在返回的响应体中做文章。</p>
<p><strong>目前的通用规范是在响应体中自定义状态码，接口返回数据，和提示信息来实现</strong>，格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;status_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>所以提供接口时，需要将后端程序可以预知的错误情况进行处理，然后返回相应的提示信息。</p>
<p>而只有当后端程序发生<strong>不可预知的异常时</strong>，这个异常才会被Flask捕获到，<strong>并返回500服务器异常。</strong></p>
<p>再次修改代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmdb</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;操作CMDB&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    operation = request.form.get(<span class="string">&quot;operation&quot;</span>)</span><br><span class="line"></span><br><span class="line">    region = request.form.get(<span class="string">&quot;region&quot;</span>)</span><br><span class="line"></span><br><span class="line">    path = request.form.get(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line">    attr = request.form.get(<span class="string">&quot;attr&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        params = HTTPParams(CMDB_HANDLER.operations)</span><br><span class="line"></span><br><span class="line">        op, args = params.parse(operation=operation, path=path, attr=attr, region=region)</span><br><span class="line"></span><br><span class="line">        ret = CMDB_HANDLER.execute(op, [*args])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: ret, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;operate cmdb success&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;Fail&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="built_in">str</span>(e)&#125;</span><br></pre></td></tr></table></figure>

<p>这时候再次发起一个请求，传入非法格式的json字符串，接口返回如下：</p>
<p>传入合法的参数时，接口返回如下：</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这一章节主要讲解了三个重要的概念：</p>
<h3 id="精简路由："><a href="#精简路由：" class="headerlink" title="精简路由："></a><strong>精简路由：</strong></h3><p>编程规范中有一个原则是<strong>单一功能原则</strong>，就是一个函数方法只实现一个功能，那我们这里的路由函数却同时处理多个CMDB操作，是不是不太合理？显然不是，路由的定义在Web框架中是一个比较重要的部分，目前主流有两种方式，<strong>一种是分散式的，一种是集中式的，各有各的优势</strong>，我们这里对CMDB的操作就是使用了集中式的方式，主要是因为CMDB的操作属于核心方法，需要对其做统一的管理。</p>
<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h3><p>异常处理不管是在普通程序或者Web应用中都十分关键，<strong>一个好的异常处理能让程序说话</strong>。而在Web应用中，由于后端处理对接口调用方完全不可见，所以清晰的异常提示就显得尤为重要。所以我们要在保证后端应用不引发错误而崩溃的同时，尽量捕获到异常，并对其进行处理。</p>
<h3 id="接口返回"><a href="#接口返回" class="headerlink" title="接口返回"></a><strong>接口返回</strong></h3><p>接口的返回通常应该遵守一定的规范，但本质上只要能够清晰的表达接口提供的信息和接口的请求状态即可。</p>
<h2 id="篇后语"><a href="#篇后语" class="headerlink" title="篇后语"></a><strong>篇后语</strong></h2><p>这一章节可能并没有像大家所预料的新增一些Flask更高级的用法，这里我的看法是：</p>
<p>写代码并没有高级和低级之分，并不是用了某个工具多么高级的特性，就会怎么怎么样，而是要<strong>真正掌握某个工具的精髓，用最简单的方法实现眼下最适合的场景</strong>；</p>
<p>除此之外就是高级的用法是在项目达到一定的规模之后才迫切需要的，并不是说实现一个简单的功能，一上来就先搭一个很复杂的代码架构，把各种Flask的特性都用上，通俗点儿说，这就是脱裤子放x。</p>
<p>其实我并没有很快的把Flask的特性一一详解，有一个<strong>最重要的原因是</strong>，在这个专题<strong>真正要学的是Web框架</strong>，而Flask恰好是Web框架中符合预期的一种，所以主次关系高下立见，如果我不给大家讲解清楚Web框架中真正需要注意的地方，而是单一的教大家Flask的高级功能，那完全是<strong>舍本逐末</strong>，并且也不符合我公众号的整体风格。</p>
<p>我虽然不推崇所有的传统运维工程师转型自动化运维时，过多的将重心放在编程基础或者细节的追求上，但也不希望大家为了快速的上手，而舍弃掉最根本的东西，那就是<strong>发展空间</strong>。</p>
<p>所以我希望我的公众号不仅能够给大家提供适合当下场景的最小的上手范围，并且也能够让大家了解到更多精髓的东西，那就是<strong>编程思想和产品思维，最终达到一个低下限和高上限的最佳平衡。</strong></p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>1.13 自动化运维新手村-Flask-认证</title>
    <url>/posts/9228f5b3.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>在Flask专题的上一章节中，主要对Web应用的路由，异常处理和接口返回做了进一步的讲解，虽然代码更健壮，但离在生产环境中使用还差了最关键的一步，那就是<strong>认证</strong>。</p>
<p><strong>认证在任何存在交互的场景中都是十分重要的环节。</strong></p>
<span id="more"></span>

<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a><strong>认证</strong></h2><p>大家需要先有一个概念，那就是<strong>认证其实是两个操作</strong>：</p>
<ol>
<li><strong>身份认证</strong></li>
<li><strong>权限控制</strong></li>
</ol>
<p>通俗的说就是：</p>
<ol>
<li>先验证用户是否合法，在Web应用中用户不合法的体现是<code>401(Unauthorized)</code></li>
<li>再去判断用户是否具有所进行操作的权限，在Web应用中没有权限的提示是<code>403（Forbidden）</code>。</li>
</ol>
<h2 id="Flask应用"><a href="#Flask应用" class="headerlink" title="Flask应用"></a><strong>Flask应用</strong></h2><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a><strong>身份认证</strong></h3><h4 id="AK-x2F-SK"><a href="#AK-x2F-SK" class="headerlink" title="AK&#x2F;SK"></a><strong>AK&#x2F;SK</strong></h4><p>对于身份认证最简单的方式，就是给调用方一个固定的<code>access_key</code>和<code>secret_key</code>，通常也叫做AK&#x2F;SK，这在<strong>系统被第三方调用的场景</strong>中是十分常见的。</p>
<p>代码实现也很简单，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    ak = request.headers.get(<span class="string">&quot;access_key&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sk = request.headers.get(<span class="string">&quot;secret_key&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ak != <span class="string">&quot;admin&quot;</span> <span class="keyword">or</span> sk != <span class="string">&quot;admin_secret&quot;</span>:</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;认证失败&quot;</span>, <span class="number">401</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 具体的业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，假设调用方将AK&#x2F;SK放在了请求的Headers中，并且我们的后端应用只允许<code>admin</code>这一个用户调用，如果AK&#x2F;SK不符，那就返回认证失败，如果成功则可以执行具体的业务逻辑。</p>
<p>相信有的朋友应该已经有了一个想法，那就是<strong>将认证的逻辑代码写在路由函数中，那岂不是每个路由函数都得写重复的认证代码？</strong></p>
<p>每个路由函数编写重复的认证逻辑这显然是不合理的，那如何进行优化呢？</p>
<p>可能有的朋友又会觉得，那把认证逻辑抽象成一个单独的函数，每次调用一下不就行了，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permission</span>():</span><br><span class="line"></span><br><span class="line">    ak = request.headers.get(<span class="string">&quot;access_key&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sk = request.headers.get(<span class="string">&quot;secret_key&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ak == <span class="string">&quot;admin&quot;</span> <span class="keyword">and</span> sk == <span class="string">&quot;admin_secret&quot;</span>:</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> permission():</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;认证失败&quot;</span>, <span class="number">401</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 具体的业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>上述代码虽然表面上看起来精简很多，但仍然没有改变将认证逻辑与业务逻辑耦合在一起的事实。</strong></p>
<p>这里大家可以转变一下思路，如果一个路由函数就代表一个业务逻辑，如果需要在执行业务逻辑前做认证，那是不是就相当于要在调用路由函数前做认证？</p>
<p>这样问题的本质就变成了，<strong>在调用一个函数前，做一系列的操作，如果合法就调用该函数，如果不合法则不去调用</strong>。听起来好像就完全是<strong>装饰器</strong>的功能（如果还不了解装饰器，强烈建议先去阅读<a href="http://mp.weixin.qq.com/s?__biz=MzU4NzQ3NzEwMQ==&mid=2247484825&idx=1&sn=04f41e1b529a7df0df12bc3942e4324f&chksm=fdea3c9bca9db58d6d985df01e32b454b9cbd9dbce477e3c33343304dfb11b1d28e4bba44d77&scene=21#wechat_redirect">【自动化运维番外篇】- Python装饰器</a>）。代码修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permission</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"></span><br><span class="line">        ak = request.headers.get(<span class="string">&quot;access_key&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        sk = request.headers.get(<span class="string">&quot;secret_key&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ak == <span class="string">&quot;admin&quot;</span> <span class="keyword">and</span> sk == <span class="string">&quot;admin_secret&quot;</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;认证失败&quot;</span>, <span class="number">401</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@permission</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 具体的业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a><strong>注册</strong></h4><p>现在已经可以对固定的AK&#x2F;SK进行验证了，那下一步就考虑是否可以<strong>让用户通过注册来实现自助获取AK&#x2F;SK，其实相当于就是注册的功能</strong>，下面通过用户名密码的方式来实现注册的功能。</p>
<p>但目前后端应用还没有引入数据库，所以可以暂且通过JSON文件的方式来记录用户信息，在用户调用注册接口时，记录其传递的username&#x2F;password 到JSON文件中，下次就可以通过检索文件，判断该用户是否合法。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">ACCOUNTS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;accounts.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permission</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"></span><br><span class="line">        username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">        password = request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">            accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">        usernames = [account[<span class="string">&quot;username&quot;</span>] <span class="keyword">for</span> account <span class="keyword">in</span> accounts]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">not</span> <span class="keyword">in</span> usernames: <span class="comment"># 判断是否用户已存在</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NotFound&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is not exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> account[<span class="string">&quot;username&quot;</span>] == username:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> md5(password.encode()).hexdigest() != account[<span class="string">&quot;password&quot;</span>]: <span class="comment"># 判断用户名和密码是否一致</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;Unauthorized&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;password is not correct&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/register&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;注册用户信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">    password = request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> <span class="keyword">not</span> password: <span class="comment"># 判断用户输入的参数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;InvalidParams&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;must have username and password&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ACCOUNTS_FILE): <span class="comment"># 判断是否存在指定文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NotFound&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;not found accounts file&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> account[<span class="string">&quot;username&quot;</span>] == username: <span class="comment"># 判断是否用户已存在</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;Duplicated&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is already exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    accounts.append(&#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: md5(password.encode()).hexdigest()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(accounts, f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: username, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;register username successfully&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@permission</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 具体的业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>上述代码中指定了一个存放用户信息的文件<code>accounts.json</code>，需要先将其内容初始化，如果不对文件做初始化，那么在进行<code>json.load()</code>时就会抛异常，<strong>提示文件内容不是合法的json</strong>，初始化如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// accounts.json 文件</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>先通过<code>os.path.abspath(__file__)</code>获取到当前启动文件所在的绝对路径，再通过<code>os.path.dirname(os.path.abspath(__file__))</code>获取到该绝对路径的目录，最后通过<code>os.path.join()</code>将目录与<code>account.json</code>文件名组合在一起，就得到了该文件的绝对路径。</p>
<p>这里我们的用户信息通过数组的方式进行存储，大概模型如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>注册功能乍一想比较简单，但实际中需要进行的异常判断仍然不少</strong>，在注册用户的路由函数中就对多种可预见的异常进行了提前处理，并返回错误信息。并且在保存密码阶段，做了特殊的处理，因为<strong>原则上即使是应用方也无权知道用户的真实密码</strong>，所以需要在保存用户信息时，对密码做哈希处理，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">accounts.append(&#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: md5(password.encode()).hexdigest()&#125;)</span><br></pre></td></tr></table></figure>

<p>并且在验证时同样使用密码的哈希去进行比较，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> md5(password.encode()).hexdigest() != account[<span class="string">&quot;password&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>最终通过postman调用接口如下： </p>
<p><img src="https://s2.loli.net/2023/04/08/jhTFySfXrZ5WQK9.png" alt="img"></p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a><strong>登录</strong></h4><p>现在用户已经可以通过注册的方式，在后端应用保存自己的用户名密码，这样每次在请求中携带用户名密码信息就可以通过认证了。</p>
<p>但如果可以实现用户登录的话，<strong>用户就可以只登录一次，在登录的有效时间内，都可以进行正常的请求访问，且无需每次请求都传递用户名和密码。</strong></p>
<p>所以代码需要做如下修改：</p>
<ol>
<li>注册逻辑保持不变。</li>
<li>新增全局常量<code>LOGIN_TIMEOUT</code>，设置一个固定的登录有效期。</li>
<li>新增全局变量<code>SESSION_IDS</code>用来记录已登录用户的信息，以及用户的登录时间。</li>
<li>新增登录的路由函数，验证用户是否已注册，已注册的用户且用户名密码正确则登录成功，记录该用户的登录信息，并返回生成的<code>session_id</code>。</li>
</ol>
<p>**5.**修改装饰器函数，获取请求头中的<code>session_id</code>字段，判断用户是否已登录且是否在有效期内，如果超过有效期则将该用户的登录信息从<code>SESSION_IDS</code>中移除，每次发起请求且认证通过后都更新登录时间戳，以延长登录有效时间</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ACCOUNTS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;accounts.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SESSION_IDS = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOGIN_TIMEOUT = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permission</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"></span><br><span class="line">        session_id = request.headers.get(<span class="string">&quot;session_id&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">global</span> SESSION_IDS</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> session_id <span class="keyword">not</span> <span class="keyword">in</span> SESSION_IDS: <span class="comment"># 是否存在会话信心</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;FORBIDDEN&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username not login&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> time.time() - SESSION_IDS[session_id][<span class="string">&quot;timestamp&quot;</span>] &gt; LOGIN_TIMEOUT: <span class="comment"># 是否会话仍有效</span></span><br><span class="line"></span><br><span class="line">            SESSION_IDS.pop(session_id) <span class="comment"># 如果失效则移除会话信息</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;FORBIDDEN&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username login timeout&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        SESSION_IDS[session_id][<span class="string">&quot;timestamp&quot;</span>] = time.time() <span class="comment"># 更新会话时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/register&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;注册用户信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">    password = request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> <span class="keyword">not</span> password: <span class="comment"># 判断用户输入的参数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;InvalidParams&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;must have username and password&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ACCOUNTS_FILE): <span class="comment"># 判断是否存在指定文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NotFound&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;not found accounts file&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> account[<span class="string">&quot;username&quot;</span>] == username: <span class="comment"># 判断是否用户已存在</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;Duplicated&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is already exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    accounts.append(&#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: md5(password.encode()).hexdigest()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(accounts, f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: username, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;register username successfully&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/login&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用户登录&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">    password = request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ACCOUNTS_FILE): <span class="comment"># 是否存在用户信息文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NotFound&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;not found accounts file&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">    usernames = [account[<span class="string">&quot;username&quot;</span>] <span class="keyword">for</span> account <span class="keyword">in</span> accounts]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> username <span class="keyword">not</span> <span class="keyword">in</span> usernames: <span class="comment"># 是否用户已注册</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NotFound&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is not exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    current_user = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> account[<span class="string">&quot;username&quot;</span>] == username:</span><br><span class="line"></span><br><span class="line">            current_user = account</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> md5(password.encode()).hexdigest() != account[<span class="string">&quot;password&quot;</span>]: <span class="comment"># 是否用户名密码正确</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;Unauthorized&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;password is not correct&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            session_id = md5((password + <span class="built_in">str</span>(time.time())).encode()).hexdigest() <span class="comment"># 生成会话ID</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">global</span> SESSION_IDS</span><br><span class="line"></span><br><span class="line">            SESSION_IDS[session_id] = &#123;<span class="string">&quot;user_info&quot;</span>: current_user, <span class="string">&quot;timestamp&quot;</span>: time.time()&#125; <span class="comment"># 记录会话信息</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: &#123;<span class="string">&quot;session_id&quot;</span>: session_id&#125;, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;login successfully&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@permission</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.run(host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>通过Postman发起登录请求如下：</p>
<p><img src="https://s2.loli.net/2023/04/08/i2j7Vr8gF4WQUam.png" alt="img"></p>
<p><img src="https://s2.loli.net/2023/04/08/EneQLoaBkT2zYfg.png" alt="img"></p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ACCOUNTS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;accounts.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SESSION_IDS = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOGIN_TIMEOUT = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permission</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"></span><br><span class="line">        session_id = request.headers.get(<span class="string">&quot;session_id&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">global</span> SESSION_IDS</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> session_id <span class="keyword">not</span> <span class="keyword">in</span> SESSION_IDS: <span class="comment"># 是否存在会话信心</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;FORBIDDEN&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username not login&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> time.time() - SESSION_IDS[session_id][<span class="string">&quot;timestamp&quot;</span>] &gt; LOGIN_TIMEOUT: <span class="comment"># 是否会话仍有效</span></span><br><span class="line"></span><br><span class="line">            SESSION_IDS.pop(session_id) <span class="comment"># 如果失效则移除会话信息</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;FORBIDDEN&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username login timeout&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        SESSION_IDS[session_id][<span class="string">&quot;timestamp&quot;</span>] = time.time() <span class="comment"># 更新会话时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/register&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;注册用户信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">    password = request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> <span class="keyword">not</span> password: <span class="comment"># 判断用户输入的参数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;InvalidParams&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;must have username and password&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ACCOUNTS_FILE): <span class="comment"># 判断是否存在指定文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NotFound&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;not found accounts file&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> account[<span class="string">&quot;username&quot;</span>] == username: <span class="comment"># 判断是否用户已存在</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;Duplicated&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is already exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    accounts.append(&#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: md5(password.encode()).hexdigest()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(accounts, f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: username, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;register username successfully&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/login&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用户登录&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">    password = request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ACCOUNTS_FILE): <span class="comment"># 是否存在用户信息文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NotFound&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;not found accounts file&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">    usernames = [account[<span class="string">&quot;username&quot;</span>] <span class="keyword">for</span> account <span class="keyword">in</span> accounts]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> username <span class="keyword">not</span> <span class="keyword">in</span> usernames: <span class="comment"># 是否用户已注册</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;NotFound&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is not exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    current_user = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> account[<span class="string">&quot;username&quot;</span>] == username:</span><br><span class="line"></span><br><span class="line">            current_user = account</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> md5(password.encode()).hexdigest() != account[<span class="string">&quot;password&quot;</span>]: <span class="comment"># 是否用户名密码正确</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;Unauthorized&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;password is not correct&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            session_id = md5((password + <span class="built_in">str</span>(time.time())).encode()).hexdigest() <span class="comment"># 生成会话ID</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">global</span> SESSION_IDS</span><br><span class="line"></span><br><span class="line">            SESSION_IDS[session_id] = &#123;<span class="string">&quot;user_info&quot;</span>: current_user, <span class="string">&quot;timestamp&quot;</span>: time.time()&#125; <span class="comment"># 记录会话信息</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: &#123;<span class="string">&quot;session_id&quot;</span>: session_id&#125;, <span class="string">&quot;status_code&quot;</span>: <span class="string">&quot;OK&quot;</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;login successfully&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@permission</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.run(host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这一章节主要讲解了关于用户身份认证的原理和具体实现，关于权限校验下一章节再详细介绍。</p>
<p>其实时Flask中也有第三方插件可以实现登录，叫做<code>flask-login</code>，感兴趣的同学可以了解一下，但我们的<strong>目的主要是要了解身份认证的具体逻辑，而不是当一个“调包侠”。</strong></p>
<p>除此之外，有一点需要大家仔细思考的是，编程是面对的计算机，所以对于逻辑的严谨和异常的处理，都需要十分仔细，平时在实现某个功能时并不是说通过正向思维，把这个功能的具体逻辑用代码翻译过来就可以了；<strong>而是要对这个功能的流程中所牵扯到的各种边界情况做充足的考虑。</strong></p>
<p>最后留一个思考题，如果大家能仔细思考各种边界条件的话，会发现最终的代码存在一个并发问题：</p>
<p>当很多人同时发起请求进行注册的时候，是否会导致文件出现写冲突，如果会，那应用如何解决呢？</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>1.14 自动化运维新手村-Flask-权限校验</title>
    <url>/posts/529a25d.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>上一章节，我们主要对Web应用的用户认证做了详细的讲解，包括使用Flask实现用户注册，登录，并通过Session机制实现用户保持登录。那么在了解了用户认证之后，这一章节我们就着重介绍一下权限校验的原理以及实现方式。</p>
<p><strong>为什么需要鉴权</strong></p>
<p>用户在通过认证之后，已经可以正常访问我们的后端应用，但当后端应用越来越完善，功能越来越丰富，并且牵扯的资源以及用户的范围都足够广的时候，用户的权限校验就显得尤为重要。例如：</p>
<ol>
<li>是否所有用户都可以通过接口获取CMDB的数据信息；</li>
<li>是否所有的用户都可以调用接口对设备进行操作；</li>
<li>是否拥有获取CMDB信息权限的用户也拥有对设备进行操作的权限；</li>
<li>是否拥有对设备操作权限的用户，就可以对全部的设备进行操作；</li>
</ol>
<p>诸如上述的权限问题还有很多，下面就一起来看看如何在Flask应用中进行鉴权。</p>
<span id="more"></span>

<h2 id="Flask实现"><a href="#Flask实现" class="headerlink" title="Flask实现"></a>Flask实现</h2><p>对用户鉴权相信大家都可以理解，其实就是判断用户是否有权限访问某个API，在实现上也相对比较简单。</p>
<p>上一章节中，我们通过装饰器实现了登录认证，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permission</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth():</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Fail</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@permission</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br></pre></td></tr></table></figure>

<p>登录认证的具体实现其实就是将该装饰器加在需要认证的路由函数上，这样就可以在调用该路由函数前进行一系列的认证过程。</p>
<h3 id="基于用户鉴权"><a href="#基于用户鉴权" class="headerlink" title="基于用户鉴权"></a>基于用户鉴权</h3><p>如果想要在登录认证的前提下再进行用户鉴权，则只需要修改<code>permission</code>装饰器，使其可以对用户进行判断，然后决定是否允许该用户访问。但是我们需要先明确具体的路由函数允许哪个用户访问，并且将这个限制传入装饰器中，这时候就需要用到<a href="http://mp.weixin.qq.com/s?__biz=MzU4NzQ3NzEwMQ==&mid=2247484839&idx=1&sn=8798cad200bc77e8e84769c8fecb5a05&chksm=fdea3ca5ca9db5b32d8803660c5d05a74082d76f3ba465f07cbdf28600dcd0cde1133e0cd5f3&scene=21#wechat_redirect">【自动化运维番外篇】Python装饰器-进阶</a>中的带参数的装饰器，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permission</span>(<span class="params">permit_users</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_acquired</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> auth() <span class="keyword">or</span> current_user <span class="keyword">not</span> <span class="keyword">in</span> permit_users:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Fail</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> login_acquired</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@permission(<span class="params">[<span class="string">&quot;ethan&quot;</span>, <span class="string">&quot;john&quot;</span>, <span class="string">&quot;jack&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br></pre></td></tr></table></figure>

<p>经过改进的装饰器加在需要鉴权的路由函数上，并且传入该路由函数允许访问的用户列表，这样在登录认证时，通过<code>session_id</code>获取到当前用户，判断该用户是否在允许访问的用户列表中即可。</p>
<p>其实不难看出，通过用户去区分权限显然是不太现实的，用户数量增多的时候，可能会让权限控制变得十分难以维护。</p>
<p>那么最先想到的改进方法，应该就是将不同的用户赋予不同的角色，这样在权限控制的时候，鉴权粒度就由用户变成了角色。</p>
<h3 id="基于角色鉴权"><a href="#基于角色鉴权" class="headerlink" title="基于角色鉴权"></a>基于角色鉴权</h3><p>关于通过角色鉴权目前业内已经有一套成熟的规范 —— RBAC（Role-Based Access Control, 基于角色的访问控制），就是用户通过角色与权限进行关联。</p>
<p>RBCA本质上是对用户进行分组管理，赋予角色，对权限进行合理的划分，最终实现一个用户拥有若干角色，每一个角色拥有若干权限。并且RBCA具有十分完善的权限模型设计，对于大型系统的权限管理是非常重要的，但这一章节目的就是化繁为简，学会其权限管理的基本原理和底层实现。</p>
<h4 id="定义角色"><a href="#定义角色" class="headerlink" title="定义角色"></a>定义角色</h4><p>这里定义角色时引入了一个新的概念，叫做枚举类型，枚举类型可以看作是一种标签或是一系列常量的集合，通常用于表示某些特定的有限集合，例如星期、月份、状态等，那么我们这里的角色显然也适合用枚举类型来定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line"></span><br><span class="line">    ADMIN = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line">    CMDB = <span class="string">&quot;cmdb&quot;</span></span><br><span class="line"></span><br><span class="line">    GUEST = <span class="string">&quot;guest&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于到目前为止，我们的后端应用还没有引入数据库的概念，所以权限信息可以和用户信息一起暂时保存在JSON文件中，这里用户的权限信息可以通过在用户信息中新增一个<code>role</code>字段来进行标识。模型如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="鉴权逻辑"><a href="#鉴权逻辑" class="headerlink" title="鉴权逻辑"></a>鉴权逻辑</h4><p>上文中已经提到需要将装饰器修改为可传参的装饰器，修改后整体逻辑如下：</p>
<p>1.允许传入参数<code>roles</code>，可以是多个角色或单个角色，参数类型为列表，如果不传默认为None，表示不限制角色</p>
<p>2.判断用户是否登录的逻辑保持不变</p>
<p>3.根据<code>session_id</code>获取当前已登陆用户</p>
<p>4.判断该用户的角色是否包含在传入的参数<code>roles</code>中</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> http <span class="keyword">import</span> HTTPStatus <span class="comment"># 引入了http包中的状态码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permission</span>(<span class="params">roles=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_required</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"></span><br><span class="line">            session_id = request.headers.get(<span class="string">&quot;session_id&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">global</span> SESSION_IDS</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> session_id <span class="keyword">not</span> <span class="keyword">in</span> SESSION_IDS: <span class="comment"># 是否存在会话信息</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.UNAUTHORIZED, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username not login&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> SESSION_IDS[session_id][<span class="string">&quot;timestamp&quot;</span>] - time.time() &gt; LOGIN_TIMEOUT: <span class="comment"># 是否会话仍有效</span></span><br><span class="line"></span><br><span class="line">                SESSION_IDS.pop(session_id) <span class="comment"># 如果失效则移除会话信息</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.UNAUTHORIZED, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username login timeout&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            SESSION_IDS[session_id][<span class="string">&quot;timestamp&quot;</span>] = time.time() <span class="comment"># 更新会话时间</span></span><br><span class="line"></span><br><span class="line">            current_user = SESSION_IDS[session_id]</span><br><span class="line"></span><br><span class="line">            role_values = [role.value <span class="keyword">for</span> role <span class="keyword">in</span> roles]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> roles <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> current_user[<span class="string">&quot;user_info&quot;</span>].get(<span class="string">&quot;role&quot;</span>) <span class="keyword">not</span> <span class="keyword">in</span> role_values:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.FORBIDDEN, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;user has no permission&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> login_required</span><br></pre></td></tr></table></figure>

<h4 id="为用户授权"><a href="#为用户授权" class="headerlink" title="为用户授权"></a>为用户授权</h4><p>现在新增一个为用户授权的路由函数，但这个函数同样应该设置权限，只允许管理员角色调用它，所以一开始需要在用户信息中初始化一个管理员账户，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yuefeiyu&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;af058879880f293b3b9b4a7072e5d0bf&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>为用户授权的大致逻辑如下：</p>
<p>1.通过POST请求传入<code>username</code>和<code>role</code>表单参数</p>
<p>2.判断参数是否合法，<code>role</code>是否属于枚举类型中已定义的角色</p>
<p>3.获取已注册的用户信息</p>
<p>4.判断被授权用户是否已注册</p>
<p>5.修改该用户的角色信息并保存</p>
<p>6.如果授权用户已登陆则修改session中该用户的角色信息</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/permission_manage&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@permission(<span class="params">roles=[Role.ADMIN]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permission_manage</span>():</span><br><span class="line"></span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">    role = request.form.get(<span class="string">&quot;role&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> <span class="keyword">not</span> role:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.BAD_REQUEST&#125;</span><br><span class="line"></span><br><span class="line">    roles = [role.value <span class="keyword">for</span> role <span class="keyword">in</span> Role]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> role <span class="keyword">not</span> <span class="keyword">in</span> roles: <span class="comment"># 判断输入的角色名称是否合法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.BAD_REQUEST&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ACCOUNTS_FILE): <span class="comment"># 是否存在用户信息文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.NOT_FOUND, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;not found accounts file&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">    permit_user = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> accounts: <span class="comment"># 查找被授权用户</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> account.get(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;&quot;</span>) == username:</span><br><span class="line"></span><br><span class="line">            permit_user = account</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> permit_user <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 是否用户已注册</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.NOT_FOUND, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is not exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    permit_user[<span class="string">&quot;role&quot;</span>] = role</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> SESSION_IDS</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, session_info <span class="keyword">in</span> SESSION_IDS.items(): <span class="comment"># 如果授权用户已登陆则修改session中该用户的角色信息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> session_info[<span class="string">&quot;user_info&quot;</span>].get(<span class="string">&quot;username&quot;</span>) == username:</span><br><span class="line"></span><br><span class="line">            session_info[<span class="string">&quot;user_info&quot;</span>][<span class="string">&quot;role&quot;</span>] = role</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(accounts, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;successfully&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口演示如下："><a href="#接口演示如下：" class="headerlink" title="接口演示如下："></a>接口演示如下：</h3><ol>
<li>登录管理员用户</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/08/4kda9GlOrqej7Hz.png" alt="img"></p>
<ol>
<li>为用户jack授予guest权限</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/08/7U2k9qY51noaPTF.png" alt="img"></p>
<ol>
<li>jack登录后携带jack的session_id访问cmdb接口</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/08/x8gsFcZHokRyAef.png" alt="img"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> http <span class="keyword">import</span> HTTPStatus</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ACCOUNTS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&quot;accounts.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SESSION_IDS = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOGIN_TIMEOUT = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line"></span><br><span class="line">    ADMIN = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line">    CMDB = <span class="string">&quot;cmdb&quot;</span></span><br><span class="line"></span><br><span class="line">    GUEST = <span class="string">&quot;guest&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permission</span>(<span class="params">roles=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_required</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line"></span><br><span class="line">            session_id = request.headers.get(<span class="string">&quot;session_id&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">global</span> SESSION_IDS</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> session_id <span class="keyword">not</span> <span class="keyword">in</span> SESSION_IDS: <span class="comment"># 是否存在会话信心</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.UNAUTHORIZED, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username not login&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> SESSION_IDS[session_id][<span class="string">&quot;timestamp&quot;</span>] - time.time() &gt; LOGIN_TIMEOUT: <span class="comment"># 是否会话仍有效</span></span><br><span class="line"></span><br><span class="line">                SESSION_IDS.pop(session_id) <span class="comment"># 如果失效则移除会话信息</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.UNAUTHORIZED, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username login timeout&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            SESSION_IDS[session_id][<span class="string">&quot;timestamp&quot;</span>] = time.time() <span class="comment"># 更新会话时间</span></span><br><span class="line"></span><br><span class="line">            current_user = SESSION_IDS[session_id]</span><br><span class="line"></span><br><span class="line">            role_values = [role.value <span class="keyword">for</span> role <span class="keyword">in</span> roles]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> roles <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> current_user[<span class="string">&quot;user_info&quot;</span>].get(<span class="string">&quot;role&quot;</span>) <span class="keyword">not</span> <span class="keyword">in</span> role_values:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.FORBIDDEN, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;user has no permission&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> login_required</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/register&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;注册用户信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">    password = request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> <span class="keyword">not</span> password: <span class="comment"># 判断用户输入的参数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.BAD_REQUEST, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;must have username and password&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ACCOUNTS_FILE): <span class="comment"># 判断是否存在指定文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.NOT_FOUND, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;not found accounts file&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> account[<span class="string">&quot;username&quot;</span>] == username: <span class="comment"># 判断是否用户已存在</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.CONFLICT, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is already exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    accounts.append(&#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: md5(password.encode()).hexdigest()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(accounts, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: username, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;register username successfully&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/login&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用户登录&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">    password = request.form.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> <span class="keyword">not</span> password:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.BAD_REQUEST, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;invalid parameters&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ACCOUNTS_FILE): <span class="comment"># 是否存在用户信息文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.NOT_FOUND, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;not found accounts file&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">    current_user = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> account[<span class="string">&quot;username&quot;</span>] == username:</span><br><span class="line"></span><br><span class="line">            current_user = account</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> current_user <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 是否用户已注册</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.NOT_FOUND, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is not exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> md5(password.encode()).hexdigest() != current_user[<span class="string">&quot;password&quot;</span>]: <span class="comment"># 是否用户名密码正确</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.UNAUTHORIZED, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;password is not correct&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> SESSION_IDS</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> session_id, session_info <span class="keyword">in</span> SESSION_IDS.items(): <span class="comment"># 判断用户是否已经登陆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> session_info[<span class="string">&quot;user_info&quot;</span>].get(<span class="string">&quot;username&quot;</span>) == username: <span class="comment"># 如果已经登录则更新时间戳并返回已登陆的sessionID</span></span><br><span class="line"></span><br><span class="line">            session_info[<span class="string">&quot;timestamp&quot;</span>] = time.time()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: &#123;<span class="string">&quot;session_id&quot;</span>: session_id&#125;, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;login successfully&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    session_id = md5((password + <span class="built_in">str</span>(time.time())).encode()).hexdigest() <span class="comment"># 生成会话ID</span></span><br><span class="line"></span><br><span class="line">    SESSION_IDS[session_id] = &#123;<span class="string">&quot;user_info&quot;</span>: current_user, <span class="string">&quot;timestamp&quot;</span>: time.time()&#125; <span class="comment"># 记录会话信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: &#123;<span class="string">&quot;session_id&quot;</span>: session_id&#125;, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;login successfully&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/permission_manage&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@permission(<span class="params">roles=[Role.ADMIN]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">permission_manage</span>():</span><br><span class="line"></span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">    role = request.form.get(<span class="string">&quot;role&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> <span class="keyword">not</span> role:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.BAD_REQUEST&#125;</span><br><span class="line"></span><br><span class="line">    roles = [role.value <span class="keyword">for</span> role <span class="keyword">in</span> Role]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> role <span class="keyword">not</span> <span class="keyword">in</span> roles: <span class="comment"># 判断输入的角色名称是否合法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.BAD_REQUEST&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(ACCOUNTS_FILE): <span class="comment"># 是否存在用户信息文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.NOT_FOUND, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;not found accounts file&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        accounts = json.load(f)</span><br><span class="line"></span><br><span class="line">    permit_user = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> accounts: <span class="comment"># 查找被授权用户</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> account.get(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;&quot;</span>) == username:</span><br><span class="line"></span><br><span class="line">            permit_user = account</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> permit_user <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 是否用户已注册</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.NOT_FOUND, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;username is not exists&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    permit_user[<span class="string">&quot;role&quot;</span>] = role</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;accounts.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">        json.dump(accounts, f, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> SESSION_IDS</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, session_info <span class="keyword">in</span> SESSION_IDS.items(): <span class="comment"># 如果授权用户已登陆则修改session中该用户的角色信息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> session_info[<span class="string">&quot;user_info&quot;</span>].get(<span class="string">&quot;username&quot;</span>) == username:</span><br><span class="line"></span><br><span class="line">            session_info[<span class="string">&quot;user_info&quot;</span>][<span class="string">&quot;role&quot;</span>] = role</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;data&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;status_code&quot;</span>: HTTPStatus.OK, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;successfully&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmdb&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@permission(<span class="params">roles=[Role.CMDB]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmdb</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.run(host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">5000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当用户范围足够广的时候，角色的定义就会变得复杂，可能会涉及到角色的继承，或者先将多个用户分到同一个用户组，然后再给这个用户组赋予一个角色，等等。除此之外除了对接口进行鉴权，有时候还需要对访问的资源进行鉴权，比如访问的数据，或者操作的设备等。</p>
<p>鉴权如果复杂可以做得很复杂，想要简单同样也可以很简单，我们这一章节其实就是简化鉴权逻辑，让大家能够了解到鉴权的底层原理和实现方式，希望大家可以仔细阅读体会。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>1.19 自动化运维新手村-Flask-部署上线</title>
    <url>/posts/44bbbe77.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>在自动化运维新手村中，我们已经依次讲解了Python的基础知识，函数与面向对象设计，使用了Flask框架作为Web应用的后端，与此同时还学习了数据库的相关知识，最终完成了一个以Flask为后端的资产管理服务。</p>
<p>到目前为止，如果大家可以充分理解并灵活应用所讲的知识点，就已经可以按照自己的实际需求，做出一些基本的运维工具，但如果需要对外提供运维能力，还需要最后一步，那就是将Flask后端部署上线。</p>
<span id="more"></span>

<h2 id="Flask启动"><a href="#Flask启动" class="headerlink" title="Flask启动"></a><strong>Flask启动</strong></h2><p>在讲解Flask框架的第一章节提到，启动Flask可以直接运行如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:    </span><br><span class="line"></span><br><span class="line">    app.<span class="title function_">run</span>()</span><br></pre></td></tr></table></figure>

<p>但启动之后的日志中会包含如下提示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WARNING: This <span class="keyword">is</span> a development server. Do <span class="keyword">not</span> use it <span class="keyword">in</span> a production deployment.</span><br><span class="line"></span><br><span class="line">Use a production WSGI server instead.</span><br></pre></td></tr></table></figure>

<p>翻译过来的含义就是，当前使用的是开发模式下的服务器，请不要在生产环境使用它，而是要使用一个生成环境下的WSGI服务器</p>
<p>那到底什么是开发模式服务器，什么又是生产环境的WSGI服务器呢？</p>
<h2 id="Web服务的组成"><a href="#Web服务的组成" class="headerlink" title="Web服务的组成"></a><strong>Web服务的组成</strong></h2><p>准确来说，一个Flask后端应用，并不等同于一个完整的Web服务，一个完整的Web服务如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/08/qsSmgi9VZ5CQRIY.png" alt="img"></p>
<p>需要由一个Web服务器接收浏览器发出的HTTP请求，并经由WSGI标准接口与APP进行通信，APP处理完请求之后，再将响应经由WSGI处理，最终由Web服务器发送给前端。</p>
<p>Flask应用就是APP的角色，而Server通常会由另一个组件来实现，当通过<code>app.run()</code>启动Flask应用时，其实是Flask内置了一个仅用于开发调试的低性能、简易的Server，这也是为什么不建议直接在生产环境使用<code>app.run()</code>来部署Flask应用（不建议并不是不能）。</p>
<h3 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a><strong>WSGI</strong></h3><p>那什么又是WSGI呢？</p>
<blockquote>
<p>百度百科定义如下：</p>
</blockquote>
<blockquote>
<p>Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。</p>
</blockquote>
<p>上文提到，Server需要由单独的组件来充当，那么Server在与APP交互过程中，就需要遵循一种规范，这个规范就是WSGI。</p>
<p>更为通俗地讲，充当WebServer角色的可以有很多组件；也有很多框架可以充当WebApp的角色，但只要它们双方都遵守WSGI规范，那么编程人员就可以用任意一个WebServer组件去和任意一种WebApp对接。</p>
<p>WSGI区分为两个部分：一边为“服务器”或“网关”，另一边为“应用程序”或“应用框架”。在处理一个WSGI请求时，服务器会为应用程序提供环境信息及一个回调函数（Callback Function）。当应用程序完成处理请求后，透过前述的回调函数，将结果回传给服务器。</p>
<p>所谓的<em>WSGI中间件</em>同时实现了API的两方（南北向接口），因此可以在WSGI服务器和WSGI应用之间起调解作用：从Web服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。“中间件”组件可以执行以下功能：</p>
<ol>
<li>重写环境变量后，根据目标URL，将请求消息路由到不同的应用对象。</li>
<li>允许在一个进程中同时运行多个应用程序或应用框架。</li>
<li>负载均衡和远程处理，通过在网络上转发请求和响应消息。</li>
<li>进行内容后处理。</li>
</ol>
<p>Flask作为应用程序，它适配实现WSGI规范的源代码大致如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wsgi_app</span>(<span class="params">self, environ: <span class="built_in">dict</span>, start_response: t.<span class="type">Callable</span></span>) -&gt; t.<span class="type">Any</span>:</span><br><span class="line"></span><br><span class="line">    ctx = self.request_context(environ)</span><br><span class="line"></span><br><span class="line">    error: t.<span class="type">Optional</span>[BaseException] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            ctx.push()</span><br><span class="line"></span><br><span class="line">            response = self.full_dispatch_request()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">            error = e</span><br><span class="line"></span><br><span class="line">            response = self.handle_exception(e)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">            error = sys.exc_info()[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.should_ignore_error(error):</span><br><span class="line"></span><br><span class="line">            error = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        ctx.auto_pop(error)</span><br></pre></td></tr></table></figure>

<p>这一章节暂时不对源码做深入解读，Flask源码会在后续的Flask进阶内容中进行讲解，感兴趣的读者可以先自行了解。</p>
<h3 id="服务器-x2F-网关"><a href="#服务器-x2F-网关" class="headerlink" title="服务器&#x2F;网关"></a><strong>服务器&#x2F;网关</strong></h3><p>目前能够充当Python HTTPServer角色的组件有很多，这一章节主要讲解Gunicorn，该服务器与各种Web框架兼容，实现非常简单，轻量级的资源消耗。可以直接用命令启动，不需要编写配置文件，相对其他的HTTP服务器要简单不少。</p>
<h2 id="Gunicorn-Flask部署"><a href="#Gunicorn-Flask部署" class="headerlink" title="Gunicorn + Flask部署"></a><strong>Gunicorn + Flask部署</strong></h2><p><strong>部署过程均在Linux环境下进行</strong></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip install gunicorn</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Collecting</span> gunicorn</span><br><span class="line"></span><br><span class="line">  Downloading gunicorn-<span class="number">20</span>.<span class="number">1</span>.<span class="number">0</span>-py3-<span class="literal">none</span>-any.whl (<span class="number">79</span> kB)</span><br><span class="line"></span><br><span class="line">     |████████████████████████████████| <span class="number">79</span> kB <span class="number">539</span> kB/s</span><br><span class="line"></span><br><span class="line">Requirement already satisfied: setuptools&gt;=<span class="number">3</span>.<span class="number">0</span> in ./venv/lib/python3.<span class="number">8</span>/site-packages (from gunicorn) (<span class="number">59</span>.<span class="number">7</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Installing collected packages: gunicorn</span><br><span class="line"></span><br><span class="line">Successfully installed gunicorn-<span class="number">20</span>.<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果安装较慢可以加上清华源的后缀<code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a><strong>全局配置</strong></h3><p>安装完gunicorn后无法直接通过命令行执行其二进制文件，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gunicorn -h</span></span><br><span class="line"></span><br><span class="line">-bash: gunicorn: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>因为安装完成后gunicorn可执行文件会存在于python的bin&#x2F;文件夹下，如果是使用的系统Python环境，则通常会存在于<code>/usr/local/python3/bin/gunicorn</code>，如果是使用的Python的虚拟环境，则通常会存在于虚拟环境目录<code>./venv/bin/gunicorn</code>。需要通过软链接将其链接到<code>/usr/bin</code>目录下，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/local/python/bin/gunicorn /usr/bin/gunicorn</span></span><br></pre></td></tr></table></figure>

<p>设置完成后，执行如下命令确认：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gunicorn -v</span></span><br><span class="line"></span><br><span class="line">gunicorn (version 20.1.0)</span><br></pre></td></tr></table></figure>

<h3 id="启动Flask应用"><a href="#启动Flask应用" class="headerlink" title="启动Flask应用"></a><strong>启动Flask应用</strong></h3><p>将已经完成的Flask上传到Linux环境的机器下；</p>
<p>先执行<code>python app.py</code>启动Flask应用，然后执行<code>curl 127.0.0.1:5000/get</code>确认应用程序可以正常运行；</p>
<p>执行<code>gunicorn app:app</code>，通过gunicorn启动Flask应用，默认会监听<code>127.0.0.1:8000</code>，输出如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[2022-03-27 15:53:53 +0800]</span> <span class="selector-attr">[76948]</span> <span class="selector-attr">[INFO]</span> Starting gunicorn <span class="number">20.1</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[2022-03-27 15:53:53 +0800]</span> <span class="selector-attr">[76948]</span> <span class="selector-attr">[INFO]</span> Listening at: http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8000</span> (<span class="number">76948</span>)</span><br><span class="line"></span><br><span class="line">[<span class="number">2022</span>-<span class="number">03</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">53</span> +<span class="number">0800</span>] [<span class="number">76948</span>] [INFO] Using worker: sync</span><br><span class="line"></span><br><span class="line">[<span class="number">2022</span>-<span class="number">03</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">53</span> +<span class="number">0800</span>] [<span class="number">76954</span>] [INFO] Booting worker with pid: <span class="number">76954</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2022</span>-<span class="number">03</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">55</span> +<span class="number">0800</span>] [<span class="number">76948</span>] [INFO] Handling signal: int</span><br><span class="line"></span><br><span class="line">[<span class="number">2022</span>-<span class="number">03</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">55</span> +<span class="number">0800</span>] [<span class="number">76954</span>] [INFO] Worker exiting (pid: <span class="number">76954</span>)</span><br><span class="line"></span><br><span class="line">[<span class="number">2022</span>-<span class="number">03</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">53</span>:<span class="number">55</span> +<span class="number">0800</span>] [<span class="number">76948</span>] [INFO] Shutting down: Master</span><br></pre></td></tr></table></figure>

<p>这时再次执行<code>curl 127.0.0.1:8000/get</code>确认应用可以正常访问</p>
<h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>gunicorn可以配置一些额外参数，格式如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gunicorn</span> -w 进程数量 -b 监听地址:监听端口 运行文件名称:Flask程序实例名</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gunicorn</span> -w <span class="number">4</span> -b <span class="number">0.0.0.0:8080</span> app:app -D</span><br></pre></td></tr></table></figure>

<p><code>-D</code>表示将gunicorn置于后台运行</p>
<p>执行<code>ps -ef | grep gunicorn</code>可以查看gunicorn进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps -ef | grep gunicorn</span></span><br><span class="line"></span><br><span class="line">  501 79794 1 0 3:58PM ?? 0:00.04 PycharmProjects/flaskProject2/venv/bin/gunicorn -w 4 -b 0.0.0.0:8080 openapi:app -D</span><br><span class="line"></span><br><span class="line">  501 79806 79794 0 3:58PM ?? 0:00.51 PycharmProjects/flaskProject2/venv/bin/gunicorn -w 4 -b 0.0.0.0:8080 openapi:app -D</span><br><span class="line"></span><br><span class="line">  501 79808 79794 0 3:58PM ?? 0:00.51 PycharmProjects/flaskProject2/venv/bin/gunicorn -w 4 -b 0.0.0.0:8080 openapi:app -D</span><br><span class="line"></span><br><span class="line">  501 79809 79794 0 3:58PM ?? 0:00.50 PycharmProjects/flaskProject2/venv/bin/gunicorn -w 4 -b 0.0.0.0:8080 openapi:app -D</span><br><span class="line"></span><br><span class="line">  501 79810 79794 0 3:58PM ?? 0:00.50 PycharmProjects/flaskProject2/venv/bin/gunicorn -w 4 -b 0.0.0.0:8080 openapi:app -D</span><br></pre></td></tr></table></figure>

<p>除此之外如果是在生产环境，必不可少还需要配置日志信息，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gunicorn -w 4 -b 0.0.0.0:8080 --access-logfile access.log --error-logfile error.log app:app -D</span><br></pre></td></tr></table></figure>

<p>可以通过<code>tail -f access.log</code>或者<code>tail -f error.log</code>查看记录的日志信息。</p>
<h4 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h4><p>执行<code>pip install gevent</code>安装依赖包。</p>
<p>gunicorn可以通过执行配置文件来完成启动，配置文件如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line"></span><br><span class="line">gevent.monkey.patch_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bind = <span class="string">&#x27;0.0.0.0:8080&#x27;</span>  <span class="comment"># 绑定的ip以及端口号</span></span><br><span class="line"></span><br><span class="line">chdir = <span class="string">&#x27;/home/flaskProject&#x27;</span>  <span class="comment"># gunicorn要切换到的目的工作目录</span></span><br><span class="line"></span><br><span class="line">timeout = <span class="number">60</span>  <span class="comment"># 超时</span></span><br><span class="line"></span><br><span class="line">worker_class = <span class="string">&#x27;gevent&#x27;</span>  <span class="comment"># 使用gevent模式，还可以使用sync 模式，默认的是sync模式</span></span><br><span class="line"></span><br><span class="line">workers = multiprocessing.cpu_count() * <span class="number">2</span> + <span class="number">1</span>  <span class="comment"># 启动的进程数</span></span><br><span class="line"></span><br><span class="line">loglevel = <span class="string">&quot;info&quot;</span>  <span class="comment"># 日志级别，这个日志级别指的是错误日志的级别，而访问日志的级别无法设置</span></span><br><span class="line"></span><br><span class="line">access_log_format = <span class="string">&#x27;%(t)s %(p)s %(h)s &quot;%(r)s&quot; %(s)s %(L)s %(b)s %(f)s&quot; &quot;%(a)s&quot;&#x27;</span>  <span class="comment"># 设置gunicorn访问日志格式，错误日志无法设置</span></span><br><span class="line"></span><br><span class="line">pidfile = <span class="string">&quot;gunicorn.pid&quot;</span></span><br><span class="line"></span><br><span class="line">accesslog = <span class="string">&quot;access.log&quot;</span></span><br><span class="line"></span><br><span class="line">errorlog = <span class="string">&quot;error.log&quot;</span></span><br><span class="line"></span><br><span class="line">daemon = <span class="literal">True</span>  <span class="comment"># 是否后台运行</span></span><br></pre></td></tr></table></figure>

<p>执行<code>gunicorn -c gun.py app:app</code>启动应用程序，</p>
<p>启动后项目的目录下会生成<code>access.log</code>，<code>error.log</code>和<code>gunicorn.pid</code>三个文件，<code>gunicorn.pid</code>中保存了gunicorn的主进程PID号，可以通过<code>cat gunicorn.pid</code>查看，当想要停止gunicorn时，直接<code>kill 进程号</code>即可杀死所有gunicorn进程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>单纯的Flask 自带的Web服务器做下测试，在压力大的时候出现socket的问题，因为他是单进程单线程的。而使用gunicorn来启动，响应速度和能力提升显著。配置中workers指定启动的进程数。cpu的损耗是平均到各个进程。workers的值一定不要过大，毕竟多进程对于系统的调度消耗比较大。</p>
<p>这一章节的结束，就标志着自动化运维新手村系列正式完结了，希望大家可以通过这一系列的学习，都可以快速上手Python，并结合自己的场景完成特定的自动化运维小工具，敬请期待自动化运维初级村的更多内容。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
        <tag>Gunicorn</tag>
      </tags>
  </entry>
  <entry>
    <title>1.1 自动化运维新手村-Python基础-1</title>
    <url>/posts/71625180.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先说明，以下几类读者朋友们请自行对号入座：</p>
<ul>
<li><p>对CMDB很了解但对于Python还没有上手的读者，强烈建议阅读此篇；</p>
</li>
<li><p>了解过Python基本的数据结构，但又没有经常在实践中运用的读者，建议阅读此篇；</p>
</li>
<li><p>已经可以熟练写出Python脚本，但对CMDB不是很了解的读者，建议阅读此篇；</p>
</li>
</ul>
<span id="more"></span>

<h2 id="CMDB简介"><a href="#CMDB简介" class="headerlink" title="CMDB简介"></a><strong>CMDB简介</strong></h2><p>简单赘述以下，CMDB的英文全称是Configuration Management Database，中文名叫配置管理数据库，它几乎贯穿了运维的每个环节。在实际的项目中，<strong>CMDB常常被认为是构建其它ITIL(Information Technology Infrastructure Library，IT基础架构库)流程的基础，ITIL项目的成败与是否成功建立CMDB有非常大的关系。</strong></p>
<p>对于一些中大型的互联网公司必然都有自研的CMDB系统，而一些初创公司可能采用开源的CMDB工具或者部分运维工程师日常使用Excel表格充当简易的CMDB功能，我们的<strong>目的并不是让大家去构建一个新的CMDB去推翻原有系统</strong>，也不是说用Excel表格就不如用Python来的高级，而是<strong>能让大家从CMDB自顶向下的拆解，来更生动的体会到Python基础数据结构的运用</strong></p>
<h2 id="CMDBv1-0"><a href="#CMDBv1-0" class="headerlink" title="CMDBv1.0"></a><strong>CMDBv1.0</strong></h2><p>实现完整的CMDB十分复杂，但作为讲解Python基本数据结构的范例，我们先实现一个简易的1.0版本。</p>
<p>CMDBv1.0只需要通过一个Python脚本就可以做到资产数据的增删改查。</p>
<blockquote>
<p>可能会有一些有CMDB使用经验的朋友会有质疑，觉得这也叫CMDB，还请大家稍安勿躁，任何大型系统的构建都是经过日积月累的迭代，但我可以保证，在项目冷启动阶段，这样一个稍微简陋的1.0版本，就可以起到基本的资产管理的作用。</p>
</blockquote>
<p>下面假设我们已经有了一个Python脚本，名叫 <code>cmdb-v1.0.py</code> ，我们简单的演示以下它的操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root&gt; </span><span class="language-bash"><span class="comment"># python3 cmdb-v1.0.py init beijing  // 初始化beijing IDC</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;beijing&quot;: &#123;</span><br><span class="line"></span><br><span class="line">        &quot;idc&quot;: &quot;beijing&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;switch&quot;: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">        &quot;router&quot;: &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">root&gt; </span><span class="language-bash"><span class="comment"># python3 cmdb-v1.0.py add /beijing/switch   // 添加beijing IDC的IP地址是10.0.0.1的交换机信息</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;beijing&quot;: &#123;</span><br><span class="line"></span><br><span class="line">        &quot;idc&quot;: &quot;beijing&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;switch&quot;: &#123;</span><br><span class="line"></span><br><span class="line">            &quot;10.0.0.1&quot;: &#123;</span><br><span class="line"></span><br><span class="line">                &quot;ip&quot;: &quot;10.0.0.1&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;manufacturer&quot;: &quot;cisco&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;hardware&quot;: &quot;nexus9500&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;role&quot;: &quot;asw&quot;,</span><br><span class="line"></span><br><span class="line">                &quot;port&quot;: [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;],</span><br><span class="line"></span><br><span class="line">                &quot;stack&quot;: true</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &quot;router&quot;: &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">root&gt; </span><span class="language-bash"><span class="comment"># python3 cmdb-v1.0.py get /beijing/switch/10.0.0.1  // 读取beijing IDC的IP地址是10.0.0.1的交换机信息</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;ip&quot;: &quot;10.0.0.1&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;manufacturer&quot;: &quot;cisco&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;hardware&quot;: &quot;nexus9500&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;role&quot;: &quot;asw&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;port&quot;: [</span><br><span class="line"></span><br><span class="line">        &quot;Eth1/1/0&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;Eth1/1/1&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;Eth1/1/2&quot;</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    &quot;stack&quot;: true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">root&gt; </span><span class="language-bash"><span class="comment"># python .\cmdb-v1.0.py update /beijing/switch/10.0.0.1/hostname &#x27;\&quot;test\&quot;&#x27;  // 将 beijing IDC的IP地址是10.0.0.1的交换机主机名修改为 test</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">root&gt; </span><span class="language-bash"><span class="comment"># python .\cmdb-v1.0.py get /beijing/switch/10.0.0.1  // 读取验证相关信息</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;ip&quot;: &quot;10.0.0.1&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;manufacturer&quot;: &quot;cisco&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;hostname&quot;: &quot;test&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;hardware&quot;: &quot;nexus9500&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;role&quot;: &quot;asw&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;port&quot;: [</span><br><span class="line"></span><br><span class="line">        &quot;Eth1/1/0&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;Eth1/1/1&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;Eth1/1/2&quot;</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    &quot;stack&quot;: true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">root&gt; </span><span class="language-bash"><span class="comment"># python .\cmdb-v1.0.py delete /beijing/switch/10.0.0.1/role  // 删除beijing IDC的IP地址是10.0.0.1的交换机的角色属性</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">root&gt; </span><span class="language-bash"><span class="comment"># python .\cmdb-v1.0.py delete /beijing/switch/10.0.0.1/port &#x27;[\&quot;Eth1/1/0\&quot;]&#x27;  // 删除beijing IDC的IP地址是10.0.0.1的交换机端口属性中的 Eth1/1/0</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">root&gt; </span><span class="language-bash"><span class="comment"># python .\cmdb-v1.0.py get /beijing/switch/10.0.0.1  // 读取验证相关信息</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;ip&quot;: &quot;10.0.0.1&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;manufacturer&quot;: &quot;cisco&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;hostname&quot;: &quot;test&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;hardware&quot;: &quot;nexus9500&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;port&quot;: [</span><br><span class="line"></span><br><span class="line">        &quot;Eth1/1/1&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;Eth1/1/2&quot;</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    &quot;stack&quot;: true</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面演示的几个步骤包括了地域的初始化，资产信息的增删改查，大家可以发现整个1.0版本中，数据源的结构是比较清晰的，几乎涉及到了Python中最常用的数据类型，以及不同数据类型的常用操作，所以这也是我想以CMDB为例切入Python的原因。</p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a><strong>Python</strong></h2><blockquote>
<p>从笔者个人经历来说，写过Python，Java，Golang，至今仍然觉得Python是一门十分优秀的语言，能够持续霸占最热门语言的前三甲，确实有其独到之处</p>
</blockquote>
<h4 id="Python优缺点"><a href="#Python优缺点" class="headerlink" title="Python优缺点"></a><strong>Python优缺点</strong></h4><ul>
<li>优点<ul>
<li>简单</li>
<li>免费、开源</li>
<li>高层语言面向对象</li>
<li>可扩展性</li>
<li>丰富的库</li>
</ul>
</li>
<li>缺点<ul>
<li>性能，虽然有一部分网友还是对Python颇有微词，但如果非要从Python的众多缺点中挑一个最重要的一点的话，那就是性能问题，但性能问题绝对不是我们弃用Python的原因，目前仍然有诸多方法可以保证Python支持企业级应用平稳运行迭代，而且就连字节如此大体量的公司很多地方都仍然使用Python进行开发</li>
</ul>
</li>
</ul>
<h2 id="CMDB拆解及Python基本数据类型"><a href="#CMDB拆解及Python基本数据类型" class="headerlink" title="CMDB拆解及Python基本数据类型"></a><strong>CMDB拆解及Python基本数据类型</strong></h2><h3 id="CMDB-拆解"><a href="#CMDB-拆解" class="headerlink" title="CMDB 拆解"></a><strong>CMDB 拆解</strong></h3><p>根据上面的演示大家应该已经大概了解CMDBv1.0版本的数据源大概长什么样子了，它的层级的划分其实是根据每个公司不同的实际场景决定的，我们这里就暂且先考虑普适情况，即idc为顶层，其包含了switch和router，然后再包含具体的设备信息和属性，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;beijing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;idc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;switch&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;10.0.0.1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;manufacturer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco-nx95-00-00-01&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hardware&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nexus9500&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asw&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;Eth1/1/0&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;Eth1/1/1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;Eth1/1/2&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;stack&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;10.0.0.2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;manufacturer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco-nx95-00-00-02&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hardware&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nexus9500&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dsw&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;GEth1/1/0&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;GEth1/1/1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;GEth1/1/2&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;stack&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;router&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;10.0.0.3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.0.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;manufacturer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco-nx95-00-00-01&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hardware&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nexus9500&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;br&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;TGEth1/0/0/1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;TGEth1/0/0/2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;TGEth1/0/0/3&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;bgp_as&quot;</span><span class="punctuation">:</span> <span class="number">64512</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;shanghai&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;idc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shanghai&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;switch&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;10.0.1.1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;manufacturer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco-nx95-00-01-01&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hardware&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nexus9500&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asw&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;Eth1/1/0&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;Eth1/1/1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;Eth1/1/2&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;stack&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;router&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;10.0.1.3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.1.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;manufacturer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco-nx95-00-01-01&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;hardware&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nexus9500&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;br&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;TGEth1/0/0/1&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;TGEth1/0/0/2&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;TGEth1/0/0/3&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;bgp_as&quot;</span><span class="punctuation">:</span> <span class="number">64512</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>想必很多读者都听过数据结构，构建一个可扩展的CMDB非常需要一个合适的数据结构，当然很多计算机专业的同学应该了解，数据结构是一门十分复杂的学科，无法在短时间内将其讲解清楚，感兴趣的同学可以阅读番外篇详细了解，此处我们先简短的介绍一下需要用到的一些概念：</p>
<h5 id="数据结构（英语：data-structure）是计算机中存储、组织数据的方式，不同种类的数据结构适合于不同种类的应用；常见的数据结构有，栈，队列，数组，链表，树，图，堆，散列表-x3D"><a href="#数据结构（英语：data-structure）是计算机中存储、组织数据的方式，不同种类的数据结构适合于不同种类的应用；常见的数据结构有，栈，队列，数组，链表，树，图，堆，散列表-x3D" class="headerlink" title="数据结构（英语：data structure）是计算机中存储、组织数据的方式，不同种类的数据结构适合于不同种类的应用；常见的数据结构有，栈，队列，数组，链表，树，图，堆，散列表&#x3D;"></a><strong>数据结构（英语：data structure）是计算机中存储、组织数据的方式，不同种类的数据结构适合于不同种类的应用；常见的数据结构有，栈，队列，数组，链表，树，图，堆，散列表&#x3D;</strong></h5><p>其实我们目前只需要用到<strong>数组</strong>和<strong>散列表</strong>(又称哈希表)两种数据结构，我先通俗易懂的讲解一下这两种数据结构</p>
<ul>
<li>数组， 可以将其理解为一个容器，里面可以装很多元素，只不过这些元素必须是相同类型的, 他们可以用下标的位置进行存取，如</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|a | b | c | d | e | f | g | h | i | j | </span><br><span class="line"></span><br><span class="line"> 0   1   2   3   4   5   6   7   8   9</span><br></pre></td></tr></table></figure>

<p>值得注意的是数组的下标永远都是从<code>0</code>开始，这个对于初期接触编程的读者朋友来说可能会有点儿不适应</p>
<ul>
<li>散列表，可以将其理解为通讯录，通讯录里的人不可以重名，每个人的名字都对应他的个人信息，个人信息可以存储任何数据，如</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;jack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;19098090000&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;allen&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;john&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shanghai&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;family&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;father&quot;</span><span class="punctuation">,</span> <span class="string">&quot;mother&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sister&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Python基础数据操作"><a href="#Python基础数据操作" class="headerlink" title="Python基础数据操作"></a><strong>Python基础数据操作</strong></h3><blockquote>
<p>通过上述的介绍，我们了解到了CMDB-v1.0的数据源长什么样子，以及它使用了什么样的数据结构，那么接下来就是如何用Python来表示它，这就涉及到了Python的几大数据类型</p>
</blockquote>
<ul>
<li>字符串: 上述数据源中用到最多的类型就是字符串，如<code>&quot;ip&quot;</code>,<code> &quot;cisco&quot;</code>, <code>&quot;role&quot;</code>等</li>
<li>整数：Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，如 <code>1</code>, <code>64512</code>, <code>-100 </code>等</li>
<li>浮点数：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，<code>1.5e11</code>，<code>1.5e-21</code></li>
<li>布尔值：布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值</li>
<li>列表：Python中列表即为数据结构中的数组，一种有序的集合，可以随时添加和删除其中的元素</li>
<li>元组：另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改</li>
<li>集合：也是一组key的集合，但在set中，没有重复的key</li>
<li>字典：dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度，dict即为数据结构中的散列表</li>
</ul>
<blockquote>
<p>Tips</p>
</blockquote>
<blockquote>
<p>上述说列表和元组为有序序列，并不是说列表和元组中的元素会按大小顺序排列，而是说列表和元组中的每个元素的排列是固定的，即不管print多少次，显示的结果是一样的；但字典和集合中的元素不是有序的，print出的结果可能会不一样；这种现象其实是由于不同的数据结构在计算机内存中不同的存储和表示方法造成的，后续会在番外篇中详细解释。</p>
</blockquote>
<p>下面我们就结合CMDB-v1.0的数据源逐一讲解涉及到的数据类型和其操作：</p>
<h4 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a><strong>第一个Python程序</strong></h4><p>学习任何一门编程语言第一个程序都是如何打印出<code>Hello World</code>，Python对此的实现十分简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在命令行模式下，输入python，进入Python的交互模式&gt;&gt;&gt; print(&quot;Hello, World!!!&quot;)# 输出结果为 Hello World# 输入exit()退出Python交互模式，或者可以直接输入ctrl-D直接退出</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tips</strong></p>
</blockquote>
<blockquote>
<p>从Python实现打印一行字符串其实可以看出很多这门语言的特点，首先给人的第一感觉就是简洁，代码阅读起来和阅读英文十分相似，其次就是Python程序的运行不需要编译，诸如C++，JAVA，Golang运行前都需要进行编译，这是因为<strong>Python是一门解释型语言</strong>，具体关于解释型语言和编译型语言的区别，后续会在番外篇中详细解释。</p>
</blockquote>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h4><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头，比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">port_num = <span class="number">40</span> <span class="comment"># 变量port_num是一个整数</span></span><br><span class="line">hostname = <span class="string">&quot;cisco-test&quot;</span> <span class="comment"># 变量hostname是一个字符串。</span></span><br><span class="line">stack = <span class="literal">True</span> <span class="comment"># 变量stack是一个布尔值True</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tips</strong></p>
</blockquote>
<blockquote>
<p>有过其他语言学习经历的同学可能会了解，程序中定义一个变量时，需要指定这个变量的数据类型，比如 <code>int a = 123;</code>，当把变量<code>a</code>指定为整型时，就无法把字符串再赋值给它，如<code>a=&#39;ABC&#39;</code>，这样会出发报错，但Python并没有这样的限制，这也是Python的另一大特点，即<strong>Python是一门动态类型语言</strong>，动态类型语言的一大好处就是灵活，这也是Python易上手的原因之一，但同时，由于在运行时才确定变量的数据类型，相较于静态类型语言，动态类型语言更容易出错，但我们享受其优点的同时，就必须要接受其弊病。更多关于静态语言与动态语言类型的区别，后续会在番外篇中详细解释。</p>
</blockquote>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h4><p>上面的示例代码中我们有使用到注释，注释可以帮我们很好的对代码进行解释说明，利于我们及他人后续阅读</p>
<p>Python的注释一般分为两种</p>
<ul>
<li>单行注释，可以跟在某行代码的后面，或者写在一个代码块的上面，没有强制的规定， 如</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">port_num = <span class="number">40</span> <span class="comment"># 变量port_num是一个整数</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变量port_num是一个整数port_num = 40</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多行注释，顾名思义，可以在多行注释内写多行文本</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;变量port_num是一个整数这是一个十分复杂的代码&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">port_num = <span class="number">40</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tips</strong></p>
</blockquote>
<blockquote>
<p>程序员之间比较流行的一句话是：今天的代码没写注释，别说其他人以后不认识，明天我自己就不认识了。</p>
</blockquote>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h4><p>在CMDB-v1.0中端口属性的数据类型就是数组，与之相对应的数据结构是列表。</p>
<p>该数组中存储了某台设备上所有的端口号，我们以此为例看看Python中的数组都有哪些常用操作：</p>
<ul>
<li><strong>如果我们想知道一共有多少端口</strong>，可以使用<code>len()</code>方法，len即为length的简称，很多方法名其实是可以根据名称推断出其作用</li>
</ul>
<p><code>len()</code>方法即为求某个可迭代对象的长度，此处我们的可迭代对象为数组，何为可迭代对象，我们会在番外篇中提到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>port = [<span class="string">&quot;Eth1/1/0&quot;</span>, <span class="string">&quot;Eth1/1/1&quot;</span>, <span class="string">&quot;Eth1/1/2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(port)<span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想获取某一个端口</strong>，可以使用数组下标索引进行访问，下标索引默认从<code>0</code>开始，最大为数组长度-1，如果超过数组长度，则会报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>port = [<span class="string">&quot;Eth1/1/0&quot;</span>, <span class="string">&quot;Eth1/1/1&quot;</span>, <span class="string">&quot;Eth1/1/2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port[<span class="number">0</span>]<span class="comment"># 输出 Eth1/1/0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port[<span class="number">2</span>]<span class="comment"># 输出 Eth1/1/2</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; port[-<span class="number">1</span>]<span class="comment"># 等同于上一个，Eth1/1/2，以此类推，-2即为倒数第二个元素，同样不可以超出数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port[<span class="built_in">len</span>(port)-<span class="number">1</span>]<span class="comment"># 输出 Eth1/1/2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port[<span class="number">3</span>]<span class="comment"># 会产生 IndexError 错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想在端口列表中增加一个端口</strong>，可以使用append()方法</li>
</ul>
<p><code>append()</code>方法为在数组末尾追加一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>port = [<span class="string">&quot;Eth1/1/0&quot;</span>, <span class="string">&quot;Eth1/1/1&quot;</span>, <span class="string">&quot;Eth1/1/2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port.append(<span class="string">&quot;Eth1/1/3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port<span class="comment"># 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;, &quot;Eth1/1/3&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>insert()</code>方法可以在数组任意位置插入一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>port = [<span class="string">&quot;Eth1/1/0&quot;</span>, <span class="string">&quot;Eth1/1/1&quot;</span>, <span class="string">&quot;Eth1/1/2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port.insert(<span class="number">1</span>, <span class="string">&quot;Eth1/1/1/1&quot;</span>)<span class="comment"># 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1/1&quot;, Eth1/1/1&quot;, &quot;Eth1/1/2&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想将两个端口列表合并</strong>，可以使用extend方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>port = [<span class="string">&quot;Eth1/1/0&quot;</span>, <span class="string">&quot;Eth1/1/1&quot;</span>, <span class="string">&quot;Eth1/1/2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port.extend([<span class="string">&quot;Eth1/1/3&quot;</span>, <span class="string">&quot;Eth1/1/4&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port<span class="comment"># 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;, &quot;Eth1/1/2&quot;, &quot;Eth1/1/3&quot;, &quot;Eth1/1/4&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想修改数组中某个元素</strong>，可以直接使用下标索引并对其赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>port = [<span class="string">&quot;Eth1/1/0&quot;</span>, <span class="string">&quot;Eth1/1/1&quot;</span>, <span class="string">&quot;Eth1/1/2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port[<span class="number">1</span>] = <span class="string">&quot;GEth1/1/1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port<span class="comment"># 输出 [&quot;Eth1/1/0&quot;, &quot;GEth1/1/1&quot;, &quot;Eth1/1/2&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想删除端口列表中的最后一个端口</strong>，可以使用pop()方法</li>
</ul>
<p><code>pop()</code>方法会返回弹出数组的最后一个元素，并将其返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>port = [<span class="string">&quot;Eth1/1/0&quot;</span>, <span class="string">&quot;Eth1/1/1&quot;</span>, <span class="string">&quot;Eth1/1/2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port.pop()<span class="comment"># 输出 Eth1/1/2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>port<span class="comment"># 输出 [&quot;Eth1/1/0&quot;, &quot;Eth1/1/1&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>pop(i)</code>可以弹出数组中任意位置的元素</p>
<ul>
<li><strong>更多数组相关的操作我们可以在以后的实践中慢慢学习</strong></li>
</ul>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a><strong>字典</strong></h4><p>CMDB-v1.0中的核心数据类型是字典，对应的数据结构是散列表。</p>
<p>字典中存储了某个IDC的名称和其设备信息，我们以此为例看看Python中的字典都有哪些常用操作：</p>
<ul>
<li><strong>如果我们想知道这个字典是存储的IDC的信息</strong>，可以使用键对其进行查找</li>
</ul>
<blockquote>
<p>字典具有一个性质就是不管存储的数据有多大，根据某个键对其进行查找的速度都会非常快，不会随着字典数据的增加而变慢，这是数据结构中散列表的一个特性，并且字典要求键必须是不可变对象，相关知识我们后续会在番外篇中提到，此处我们暂且以字符串作为字典的键</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;&#123;...&#125;, &#123;...&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bj_info= data[<span class="string">&quot;beijing&quot;</span>]  <span class="comment"># 获取beijing IDC的数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.get(<span class="string">&quot;beijing&quot;</span>)  <span class="comment"># 同样为根据键进行查找，当字典中不存在 &quot;beijing&quot; 这个键时会返回 None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>idc_info.get(<span class="string">&quot;xiamen&quot;</span>, &#123;&#125;)  <span class="comment"># dict.get() 方法可以接收另外一个参数，作为查找的键值不存在时的默认返回值# 输出 &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想修改IDC的值</strong>，可以通过键对其进行赋值</li>
</ul>
<p>字典中键和值是一一对应的，一个键只能存储一个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>device_info = data[<span class="string">&quot;beijing&quot;</span>][<span class="string">&quot;switch&quot;</span>][<span class="string">&quot;10.0.0.1&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>device_info[<span class="string">&quot;hostname&quot;</span>] = <span class="string">&quot;test&quot;</span>  <span class="comment"># 将device_info设备的hostname修改为test</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想知道switch下有哪些设备IP</strong>，可以使用<code>dict.keys()</code>方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bj_switches = data[<span class="string">&quot;beijing&quot;</span>][<span class="string">&quot;switch&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bj_switches.keys()<span class="comment"># 输出 [&quot;10.0.0.1&quot;, &quot;10.0.0.2&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bj_switches.values()  <span class="comment"># 该方法可以获取字典中的所有值，得到beijing IDC的所有switch的详情# 输出 [&#123;...&#125;, &#123;...&#125;] </span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想给某个设备新增属性信息</strong>，可以直接用键去赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>switch_info_10_1 = bj_switches.get(<span class="string">&quot;10.0.0.1&quot;</span>, &#123;&#125;)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值时必须保证变量是字典，所以如果此处不用dict.get() 默认返回空字典，那么当不存在查询的数据时就会返回None，给None通过键赋值就会报错</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>switch_info_10_1[<span class="string">&quot;label&quot;</span>] = <span class="string">&quot;test_label&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>switch_info_10_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 &#123; &quot;label&quot;: &quot;test_label&quot;, manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;cisco-nx95-00-00-01&quot;, ...&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想用某个新的设备信息覆盖原有设备的属性信息</strong>，可以使用<code>dict.update()</code>方法</li>
</ul>
<p><code>dict.update()</code>方法接收一个字典，用来更新在原有的字典上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_dict = &#123; <span class="string">&quot;hostname&quot;</span>：<span class="string">&quot;test-00-00-01&quot;</span>, <span class="string">&quot;role&quot;</span>: <span class="string">&quot;csw&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>switch_info_10_1.update(new_dict)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>switch_info_10_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 &#123; &quot;manufacturer&quot;: &quot;cisco&quot;, &quot;hostname&quot;: &quot;test-00-00-01&quot;, ...&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想删除设备的某个属性</strong>，可以使用<code>dict.pop()</code>方法</li>
</ul>
<p><code>dict.pop()</code>方法接收一个键，将该键和其对应的值从字典中删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bj_switches[<span class="string">&quot;10.0.0.1&quot;</span>].pop(<span class="string">&quot;label&quot;</span>)  <span class="comment"># 删除beijing IDC下10.0.0.1设备的label属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>更多字典相关的操作我们可以在以后的实践中慢慢学习</strong></li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h4><p>我们CMDB-v1.0中最多使用到的就是字符串这一数据类型，如<code>&quot;idc&quot;, &quot;beijing&quot;,&quot;ip&quot;</code>等，在Python中使用引号将一串字符引住，即为字符串，引号可以是双引号或者单引号并没有强制要求，但具体如何使用更加规范我们会在番外篇中提到。</p>
<p>下面我们以设备的主机名为例，看看对于字符串有哪些具体的操作方法需要用到， 如<code>&quot;cisco-nx95-00-00-01&quot;</code></p>
<ul>
<li><strong>如果我们想查看主机名的长度</strong>，可以使用<code>len()</code>方法，上文中提到<code>len()</code>可以获取数组的长度，因为字符串同样也为可迭代对象，所以<code>len()</code>同样可以获取字符串的长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hostname = <span class="string">&quot;cisco-nx95-00-00-01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(hostname)<span class="comment"># 输出 19</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们将主机名以</strong><code>**-**</code><strong>分隔</strong>，可以使用<code>split()</code>方法，该方法需要传入分隔符，并且返回一个数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hostname.split(<span class="string">&quot;-&quot;</span>)<span class="comment"># 输出 [&quot;cisco&quot;, &quot;nx95&quot;, &quot;00&quot;, &quot;00&quot;, &quot;01&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想获取字符串的某一段</strong>，可以使用切片的方式，因为Python中字符串的存储与数组十分类似，所以切片的方式同时适用于数组和字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hostname[<span class="number">0</span>:<span class="number">5</span>]  <span class="comment"># 0可以省略，故等价于 hostname[:5]，Python中的切片是一个左闭右开区间，0-5的切片范围不包括下标5# 输出 cisco</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hostname[<span class="number">6</span>:<span class="built_in">len</span>(hostname)]  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于 hostname[6:]，切片的区间右侧数字大于等于字符串长度时，都不会报错，此时相当于一直取到字符串末尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 nx95-00-00-01</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hostname[<span class="number">0</span>:<span class="built_in">len</span>(hostname):<span class="number">2</span>]  <span class="comment"># 切片操作可以接受第三个参数，用于表示步长</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 cson9-00-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hostname[::-<span class="number">1</span>]  <span class="comment"># 第三个操作为负数时可以将字符串或数组倒置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 10-00-00-59xn-ocsic</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果我们想获取某个字符所在的位置</strong>，可以使用<code>index()</code>方法，该方法接收字符参数，并且返回该字符在字符串中的第一个出现的下标</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hostname.index(<span class="string">&quot;-&quot;</span>)<span class="comment"># 输出 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>更多字符串相关的操作我们可以在以后的实践中慢慢学习</strong></li>
</ul>
<blockquote>
<p><strong>Tips</strong></p>
</blockquote>
<blockquote>
<p>字符串是一种十分常见的数据类型，但由于字符串是文本，既然是文本就涉及到不同国家之间的编码问题，关于编码相关的内容我们会在番外篇中详细解释，大家暂时只需要知道目前国际通用的是UTF-8编码即可。</p>
</blockquote>
<h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a><strong>知识总结</strong></h2><ul>
<li>介绍了CMDB在自动化运维中的重要性</li>
<li>演示了v1.0版本的CMDB的增删改查操作</li>
<li>讲解了Python常用的数据类型：字符串，数组，字典，以及对它们的常用操作方法</li>
</ul>
<p>CMDB系列第一节我们就暂且讲解到这里，其实Python的数据类型和其操作还没有全部涉及到，我们先只掌握最常用的即可，更多的类型和内置操作方法可以慢慢积累。</p>
<p>第二节我们就会进入到CMDBv1.0版本的具体代码，为大家讲解Python的基础语句以及函数和面向对象相关的知识。</p>
<blockquote>
<p><strong>篇后语</strong></p>
</blockquote>
<blockquote>
<p>文中我们多次提到部分内容会在番外篇中详细解释，最大的原因是某个知识点如果详细展开，都足以单独写一篇文章，但对于初学者来说，我们完全必要花时间在一些细枝末节上，因为当我们学习一门新知识时，我们最好的方法就是自顶向下逐步拆解，如果一头扎进知识的海洋中，那极有可能“溺亡”。</p>
</blockquote>
<blockquote>
<p>所以如果一些职场朋友，没有多余的精力去深究细节，就没有必要去看番外篇，当然如果对某个知识点十分感兴趣也可以多做了解；</p>
</blockquote>
<blockquote>
<p>但对于计算机专业的同学，不管已经毕业或者还未毕业，我都强烈大家建议阅读番外篇，只有基础打的足够牢，才能做到触类旁通。</p>
</blockquote>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.16 自动化运维新手村-Flask-ORM集成</title>
    <url>/posts/760ef160.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>在上一章节「自动化运维新手村-ORM」入门中，我们已经了解了基本的数据库的概念，以及常用的数据表操作，并且我希望大家意识到，如果在后端应用不必须依赖数据库时，最好不要引入；但如果引入，那么就最好在使用之前了解一些数据库的基础知识，比如：从手动写SQL语句建数据表开始。</p>
<p>在建好表后，今天这一章节，就开始讲解如何在后端应用中集成对数据库操作的能力。</p>
<span id="more"></span>

<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a><strong>ORM</strong></h2><p>全称叫做对象关系映射（Object Relational Mapping，简称ORM）</p>
<p>ORM的名称上就已经十分清晰的表明其功能和用途：</p>
<p><strong>Object</strong>：对象，这里是指编程语言中的对象，例如Python&#x2F;Java中的Class，或者Golang中的struct</p>
<p><strong>Relational</strong>：关系，表示特指关系型数据库，如MySQL，Oracle，PostgreSQL</p>
<p><strong>Mapping</strong>：映射，指将编程语言的对象和关系型数据库之间进行相互关联，例如对象名表示数据表名，对象属性表示数据表列名，以及数据类型等等。</p>
<p>映射关系如图所示</p>
<p>正是由于ORM具有的以上特点，所以在继承了ORM框架的后端应用，如Django，Flask中，才可以实现定义好Model类（对象模型）后，可以一键将其在数据库中创建出对应的数据表结构。</p>
<h2 id="Flask-SQLAlchemy框架"><a href="#Flask-SQLAlchemy框架" class="headerlink" title="Flask-SQLAlchemy框架"></a><strong>Flask-SQLAlchemy框架</strong></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p>Flask作为微框架，其集成的几乎所有的能力都来自于插件，ORM框架就是提供数据库操作能力的一种插件。</p>
<p>SQLAlchemy，就是一个Python中十分常用的ORM框架，它提供了高层的ORM对底层的原生数据库的操作，让开发者不用直接和 SQL 语句打交道，而是通过 Python 对象来操作数据库。</p>
<p>而Flask-SQLAlchemy 是SQLAlchemy在Flask应用中的扩展，它旨在通过提供有用的默认值和额外的帮助程序来简化SQLAlchemy在Flask应用中的使用，从而更轻松地完成常见任务。</p>
<p>执行以下命令安装扩展包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pymysql</span><br><span class="line"></span><br><span class="line">pip install flask-sqlalchemy</span><br></pre></td></tr></table></figure>

<p>如果安装速度较慢，可以尝试指定镜像源地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install flask-sqlalchemy==2.5.1 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a><strong>引入</strong></h3><p>将Flask-SQLAlchemy引入到Flask应用中十分简单，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果flask-sqlchemy是3.0.0版本及以上，需要增加Flask上下文。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app.app_context().push()</span></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&quot;mysql+pymysql://root:Yfy98333498@127.0.0.1:3306/ops?charset=utf8&quot;</span></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br></pre></td></tr></table></figure>

<p>使用Flask-SQLAlchemy扩展到简易性显而易见，只需要设置一个<code>SQLALCHEMY_DATABASE_URI</code>，该变量的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql+pymysql://username:password@host:port/db_name?charset=utf8</span><br></pre></td></tr></table></figure>

<p>大家根据自己数据库的设置进行替换即可。</p>
<p>除了数据库URI的设置，我这里还十分推荐大家设置一个变量，那就是<code>SQLALCHEMY_ECHO</code>，该变量为<code>True</code>时，可以打印出ORM框架操作对应的数据库SQL语句，一方面对于刚接触数据库的朋友来说，可以更熟悉ORM框架与数据库之间的映射，另一方面也利于排查问题。</p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a><strong>Model</strong></h3><p>在引入<code>db</code>之后，就可以开始定义Model模型了，根据上一章节中的数据表结构，我们可以对应的定义出对象模型，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">&#x27;devices&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>, comment=<span class="string">&quot;自增主键&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ip = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;IP地址&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hostname = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;主机名&quot;</span>)</span><br><span class="line"></span><br><span class="line">    idc = db.Column(db.String(<span class="number">32</span>), comment=<span class="string">&quot;机房&quot;</span>)</span><br><span class="line"></span><br><span class="line">    row = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    column = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜列&quot;</span>)</span><br><span class="line"></span><br><span class="line">    vendor = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;厂商&quot;</span>)</span><br><span class="line"></span><br><span class="line">    model = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;型号&quot;</span>)</span><br><span class="line"></span><br><span class="line">    role = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;角色&quot;</span>)</span><br><span class="line"></span><br><span class="line">    created_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    updated_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), server_onupdate=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;修改时间&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里与上节相比新增了两列，分别是<code>created_at, updated_at</code>，在新增一行数据或者某一行数据修改时，会更新数据创建或修改的时间。</p>
<p>大家可以参照数据表的SQL语句来对比一下，ORM框架中模型与数据库的映射。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `devices` (</span><br><span class="line"></span><br><span class="line">    `id` <span class="type">INT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `ip` <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;IP地址&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `hostname` <span class="type">VARCHAR</span>(<span class="number">128</span>) COMMENT <span class="string">&#x27;主机名&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `idc` <span class="type">VARCHAR</span>(<span class="number">32</span>) COMMENT <span class="string">&#x27;机房&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `<span class="type">row</span>` <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;机柜行&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `<span class="keyword">column</span>` <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;机柜列&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `vendor` <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;厂商&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `model` <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;型号&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `role` <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;角色&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `created_at` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    `updated_at` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<h3 id="数据类型及列选项"><a href="#数据类型及列选项" class="headerlink" title="数据类型及列选项"></a>数据类型及列选项</h3><p>从上面的Model创建和SQL语句的对比来看，Flask-SQLAlchemy与数据库之间的数据类型存在特定的映射关系，由于Flask-SQLAlchemy是基于SQLAlchemy实现的，所以其数据类型与SQLAlchemy相同。</p>
<p>SQLAlchemy中常用数据类型：</p>
<p><img src="https://s2.loli.net/2023/04/08/4daxQqOtkmDF72C.png" alt="img"></p>
<p>除了常用的数据类型之外，我们SQL语句中还在定义列的时候，指定了很多属性，这些在SQLAlchemy中也有同样的定义。</p>
<h3 id="SQLAlchemy中常用的列选项"><a href="#SQLAlchemy中常用的列选项" class="headerlink" title="SQLAlchemy中常用的列选项"></a><strong>SQLAlchemy中常用的列选项</strong></h3><p><img src="https://s2.loli.net/2023/04/08/XJHADpeZLqdK1o4.png" alt="img"></p>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a><strong>增删改查</strong></h2><p>在定义好Model之后，就进入了最为重要的一步，那就是通过对Model的操作，实现数据表的增删改查。</p>
<p>代码整理如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /models.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&quot;mysql+pymysql://root:YfyH98333498.@127.0.0.1:3306/ops?charset=utf8&quot;</span></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line"></span><br><span class="line">    __tablename__ = <span class="string">&#x27;devices&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>, comment=<span class="string">&quot;自增主键&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ip = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;IP地址&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hostname = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;主机名&quot;</span>)</span><br><span class="line"></span><br><span class="line">    idc = db.Column(db.String(<span class="number">32</span>), comment=<span class="string">&quot;机房&quot;</span>)</span><br><span class="line"></span><br><span class="line">    row = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    column = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜列&quot;</span>)</span><br><span class="line"></span><br><span class="line">    vendor = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;厂商&quot;</span>)</span><br><span class="line"></span><br><span class="line">    model = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;型号&quot;</span>)</span><br><span class="line"></span><br><span class="line">    role = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;角色&quot;</span>)</span><br><span class="line"></span><br><span class="line">    created_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    updated_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), server_onupdate=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;修改时间&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 增</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查</span></span><br></pre></td></tr></table></figure>

<h3 id="增"><a href="#增" class="headerlink" title="增"></a><strong>增</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /models.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 增</span></span><br><span class="line"></span><br><span class="line">    device = Devices(ip=<span class="string">&quot;10.0.0.1&quot;</span>, hostname=<span class="string">&quot;BJ-R01-C01-N9K-00-00-01&quot;</span>, idc=<span class="string">&quot;Beijing&quot;</span>, row=<span class="string">&quot;R01&quot;</span>, column=<span class="string">&quot;C01&quot;</span>, vendor=<span class="string">&quot;Cisco&quot;</span>, model=<span class="string">&quot;Nexus9000&quot;</span>, role=<span class="string">&quot;CSW&quot;</span>)</span><br><span class="line"></span><br><span class="line">    db.session.add(device)</span><br><span class="line"></span><br><span class="line">    db.session.commit()</span><br></pre></td></tr></table></figure>

<p>这里在操作数据时会通过<code>db.session</code>来进行操作，并且执行完语句之后需要执行<code>db.session.commit()</code>来提交操作，这是由于Flask-SQLAlchemy通过session机制保证了在多线程操作数据库时互不影响，具体的原理我们会单独在番外篇中提到。</p>
<p>执行<code>python models.py</code>后可以看到控制台输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-03-06 20:03:35,775 INFO sqlalchemy.engine.Engine SELECT @@sql_mode</span><br><span class="line"></span><br><span class="line">2022-03-06 20:03:35,776 INFO sqlalchemy.engine.Engine SELECT @@lower_case_table_names</span><br><span class="line"></span><br><span class="line">2022-03-06 20:03:35,777 INFO sqlalchemy.engine.Engine SELECT DATABASE()</span><br><span class="line"></span><br><span class="line">2022-03-06 20:03:35,778 INFO sqlalchemy.engine.Engine BEGIN (implicit)</span><br><span class="line"></span><br><span class="line">2022-03-06 20:03:35,780 INFO sqlalchemy.engine.Engine INSERT INTO devices (ip, hostname, idc, `row`, `column`, vendor, model, `role`) VALUES (%(ip)s, %(hostname)s, %(idc)s, %(row)s, %(column)s, %(vendor)s, %(model)s, %(role)s)</span><br><span class="line"></span><br><span class="line">2022-03-06 20:03:35,781 INFO sqlalchemy.engine.Engine [generated in 0.00023s] &#123;&#x27;ip&#x27;: &#x27;10.0.0.1&#x27;, &#x27;hostname&#x27;: &#x27;BJ-R01-C01-N9K-00-00-01&#x27;, &#x27;idc&#x27;: &#x27;Beijing&#x27;, &#x27;row&#x27;: &#x27;R01&#x27;, &#x27;column&#x27;: &#x27;C01&#x27;, &#x27;vendor&#x27;: &#x27;Cisco&#x27;, &#x27;model&#x27;: &#x27;Nexus9000&#x27;, &#x27;role&#x27;: &#x27;CSW&#x27;&#125;</span><br><span class="line"></span><br><span class="line">2022-03-06 20:03:35,783 INFO sqlalchemy.engine.Engine COMMIT</span><br></pre></td></tr></table></figure>

<p>执行<code>select * from devices\G;</code>查询数据库结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> devices\G;</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line">id: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">ip: <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">hostname: BJ<span class="operator">-</span>R01<span class="operator">-</span>C01<span class="operator">-</span>N9K<span class="number">-00</span><span class="number">-00</span><span class="number">-01</span></span><br><span class="line"></span><br><span class="line">idc: Beijing</span><br><span class="line"></span><br><span class="line"><span class="type">row</span>: R01</span><br><span class="line"></span><br><span class="line"><span class="keyword">column</span>: C01</span><br><span class="line"></span><br><span class="line">vendor: Cisco</span><br><span class="line"></span><br><span class="line">model: Nexus9000</span><br><span class="line"></span><br><span class="line">role: CSW</span><br><span class="line"></span><br><span class="line">created_at: <span class="number">2022</span><span class="number">-03</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">03</span>:<span class="number">35</span></span><br><span class="line"></span><br><span class="line">updated_at: <span class="number">2022</span><span class="number">-03</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">03</span>:<span class="number">35</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到已经成功插入了一条数据，并且数据库自动插入了<code>id, created_at, updated_at</code>字段。</p>
<p>批量新增如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /models.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增</span></span><br><span class="line"></span><br><span class="line">device1 = Devices(ip=<span class="string">&quot;10.0.0.1&quot;</span>, hostname=<span class="string">&quot;BJ-R01-C01-N9K-00-00-01&quot;</span>, idc=<span class="string">&quot;Beijing&quot;</span>, row=<span class="string">&quot;R01&quot;</span>, column=<span class="string">&quot;C01&quot;</span>, vendor=<span class="string">&quot;Cisco&quot;</span>, model=<span class="string">&quot;Nexus9000&quot;</span>, role=<span class="string">&quot;CSW&quot;</span>)</span><br><span class="line"></span><br><span class="line">device2 = Devices(ip=<span class="string">&quot;10.0.0.2&quot;</span>, hostname=<span class="string">&quot;BJ-R01-C01-N9K-00-00-02&quot;</span>, idc=<span class="string">&quot;Beijing&quot;</span>, row=<span class="string">&quot;R01&quot;</span>, column=<span class="string">&quot;C02&quot;</span>, vendor=<span class="string">&quot;Cisco&quot;</span>, model=<span class="string">&quot;Nexus9000&quot;</span>, role=<span class="string">&quot;CSW&quot;</span>)</span><br><span class="line"></span><br><span class="line">device3 = Devices(ip=<span class="string">&quot;10.0.0.3&quot;</span>, hostname=<span class="string">&quot;BJ-R01-C01-N9K-00-00-03&quot;</span>, idc=<span class="string">&quot;Beijing&quot;</span>, row=<span class="string">&quot;R01&quot;</span>, column=<span class="string">&quot;C03&quot;</span>, vendor=<span class="string">&quot;Cisco&quot;</span>, model=<span class="string">&quot;Nexus9000&quot;</span>, role=<span class="string">&quot;CSW&quot;</span>)</span><br><span class="line"></span><br><span class="line">db.session.add_all([device1, device2, device3])</span><br><span class="line"></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure>

<p>查询数据库结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> devices\G;</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line">id: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">ip: <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">hostname: BJ<span class="operator">-</span>R01<span class="operator">-</span>C01<span class="operator">-</span>N9K<span class="number">-00</span><span class="number">-00</span><span class="number">-01</span></span><br><span class="line"></span><br><span class="line">idc: Beijing</span><br><span class="line"></span><br><span class="line"><span class="type">row</span>: R01</span><br><span class="line"></span><br><span class="line"><span class="keyword">column</span>: C01</span><br><span class="line"></span><br><span class="line">vendor: Cisco</span><br><span class="line"></span><br><span class="line">model: Nexus9000</span><br><span class="line"></span><br><span class="line">role: CSW</span><br><span class="line"></span><br><span class="line">created_at: <span class="number">2022</span><span class="number">-03</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">52</span></span><br><span class="line"></span><br><span class="line">updated_at: <span class="number">2022</span><span class="number">-03</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">52</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line">id: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">ip: <span class="number">10.0</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">hostname: BJ<span class="operator">-</span>R01<span class="operator">-</span>C01<span class="operator">-</span>N9K<span class="number">-00</span><span class="number">-00</span><span class="number">-02</span></span><br><span class="line"></span><br><span class="line">idc: Beijing</span><br><span class="line"></span><br><span class="line"><span class="type">row</span>: R01</span><br><span class="line"></span><br><span class="line"><span class="keyword">column</span>: C02</span><br><span class="line"></span><br><span class="line">vendor: Cisco</span><br><span class="line"></span><br><span class="line">model: Nexus9000</span><br><span class="line"></span><br><span class="line">role: CSW</span><br><span class="line"></span><br><span class="line">created_at: <span class="number">2022</span><span class="number">-03</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">52</span></span><br><span class="line"></span><br><span class="line">updated_at: <span class="number">2022</span><span class="number">-03</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">52</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line">id: <span class="number">7</span></span><br><span class="line"></span><br><span class="line">ip: <span class="number">10.0</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line"></span><br><span class="line">hostname: BJ<span class="operator">-</span>R01<span class="operator">-</span>C01<span class="operator">-</span>N9K<span class="number">-00</span><span class="number">-00</span><span class="number">-03</span></span><br><span class="line"></span><br><span class="line">idc: Beijing</span><br><span class="line"></span><br><span class="line"><span class="type">row</span>: R01</span><br><span class="line"></span><br><span class="line"><span class="keyword">column</span>: C03</span><br><span class="line"></span><br><span class="line">vendor: Cisco</span><br><span class="line"></span><br><span class="line">model: Nexus9000</span><br><span class="line"></span><br><span class="line">role: CSW</span><br><span class="line"></span><br><span class="line">created_at: <span class="number">2022</span><span class="number">-03</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">52</span></span><br><span class="line"></span><br><span class="line">updated_at: <span class="number">2022</span><span class="number">-03</span><span class="number">-06</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">52</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="删、改、查"><a href="#删、改、查" class="headerlink" title="删、改、查"></a><strong>删、改、查</strong></h3><p>删除和修改都需要基于查询，由于查询的篇幅较多，我们都统一放到下一章节再讲解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这一章节是比较重要的一节，我们首次在后端应用中引入数据库，并通过ORM框架实现对数据库的操作，所以希望大家务必要亲自实践操作，否则后面的学习内容就无法顺利地开展。</p>
]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>CMDB</tag>
        <tag>Web</tag>
        <tag>Flask</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>2.1 自动化运维初级村-Paramiko vs Netmiko</title>
    <url>/posts/7a08fdf6.html</url>
    <content><![CDATA[<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>秉承着“<strong>最小化上手范围</strong>”的原则，相信大家经过新手村二十多个章节的学习，都已经对Python有了初步的了解，基础的学习必然是略显枯燥无聊的，但希望大家可以在“新手村”系列视频和文章的指导下有自己<strong>阅读程序，分析需求，编写程序，调试程序</strong>的基本技能。</p>
<p>以上也是进入初级村的最低门槛，如果还没有具备上述能力的朋友，衷心的希望你可以返回新手村进行学习，切勿囫囵吞枣，盲目求快。</p>
<span id="more"></span>

<h2 id="初级村包含的内容"><a href="#初级村包含的内容" class="headerlink" title="初级村包含的内容"></a><strong>初级村包含的内容</strong></h2><h3 id="Paramiko和Netmiko"><a href="#Paramiko和Netmiko" class="headerlink" title="Paramiko和Netmiko"></a>Paramiko和Netmiko</h3><blockquote>
<p>两者的使用方式及优劣</p>
</blockquote>
<h3 id="Python-正则解析"><a href="#Python-正则解析" class="headerlink" title="Python 正则解析"></a>Python 正则解析</h3><blockquote>
<p>将通过SSH收集回来的各种信息进行正则解析</p>
</blockquote>
<h4 id="番外：Text-FSM解析"><a href="#番外：Text-FSM解析" class="headerlink" title="番外：Text-FSM解析"></a>番外：Text-FSM解析</h4><h3 id="Python-SNMP"><a href="#Python-SNMP" class="headerlink" title="Python SNMP"></a>Python SNMP</h3><blockquote>
<p>如何使用Python调用SNMP采集指令，并讲解OID使用方式</p>
</blockquote>
<h3 id="NetConf"><a href="#NetConf" class="headerlink" title="NetConf"></a>NetConf</h3><blockquote>
<p>如何通过NetConf对网络设备进行操作</p>
</blockquote>
<h3 id="Crontab并回调CMDB"><a href="#Crontab并回调CMDB" class="headerlink" title="Crontab并回调CMDB"></a>Crontab并回调CMDB</h3><blockquote>
<p>如何设置定时执行SSH任务进行定期巡检，并更新回写CMDB</p>
</blockquote>
<h4 id="番外：Python-Scheduler"><a href="#番外：Python-Scheduler" class="headerlink" title="番外：Python Scheduler"></a>番外：Python Scheduler</h4><h3 id="Flask-Web框架"><a href="#Flask-Web框架" class="headerlink" title="Flask Web框架"></a>Flask Web框架</h3><blockquote>
<p>将SSH和NetConf与Web框架相结合，通过API方式或前端调用其执行</p>
</blockquote>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote>
<p>在自动化运维领域里面，单从服务器运维的角度来讲，由于可以提前对服务器做系统的定制安装，所以一些大厂会选择在装机时植入特定的Agent，以此实现远程控制服务器的目的。</p>
<p>不过对于大部分的公司，服务器运维或者网络设备运维都仍然依靠远程SSH这一方法，所以我们使用Python作为自动化运维的编程语言的话，就非常需要一个第三方包来实现这一功能，而Paramiko和Netmiko可以说是扛把子的角色。</p>
<p>相信看这个教程的朋友肯定都听过这两个工具包，但可能并不是所有的人都了解这两个包之间的关系。除此之外，网上五花八门的对于用哪个更好的争论也难以分辨。</p>
<p>那么这个章节就先给大家介绍一下这两个包的来龙去脉，以及我个人在工作中对两个包都深度使用过之后的体验。</p>
</blockquote>
<h2 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h2><p>介绍第三方库之前有必要先科普一下关于SSH的知识。</p>
<p>我们经常谈论的SSH是一个传输层协议，相比Telnet来说可以与远端设备建立更安全的连接通道，对传输的内容进行加解密处理，所以基于安全考虑，企业中几乎所有的对远程设备的连接都要求使用SSH连接。</p>
<p>SSH协议有两种不兼容的版本：SSHv1和SSHv2。</p>
<p>那么设备想要支持SSH协议，就需要在设备上安装一个与之相匹配的服务端&#x2F;客户端的应用程序，而OpenSSH就是目前使用最为广泛的SSH协议的开源实现。</p>
<p>对于较老的SSHv1，由于存在加密算法的专利问题和数据完整性的缺陷，OpenSSH已经删除了对其的支持。所以目前OpenSSH主要支持SSHv2。</p>
<p>OpenSSH 套件包含以下工具：</p>
<ul>
<li>远程操作使用 <a href="https://man.openbsd.org/ssh.1">ssh</a>、 <a href="https://man.openbsd.org/scp.1">scp</a>和 <a href="https://man.openbsd.org/sftp.1">sftp</a>完成。</li>
<li>使用<a href="https://man.openbsd.org/ssh-add.1">ssh-add</a>、 <a href="https://man.openbsd.org/ssh-keysign.8">ssh-keysign</a>、 <a href="https://man.openbsd.org/ssh-keyscan.1">ssh-keyscan</a>和 <a href="https://man.openbsd.org/ssh-keygen.1">ssh-keygen</a> 进行密钥管理 。</li>
<li>服务端<a href="https://man.openbsd.org/sshd.8"> sshd</a>、 <a href="https://man.openbsd.org/sftp-server.8">sftp-server</a>和 <a href="https://man.openbsd.org/ssh-agent.1">ssh-agent</a>组成。</li>
</ul>
<p>整体的结构图如下所示：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<h1 id="Paramiko-x2F-Netmiko简介"><a href="#Paramiko-x2F-Netmiko简介" class="headerlink" title="Paramiko&#x2F;Netmiko简介"></a>Paramiko&#x2F;Netmiko简介</h1><h2 id="Paramiko"><a href="#Paramiko" class="headerlink" title="Paramiko"></a>Paramiko</h2><p>Paramiko遵循SSH2协议，支持以加密和认证的方式，进行远程<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>的连接；模块本身使用Python语言编写和开发，只有像crypto这样的核心函数才会用到C语言。</p>
<p>Paramiko目前是Python中应用最广的SSH模块，大家耳熟能详的Ansible， Netmiko，Nornir，NAPALM其实都是用到了Paramiko来做SSH的实现，所以也可以从中看出，其实Paramiko的角色其实是Python语言里实现SSH功能的底层工具包。</p>
<p>那么既然是底层工具包就必然为了具备完备的通用性而损失了易用性，而Paramiko过于底层的方法调用也是被网友最为诟病的原因。</p>
<p>但我们已经提到，Python想要实现SSH远程连接，就逃不开Paramiko，那么我们就非常有必要了解一下Paramiko的基本实现原理和主要的组成类</p>
<h3 id="源码核心架构图"><a href="#源码核心架构图" class="headerlink" title="源码核心架构图"></a>源码核心架构图</h3><p><img src="https://xzsh9e8v26.feishu.cn/space/api/box/stream/download/asynccode/?code=OTQ4Y2FhNzZiYjE2NmVkODg4ZWE1ZDRiMDg5YWVjNDRfWnE2NVVCemxqSmxkZFZPdnhHc0ppNjhyY2dFU1BYN3VfVG9rZW46WFhVM2JmYW9Lb2FYbTl4QnZpZ2NmUThCbmVlXzE2ODA5MjMwMTc6MTY4MDkyNjYxN19WNA" alt="img"></p>
<p>Paramiko中几个大的概念和相互之间的关系基本就是如上图所示了（一些身份认证类和其他杂类并没有包含其中，在学习初期也没有深究这些的必要）。</p>
<p>总体来说Paramiko的源码核心架构并不复杂，但对于使用该包的编程人员来说，暴露了太多底层细节。因为其最High-Level的类就是一个SSHClient对象，而一个SSHClient对象又必须通过创建Channel来完成数据的收发。</p>
<p>所以说Paramiko其实就是一个实现了SSH功能的底层工具包，它可以连接任何兼容SSHv2的设备，包括：服务器，网络设备，打印机，甚至是监控摄像头，并且它最核心的功能就是：建立SSH连接 -&gt; 发数据 -&gt; 收数据。</p>
<h2 id="Netmiko"><a href="#Netmiko" class="headerlink" title="Netmiko"></a>Netmiko</h2><p>但看本系列的教程的朋友应该大多数都是具备网络运维背景的朋友，想实现一些网络运维中的自动化能力，那么平时所要面对的就都是网络设备，我这里推荐大家使用Netmiko。</p>
<p>我们可以通过一个流程图来表示一下除了Paramiko本身的底层能力外，还需要哪些步骤才能完成一次与网络设备的交互。</p>
<h3 id="交互流程图"><a href="#交互流程图" class="headerlink" title="交互流程图"></a>交互流程图</h3><p><img src="https://xzsh9e8v26.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Q2NTBhNWY1OTgwOWEwM2NkMjI0NGIzZjM1YTA3OWVfTWlvRTFhbVc1RmpRZmYzWmpJcFczNDhLS3Q0U2l3NUdfVG9rZW46TnRteGJDZ0NSbzZvZEl4MmpJMGNBb2FMbkVkXzE2ODA5MjMwMTc6MTY4MDkyNjYxN19WNA" alt="img"></p>
<p>从上述的流程图中可以看出，除了Paramiko支持的底层SSH连接与数据发送接收功能之外，我们想要与网络设备进行交互还需要诸多地方需要处理，而Netmiko正好可以提供以上这些功能，这也是我们为什么选择用Netmiko的原因。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实网上有很多文章都有对Paramiko和Netmiko的对比，但大多数的解释都不够准确，并且还有很多直接通过代码来演示区别的，更是让一些编程基础不太好的朋友十分头疼，所以我希望大家可以通过这一章节，非常清晰的知道，两者之间的区别究竟有哪些。</p>
<p>这一章节并没有提到关于使用Paramiko或者Netmiko来进行连接设备的代码，但对Paramiko的源码核心架构做了介绍，这也是大家后续使用Netmiko必须要掌握的基础知识，并且对于Netmiko基于Paramiko的改进也通过流程图展示给大家，对后续的深入理解及二次开发会非常有帮助。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>Paramiko</tag>
        <tag>Netmiko</tag>
      </tags>
  </entry>
  <entry>
    <title>2.2 自动化运维初级村-Netmiko-入门</title>
    <url>/posts/248441c7.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>经过上一章节的分析，Netmiko已经确定是SSH连接网络设备工具包的不二之选。那么这一章节我们就正式进入Netmiko的讲解，由浅入深的学会使用Netmiko。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>首先我们再次总结一下Netmiko能够提供的能力</p>
<ul>
<li>成功建立到设备的 SSH 连接。</li>
<li>封装掉与设备交互的许多低级机制。</li>
<li>抽象出与设备交互的统一API。</li>
<li>在广泛的网络供应商和平台上执行上述操作。</li>
<li>简化 show 命令的执行、检索和格式化。</li>
<li>简化配置命令的执行。<span id="more"></span></li>
</ul>
<h1 id="抽象网络设备"><a href="#抽象网络设备" class="headerlink" title="抽象网络设备"></a>抽象网络设备</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>在开始讲解如何写代码之前，仍然需要一个架构图来了解Netmiko究竟做了哪些事情，通过架构图的直观展示，可以让第一次接触该包，或者了解不够深入的朋友，对其整体的逻辑有一个清晰的认识。</p>
<p><img src="https://xzsh9e8v26.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFmMGY4ZmUxMDJlMDkxNjFjOTE2ZjBjMzg5MDgzOGNfMDRRUTF0ZEpyZHAzcllJb095NTFjRjJxSHlsUGxDREFfVG9rZW46UTRaSmJGNmlVb1pwR1d4VG9DRGN0S1c5blplXzE2ODA5MjMxNTM6MTY4MDkyNjc1M19WNA" alt="img"></p>
<p>单纯从架构图可以发现，Netmiko中核心的几个概念都已经较难发现Paramiko的影子，因为虽然Netmiko底层仍然依赖了Paramiko的SSH连接能力，但都对其进行的一定的封装，并且将Telnet，Serial的连接一并进行了High-Level的抽象，这对于后续的使用来说就会非常方便。</p>
<h2 id="支持厂商"><a href="#支持厂商" class="headerlink" title="支持厂商"></a>支持厂商</h2><p>从上一章节的交互图中可以看出，在连接到网络设备之后，我们需要做诸多的预处理操作，那么这些操作都是与设备厂商强相关的，也就是说Netmiko必须对不同的设备类型做一定的适配。</p>
<p>究竟支持哪些设备厂商，在工具包的开源项目里就有提供，<a href="https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md">netmiko&#x2F;PLATFORMS.md</a>。</p>
<p>除此之外我们也可以在使用过程中通过源码检索到，检索方式可以参照视频讲解。</p>
<h1 id="连接设备"><a href="#连接设备" class="headerlink" title="连接设备"></a>连接设备</h1><p>使用Netmiko来连接设备的代码非常的简短，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;device_type&quot;</span>: <span class="string">&quot;cisco_ios&quot;</span>, </span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.31.149&quot;</span>, </span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;cisco&quot;</span>, </span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;cisco&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">net_connect = ConnectHandler(**params)</span><br></pre></td></tr></table></figure>

<p>上述代码是通过用户名和密码进行SSH连接的方式，这种方式最为普遍，所以我们的讲解都按照这种方式来，另外还有使用证书认证的方式，我也会在视频中提到相关参数的使用方法。</p>
<h2 id="ConnectHandler"><a href="#ConnectHandler" class="headerlink" title="ConnectHandler"></a>ConnectHandler</h2><p>这个函数就是Netmiko中的最上层的工厂函数，它的作用就是根据传入的<code>device_type</code>来选择对应的连接对象，并把工厂函数接收到的所有参数都传递到连接对象中去。</p>
<p>“工厂模式”也是在实际工作中较为常用的一个设计模式，这里的ConnectHandler就是使用了这一思想；将创建方式相同的连接对象通过工厂函数的封装来实现对上层的屏蔽。</p>
<p>该函数会把<code>params</code>参数原封不动的透传到连接对象中去（用到了之前番外篇提到的可变参数<a href="https://xzsh9e8v26.feishu.cn/docs/doccnHQr7HdMecZtoANNXw9apFc">自动化运维番外篇-Python参数</a> ），返回一个初始化好的连接对象<code>Connection</code>。</p>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>这个对象就是真正的连接对象了，不同厂商设备的连接对象继承自基类连接对象<code>(BaseConnection)</code></p>
<p>在这个对象初始化的过程中会打开SSH连接，由上一节内容的介绍可以知道，Netmiko在创建连接的时候是会很多准备工作，这些准备工作如下：</p>
<ul>
<li>test_channel_read：尝试读取通道中的数据。</li>
<li>set_base_prompt：设置分隔符，用来去除输出内容结尾的设备提示符，通常为设备名</li>
<li>set_terminal_width：设置终端宽度，这个值与输出内容的行宽度有关，会影响到结果的换行。</li>
<li>disable_paging：关闭输出分页。</li>
</ul>
<p>上述是连接基类<code>BaseConnection</code>中提供的函数，不同设备厂商的连接对象会有各自不同的实现。</p>
<p>正是因为Netmiko在登录之后做了上述几个操作，所以会让人感觉Netmiko连接的速度要比Paramiko慢很多，Paramiko只需要协商SSH成功就可以直接收发数据了，但Netmiko的四个准备动作就需要和设备交互四次以上，才算建立连接成功。</p>
<p>可能部分朋友会觉得我讲的有点儿复杂了，但其实我认为这些内容都是非常有必要了解的，实际Netmiko源码中的处理要更为复杂，我这里只把最为核心的操作给大家介绍了一下。</p>
<p>如果像其他博客一样，直接贴几行Netmiko连接设备执行命令的代码，那么我这个教程就毫无意义了；而且如果不了解这些内容，在后续执行命令出现任何问题的时候，因为在最开始根本就没有了解到Netmiko的实现逻辑，所以会排查起来毫无头绪。</p>
<p>因此我希望大家可以耐心一点，慢即是快。</p>
<h1 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h1><p>Netmiko的执行命令操作分为几种，我们先以最常用到的一种来举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;device_type&quot;</span>: <span class="string">&quot;cisco_ios&quot;</span>,</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.31.149&quot;</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;cisco&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;cisco&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">net_connect = ConnectHandler(**params)</span><br><span class="line">cmd = <span class="string">&quot;show interface brief&quot;</span></span><br><span class="line">output = net_connect.send_command(cmd)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>

<h2 id="send-command"><a href="#send-command" class="headerlink" title="send_command"></a>send_command</h2><p>这个函数通常用来执行show类型的命令，默认情况下，该方法将一直等待接收数据，直到检测到设备提示符。</p>
<blockquote>
<p>设备提示符默认在执行命令前会自动确定，自动确定的方法为向设备发送一个换行符，然后读取输出内容的最后一行作为设备提示符，后续执行指定命令的时候就会等待输出结果中出现这个提示符，视为命令执行完成。</p>
</blockquote>
<p>该函数的主要逻辑如下所示：</p>
<p><img src="https://xzsh9e8v26.feishu.cn/space/api/box/stream/download/asynccode/?code=YWEzZDVhZTkyOGE0YmE5ODdlNWUxNzI2NzZmODg2MTJfdnI5MGZLQmFXVkhtSDExNUtMZmxwb0hRaW9nU25pUGxfVG9rZW46S3hpVmJtdmUxb0JueFF4WDhRS2NLMDBFbmNoXzE2ODA5MjMxNTM6MTY4MDkyNjc1M19WNA" alt="img"></p>
<p>从流程图可以看出，调用一个简单的send_command函数后，Netmiko默默帮我们做了非常多的事情，尤其是在“读取数据”的环节，做了很多特殊的处理，并且大家在执行命令的时候遇到问题，大多数都是在“读取数据”的环节出了问题，所以只有了解清楚Netmiko究竟做了哪些事情，才能在出问题的时候快速解决。</p>
<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>在向通道发送命令之后，会进入到读取通道的数据的逻辑，流程图如下所示：</p>
<p><img src="https://s2.loli.net/2023/04/08/qhEl5eADwjW2MRv.png" alt="img"></p>
<p>以上流程图中两个高亮的节点就是读取数据中比较核心的地方；</p>
<h3 id="read-timeout"><a href="#read-timeout" class="headerlink" title="read_timeout"></a>read_timeout</h3><p>超时时间的设置直接决定读取通道数据是否抛出异常，很多情况下获取不到返回结果都是由于超时导致。</p>
<h4 id="Netmiko4-x-x2F-5-x"><a href="#Netmiko4-x-x2F-5-x" class="headerlink" title="Netmiko4.x&#x2F;5.x"></a>Netmiko4.x&#x2F;5.x</h4><p>在Netmiko5.x中我们可以直接在调用<code>send_command</code>时传入<code>read_timeout</code>参数来指定此次命令执行超时时间，也可以在调用<code>ConnectHandler</code>创建连接的时候传入<code>read_timeout_override</code>参数来将其作为每次执行命令的超时时间。</p>
<h4 id="Netmiko3-x"><a href="#Netmiko3-x" class="headerlink" title="Netmiko3.x"></a>Netmiko3.x</h4><p>在创建连接的时候如果将<code>delay_factor_compat</code>置为True，则可以将超时时间的设置切换为Netmiko3.x的模式，而在Netmiko3.x中超时时间有不同的计算方法。read_timeout的值是由几个不同的变量共同决定的，公示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_timeout = max_loops * loop_delay * delay_factor</span><br></pre></td></tr></table></figure>

<p>如果除了要执行的命令，没传任何其他参数的话，那么这里的超时时间默认为100秒，计算方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_timeout = 500 * 0.2 * 1 = 100s</span><br></pre></td></tr></table></figure>

<p>同样也可以在调用<code>send_command</code>的时候通过传入<code>max_loops|loop_delay|delay_factor</code>来决定执行命令的超时时间。</p>
<h3 id="past-n-reads"><a href="#past-n-reads" class="headerlink" title="past_n_reads"></a>past_n_reads</h3><p><code>send_command</code>函数是通过判断是否返回内容中存在指定<code>pattern</code>来决定是否读取结束，但这个Netmiko做了一个特殊的机制来保护性能。</p>
<p>通过流程图可以知道，输出结果是通过循环读取通道来进行累加的，那么就会存在输出内容特别长的情况，所以Netmiko设置了一个<code>MAX_CHARS</code>变量，针对输出内容长度是否超过<code>MAX_CHARS</code>来做不同的处理，流程如下：</p>
<p><img src="https://s2.loli.net/2023/04/08/ghMPj74kDaIciyv.png" alt="img"></p>
<p>上面的流程看起来复杂，其实简单来说就是通过队列先进先出的特性，当output结果过长时，只对最近几次结果进行pattern匹配。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章节主要讲解了如何使用Netmiko进行设备连接，并执行show命令，但我想强调的是，这一章节的几行代码是次要的，最重要的是对于Netmiko收发数据机制的理解，只有理解了这部分逻辑，才能够对各种异常情况得心应手。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>Netmiko</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>2.3 自动化运维初级村-Netmiko-进阶</title>
    <url>/posts/f6ffcca1.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>上一章节中已经介绍了如何使用Netmiko创建连接，发送命令，并了解了Netmiko如何发送命令并接收数据，但只掌握这些还是远远不够的，实际的场景中会遇到各种各样的问题，诸如：设备类型问题，连接超时问题，执行超时问题等，这些问题其实Netmiko都有办法通过参数的调整来解决。</p>
<span id="more"></span>

<p>先回顾一下基础的代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;device_type&quot;</span>: <span class="string">&quot;cisco_ios&quot;</span>, </span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.31.149&quot;</span>, </span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;cisco&quot;</span>, </span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;cisco&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">net_connect = ConnectHandler(**params)</span><br><span class="line">cmd = <span class="string">&quot;show interface brief&quot;</span></span><br><span class="line">output = net_connect.send_command(cmd)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>

<h1 id="连接参数"><a href="#连接参数" class="headerlink" title="连接参数"></a>连接参数</h1><p>Netmiko中支持的不同厂商的连接对象<code>ConnectionClass</code>都是继承自一个基类<code>BaseConnection</code>，并且常见的几种厂商初始化连接对象的方式（即<code>__init__</code>方法）几乎都没有进行重写，也就是说我们目前只需要着重了解基类的初始化即可。</p>
<p>源码中的连接对象初始化参数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    ip: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    host: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    username: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    password: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    secret: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    port: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    device_type: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    verbose: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    global_delay_factor: <span class="built_in">float</span> = <span class="number">1.0</span>,</span></span><br><span class="line"><span class="params">    global_cmd_verify: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    use_keys: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    key_file: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    pkey: <span class="type">Optional</span>[paramiko.PKey] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    passphrase: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    disabled_algorithms: <span class="type">Optional</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    allow_agent: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    ssh_strict: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    system_host_keys: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    alt_host_keys: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    alt_key_file: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    ssh_config_file: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    <span class="comment">#</span></span></span><br><span class="line"><span class="params">    <span class="comment"># Connect timeouts</span></span></span><br><span class="line"><span class="params">    <span class="comment"># ssh-connect --&gt; TCP conn (conn_timeout) --&gt; SSH-banner (banner_timeout)</span></span></span><br><span class="line"><span class="params">    <span class="comment">#       --&gt; Auth response (auth_timeout)</span></span></span><br><span class="line"><span class="params">    conn_timeout: <span class="built_in">int</span> = <span class="number">10</span>,</span></span><br><span class="line"><span class="params">    <span class="comment"># Timeout to wait for authentication response</span></span></span><br><span class="line"><span class="params">    auth_timeout: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    banner_timeout: <span class="built_in">int</span> = <span class="number">15</span>,  <span class="comment"># Timeout to wait for the banner to be presented</span></span></span><br><span class="line"><span class="params">    <span class="comment"># Other timeouts</span></span></span><br><span class="line"><span class="params">    blocking_timeout: <span class="built_in">int</span> = <span class="number">20</span>,  <span class="comment"># Read blocking timeout</span></span></span><br><span class="line"><span class="params">    timeout: <span class="built_in">int</span> = <span class="number">100</span>,  <span class="comment"># TCP connect timeout | overloaded to read-loop timeout</span></span></span><br><span class="line"><span class="params">    session_timeout: <span class="built_in">int</span> = <span class="number">60</span>,  <span class="comment"># Used for locking/sharing the connection</span></span></span><br><span class="line"><span class="params">    read_timeout_override: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    keepalive: <span class="built_in">int</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">    default_enter: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    response_return: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    serial_settings: <span class="type">Optional</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    fast_cli: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    _legacy_mode: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    session_log: <span class="type">Optional</span>[SessionLog] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    session_log_record_writes: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    session_log_file_mode: <span class="built_in">str</span> = <span class="string">&quot;write&quot;</span>,</span></span><br><span class="line"><span class="params">    allow_auto_change: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    encoding: <span class="built_in">str</span> = <span class="string">&quot;utf-8&quot;</span>,</span></span><br><span class="line"><span class="params">    sock: <span class="type">Optional</span>[socket.socket] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    auto_connect: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    delay_factor_compat: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="literal">None</span>:</span><br></pre></td></tr></table></figure>

<p>大部分朋友可能看到这么多参数会非常头疼，我这里给大家做一个归类，就可以很好的掌握这些参数的作用了。</p>
<h2 id="参数分类"><a href="#参数分类" class="headerlink" title="参数分类"></a>参数分类</h2><table>
<thead>
<tr>
<th>类别</th>
<th>参数名</th>
<th>参数类型</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>基本参数</td>
<td>ip&#x2F;host</td>
<td>string</td>
<td>“”</td>
<td>两者必须填一个，作为远程设备的地址</td>
</tr>
<tr>
<td>device_type</td>
<td>string</td>
<td>“”</td>
<td>根据设备类型映射到对应的连接对象</td>
<td></td>
</tr>
<tr>
<td>认证参数</td>
<td>username</td>
<td>string</td>
<td>“”</td>
<td>对目标设备进行身份验证的用户名</td>
</tr>
<tr>
<td>password</td>
<td>string</td>
<td>None</td>
<td>对目标设备进行身份验证的密码</td>
<td></td>
</tr>
<tr>
<td>secret</td>
<td>string</td>
<td>“”</td>
<td>如果目标设备需要，则设置为enable的密码</td>
<td></td>
</tr>
<tr>
<td>use_keys</td>
<td>bool</td>
<td>False</td>
<td>使用SSH密钥连接目标设备</td>
<td></td>
</tr>
<tr>
<td>key_file</td>
<td>string</td>
<td>None</td>
<td>要使用的SSH密钥文件的文件名路径</td>
<td></td>
</tr>
<tr>
<td>pkey</td>
<td>paramiko.PKey</td>
<td>None</td>
<td>要使用的SSH密钥对象</td>
<td></td>
</tr>
<tr>
<td>passphrase</td>
<td>string</td>
<td>None</td>
<td>用于密钥的密码短语</td>
<td></td>
</tr>
<tr>
<td>disabled_algorithms</td>
<td>dict</td>
<td>None</td>
<td>要禁用的SSH算法字典</td>
<td></td>
</tr>
<tr>
<td>allow_agent</td>
<td>bool</td>
<td>False</td>
<td>启用SSH key-agent</td>
<td></td>
</tr>
<tr>
<td>ssh_strict</td>
<td>bool</td>
<td>False</td>
<td>自动拒绝未知的SSH主机密钥(默认值:False表示将接受未知的SSH主机密钥)。</td>
<td></td>
</tr>
<tr>
<td>system_host_keys</td>
<td>bool</td>
<td>False</td>
<td>从users known_hosts文件加载主机密钥</td>
<td></td>
</tr>
<tr>
<td>alt_host_keys</td>
<td>bool</td>
<td>False</td>
<td>如果’ True ‘主机密钥将从指定的文件加载alt_key_file。</td>
<td></td>
</tr>
<tr>
<td>alt_key_file</td>
<td>string</td>
<td>“”</td>
<td>要使用的SSH主机密钥文件(如果alt_host_keys&#x3D;True)</td>
<td></td>
</tr>
<tr>
<td>ssh_config_file</td>
<td>string</td>
<td>“”</td>
<td>OpenSSH配置文件文件名</td>
<td></td>
</tr>
<tr>
<td>serial_settings</td>
<td>Dict</td>
<td>None</td>
<td>串口连接的设置</td>
<td></td>
</tr>
<tr>
<td>超时参数(单位为秒)</td>
<td>conn_timeout</td>
<td>int</td>
<td>10</td>
<td>建立TCP连接的超时时间</td>
</tr>
<tr>
<td>auth_timeout</td>
<td>int</td>
<td>10</td>
<td>设置等待认证响应的超时时间</td>
<td></td>
</tr>
<tr>
<td>banner_timeout</td>
<td>int</td>
<td>15</td>
<td>等待banner出现的超时时间</td>
<td></td>
</tr>
<tr>
<td>blocking_timeout</td>
<td>int</td>
<td>20</td>
<td>阻塞读写操作的超时时间，如果有值则会在读写channel阻塞超时后抛出异常</td>
<td></td>
</tr>
<tr>
<td>timeout</td>
<td>int</td>
<td>20</td>
<td>可以用来调整改变读取通道的max_loops</td>
<td></td>
</tr>
<tr>
<td>session_timeout</td>
<td>int</td>
<td>60</td>
<td>设置并发请求的超时时间</td>
<td></td>
</tr>
<tr>
<td>read_timeout_override</td>
<td>float</td>
<td>None</td>
<td>用来覆盖读取超时的设置</td>
<td></td>
</tr>
<tr>
<td>global_delay_factor</td>
<td>float</td>
<td>1.0</td>
<td>影响读取通道间隔延迟的乘法因子(默认值:1)</td>
<td></td>
</tr>
<tr>
<td>delay_factor_compat</td>
<td>bool</td>
<td>False</td>
<td>设置send_command和send_command_timing使用Netmiko3.x中delay_factor&#x2F;global_delay_factor&#x2F;max_loops的行为。这在Netmiko 5中被淘汰x(默认值:False)</td>
<td></td>
</tr>
<tr>
<td>keepalive</td>
<td>int</td>
<td>0</td>
<td>按指定的时间间隔发送SSH keepalive报文，单位为秒</td>
<td></td>
</tr>
<tr>
<td>与读写通道相关的参数</td>
<td>global_cmd_verify</td>
<td>bool</td>
<td>None</td>
<td>控制是否启用或禁用命令回显验证(默认值:没有)。全局属性优先于函数“cmd_verify”论点。“None”的值表示使用函数“cmd_verify”参数</td>
</tr>
<tr>
<td>default_enter</td>
<td>string</td>
<td>“”</td>
<td>默认换行符(\n)</td>
<td></td>
</tr>
<tr>
<td>response_return</td>
<td>string</td>
<td>“”</td>
<td>在规范化返回数据中要表示的字符舒付(默认:\n)</td>
<td></td>
</tr>
<tr>
<td>fast_cli</td>
<td>bool</td>
<td>True</td>
<td>提供一种优化性能的方法。转换select_delay_factor选择最小的全局和特定。设置默认的global_delay_factor为0.1，这个值在Netmiko3.x中会影响到read_timeout的值</td>
<td></td>
</tr>
<tr>
<td>_legacy_mode</td>
<td>bool</td>
<td>False</td>
<td>逐行执行多条命令后，一起收集输出级过</td>
<td></td>
</tr>
<tr>
<td>session_log</td>
<td>SessionLog</td>
<td>None</td>
<td>用来写入会话日志的文件路径或BufferedIOBase子类对象。</td>
<td></td>
</tr>
<tr>
<td>session_log_record_writes</td>
<td>bool</td>
<td>False</td>
<td>会话日志通常只记录通道读操作，以消除命令回传造成的命令重复。如果你想在日志中都记录通道读和通道写，则需要将该值设为True</td>
<td></td>
</tr>
<tr>
<td>session_log_file_mode</td>
<td>string</td>
<td>write</td>
<td>session_log文件模式为write或append</td>
<td></td>
</tr>
<tr>
<td>allow_auto_change</td>
<td>bool</td>
<td>False</td>
<td>允许自动更改终端宽度的设置，部分继承了基类的连接对象会用到该值。</td>
<td></td>
</tr>
<tr>
<td>encoding</td>
<td>string</td>
<td>utf-8</td>
<td>向输出通道写入字节时使用的编码。</td>
<td></td>
</tr>
<tr>
<td>sock</td>
<td>socket</td>
<td>None</td>
<td>一个开放的套接字或类似套接字的对象(如’ . channel ‘)，用于与目标主机通信(默认:None)。</td>
<td></td>
</tr>
<tr>
<td>auto_connect</td>
<td>bool</td>
<td>True</td>
<td>是否在初始化连接对象后自动建立连接</td>
<td></td>
</tr>
</tbody></table>
<p>通过上面表格的分类，大家应该都对连接对象的参数有了清晰的认识，虽然每个分类里的参数都比较多，但并不是都需要全部用到，我这里只把常用的几个参数通过高亮标识里出来。</p>
<h2 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h2><p>连接设备必须的基本参数和认证参数就不做赘述了，大家可以根据自己的实际情况选择是用户名&#x2F;密码方式连接，还是密钥连接。</p>
<p>但超时参数里有几个参数是比较重要的。</p>
<ol>
<li>conn_timeout</li>
<li>auth_timeout</li>
<li>banner_timeout</li>
</ol>
<p>整个连接的建立过程存在几个可能会超时的节点，如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/08/QSAXg8rmVt59sYl.png" alt="img"></p>
<p>所以大家可以根据连接设备时具体的报错日志分析，超时异常出现在哪一个阶段，然后相应的调整连接超时参数即可。</p>
<h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><p>Netmiko发送命令的函数有很多个，分别适用于不同的场景，但今天我们以最为常用的<code>send_command</code>做为例子来讲解，因为其他的执行函数大多也都是基于该函数进行了封装，或者其参数与该函数的参数也基本类似。</p>
<p>源码中函数的参数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send_command</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    command_string: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    expect_string: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    read_timeout: <span class="built_in">float</span> = <span class="number">10.0</span>,</span></span><br><span class="line"><span class="params">    delay_factor: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    max_loops: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    auto_find_prompt: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    strip_prompt: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    strip_command: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    normalize: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    use_textfsm: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    textfsm_template: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    use_ttp: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    ttp_template: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    use_genie: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    cmd_verify: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Union</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="type">Any</span>], <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]]:</span><br></pre></td></tr></table></figure>

<p>其实源码中的类，函数，参数的作用都和实际的命名相关，所以大家可以多去翻译一下，这样不仅可以在后续编程的过程中养成良好的命名习惯，也可以慢慢的面对陌生的函数或参数大概猜到其用法。</p>
<h2 id="参数分类-1"><a href="#参数分类-1" class="headerlink" title="参数分类"></a>参数分类</h2><table>
<thead>
<tr>
<th>类别</th>
<th>参数名</th>
<th>参数类型</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>基本参数</td>
<td>command_string</td>
<td>string</td>
<td>“”</td>
<td>在设备上执行的命令</td>
</tr>
<tr>
<td></td>
<td>expect_string</td>
<td>string</td>
<td>None</td>
<td>用于判定输出结束的正则表达式&#x2F;字符串，如果不传则默认自动获取设备标识符</td>
</tr>
<tr>
<td>超时参数</td>
<td>read_timeout</td>
<td>float</td>
<td>10.0</td>
<td>循环读取通道的超时时间</td>
</tr>
<tr>
<td></td>
<td>delay_factor</td>
<td>float</td>
<td>None</td>
<td>确定超时时间延迟乘数，只有delay_factor_compat设为True时才使用，通常在Netmiko4.x&#x2F;5.x中不使用</td>
</tr>
<tr>
<td></td>
<td>max_loops</td>
<td>int</td>
<td>None</td>
<td>确定超时时间的最大循环次数，只有delay_factor_compat设为True时才使用，通常在Netmiko4.x&#x2F;5.x中不使用</td>
</tr>
<tr>
<td>格式化参数</td>
<td>auto_find_prompt</td>
<td>bool</td>
<td>True</td>
<td>自动获取设备标识</td>
</tr>
<tr>
<td></td>
<td>strip_command</td>
<td>bool</td>
<td>True</td>
<td>删除执行命令的回显信息，通常为删除结果的首行并处理特殊字符</td>
</tr>
<tr>
<td></td>
<td>strp_prompt</td>
<td>bool</td>
<td>True</td>
<td>从输出中删除末尾的路由器提示符</td>
</tr>
<tr>
<td></td>
<td>normalize</td>
<td>bool</td>
<td>True</td>
<td>去除command_string的多余空格并末尾添加换行符</td>
</tr>
<tr>
<td></td>
<td>cmd_verify</td>
<td>bool</td>
<td>True</td>
<td>在获取命令结果之前，验证命令回显，确保不会读取到无用的通道buffer数据</td>
</tr>
<tr>
<td>解析参数</td>
<td>use_textfsm</td>
<td>bool</td>
<td>False</td>
<td>通过TextFSM模板处理命令回显信息</td>
</tr>
<tr>
<td></td>
<td>textfsm_template</td>
<td>string</td>
<td>None</td>
<td>TextFSM模版的文件名</td>
</tr>
<tr>
<td></td>
<td>use_ttp</td>
<td>bool</td>
<td>False</td>
<td>通过TTP模板处理命令输出</td>
</tr>
<tr>
<td></td>
<td>ttp_template</td>
<td>string</td>
<td>None</td>
<td>TTP模版的文件名</td>
</tr>
<tr>
<td></td>
<td>use_genie</td>
<td>bool</td>
<td>False</td>
<td>通过PyATS&#x2F;Genie解析器处理命令输出</td>
</tr>
</tbody></table>
<h2 id="参数调整-1"><a href="#参数调整-1" class="headerlink" title="参数调整"></a>参数调整</h2><p>执行的命令的参数中大多数都是默认设置，并且都设为了True，也就是说大多数情况下都不需要修改；而需要根据实际情况修改的参数我也高亮标注了出来。</p>
<h5 id="read-timeout"><a href="#read-timeout" class="headerlink" title="read_timeout"></a>read_timeout</h5><p>这个函数之前已经提到了一次，在Netmiko5.x中可以直接用这个参数来调整循环读取通道的超时时间，不过通常的做法是设置一个较大的值，使其可以覆盖大多数的命令延迟，比如设为100。</p>
<p>如果实际确实有延迟很高的命令的话，再根据具体的命令适当修改read_timeout的值。</p>
<p>可能部分朋友会觉得直接设置一个5分钟或者10分钟，这样就可以覆盖所有命令了，没必要单独处理。</p>
<p>但如果真的某台设备出现故障，所有的命令都延迟极高，或者网络链路出现很大抖动，那么执行的命令会在一段时间内都获取不到结果，这种情况下超时时间都设为5分钟的话，就无法及时抛出超时异常，而是会陷入长时间的循环等待，这当然不是我们想要看到的。</p>
<p>所以对于异常情况，或者边界case的考虑也是需要大家在学习和运用的过程中锻炼提高的。</p>
<h5 id="expect-string"><a href="#expect-string" class="headerlink" title="expect_string"></a>expect_string</h5><p>由于<code>auto_find_prompt</code>参数默认设为了True，所以即使不传递expect_string，也可以自动获取到设备标识符做为<code>search_pattern</code>。</p>
<p>对于特殊的命令的话，我们可以修改该参数，使其作为判定循环读取结束的正则表达式，但大多数命令其实都是用的设备标识符做的<code>search_pattern</code>。</p>
<p>所以我的建议是这里直接将<code>expect_string</code>设置为<code>self.base_prompt</code>，或者将<code>auto_find_prompt</code>设置为<code>False</code>，因为在连接建立后的<code>session_preparation</code>函数里获取了设备标识符作为<code>base_prompt</code>，所以<code>send_command</code>函数自动获取的标识符同样也是发送换行符后获取的设备标识符，设置调用的函数都是同一个<code>find_prompt</code>，所以我们大多数情况下可以直接穿入<code>self.base_prompt</code>作为<code>search_pattern</code>，这样就可以每条命令都减少一次自动获取标识符时产生的与设备的交互，对于提高性能来说会有不小的帮助。</p>
<h1 id="基于时间的命令执行"><a href="#基于时间的命令执行" class="headerlink" title="基于时间的命令执行"></a>基于时间的命令执行</h1><p>上面提到<code>send_command</code>是使用最为普遍的一个执行命令函数，它是基于字符串匹配决定是否输出结束，但对于部分命令，我们无法准确的定义它的<code>expect_string</code>，这时候我们就需要另一种方式来获取它的执行结果，那就是<code>send_command_timing</code>，这个函数是一种基于时间机制的命令执行函数。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>这个函数的参数与<code>send_command</code>中的参数几乎完全一致，只额外多了一个<code>last_read</code>参数，这个参数会对是否结束循环起到关键性的作用。</p>
<p>除此之外，<code>read_timeout</code>时间也从默认的100s改为了默认120s。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://s2.loli.net/2023/04/08/eTPDgsI6fxrt2CX.png" alt="img"></p>
<p>基于时间的机制中，循环读取通道数据后，已经不需要设置<code>last_n_reads</code>队列来提高性能来，因为时间机制下，完全没有做任何的字符匹配，而是单纯通过<code>last_read</code>这一变量来判断是否输出结束。</p>
<p>最为关键的一个节点我已经高亮标注了出来，其实核心的逻辑就是：</p>
<p>循环读取通道时，当此次没有读取到任何数据，那么就说明有可能已经输出结束了，那么此时休眠<code>last_read</code>秒之后再读取一次，如果还没有数据，就判定为结束，如果又读到了数据，那么上一次没读到数据就有可能是设备或网络延迟造成的，则再次进入循环。</p>
<h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p><code>send_command_timing</code>是基于时间机制来判定输出结束的，所以我们能调整的就是两个参数：</p>
<h3 id="read-timeout-1"><a href="#read-timeout-1" class="headerlink" title="read_timeout"></a>read_timeout</h3><p>当执行的命令返回内容输出较长时，则需要循环更多次才能读取到全部结果，这时候就需要调大<code>read_timeout</code>，避免抛出超时异常。</p>
<h3 id="last-read"><a href="#last-read" class="headerlink" title="last_read"></a>last_read</h3><p>当执行的命令需要较长时间延迟才能输出回显结果时，可能会造成某次循环在<code>last_read</code>时间内从通道中读取不到任何数据，导致提前结束循环，获取不到全部的结果，所以这时候需要调大<code>last_read</code>参数。</p>
<h1 id="执行命令（配置）"><a href="#执行命令（配置）" class="headerlink" title="执行命令（配置）"></a>执行命令（配置）</h1><p>对于网络设备来说，在不同的模式下可以执行不同的命令，show类型的命令通常都在用户模式或特权模式执行，而配置命令的话必须要在配置模式执行；</p>
<p>那么对于不同的设备进入配置模式的方式也都不尽相同，既然Netmiko能够支持不同厂商的设备，就理所应当也适配了该类型设备进入配置模式的方法。</p>
<p>关于配置模式相关的函数如下：</p>
<ul>
<li>self.check_config_mode: 调用该函数可以检查当前是否在配置模式下，返回一个bool值</li>
<li>self.config_mode：调用函数可以进入设备的配置模式</li>
<li>self.exit_config_mode: 调用该函数可以退出配置模式</li>
</ul>
<p>通常执行配置类型的命令需要：进入配置模式 -&gt; 执行命令 -&gt; 退出配置模式，而Netmiko就为我们提供了一个封装好的方法：</p>
<h2 id="send-config-set"><a href="#send-config-set" class="headerlink" title="send_config_set"></a>send_config_set</h2><p>源码中的参数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send_config_set</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    config_commands: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="type">Sequence</span>[<span class="built_in">str</span>], Iterator[<span class="built_in">str</span>], TextIO, <span class="literal">None</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    *,</span></span><br><span class="line"><span class="params">    exit_config_mode: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    read_timeout: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    delay_factor: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    max_loops: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    strip_prompt: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    strip_command: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    config_mode_command: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    cmd_verify: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    enter_config_mode: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">    error_pattern: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    terminator: <span class="built_in">str</span> = <span class="string">r&quot;#&quot;</span>,</span></span><br><span class="line"><span class="params">    bypass_commands: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br></pre></td></tr></table></figure>

<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><table>
<thead>
<tr>
<th>参数名</th>
<th>参数类型</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>config_commands</td>
<td>多种</td>
<td>None</td>
<td>要执行的配置命令</td>
</tr>
<tr>
<td>exit_config_mode</td>
<td>bool</td>
<td>True</td>
<td>执行完配置命令之后是否退出配置模式</td>
</tr>
<tr>
<td>read_timeout</td>
<td>float</td>
<td>None</td>
<td>如果不传该参数会默认设置为15s，</td>
</tr>
<tr>
<td>config_mode_command</td>
<td>string</td>
<td>None</td>
<td>进入配置模式的命令，各厂商会在自己的连接类里定义</td>
</tr>
<tr>
<td>cmd_verify</td>
<td>bool</td>
<td>True</td>
<td>每条配置命令都验证是否输出命令echo</td>
</tr>
<tr>
<td>enter_config_mode</td>
<td>bool</td>
<td>True</td>
<td>是否进入配置模式，默认进入</td>
</tr>
<tr>
<td>error_pattern</td>
<td>string</td>
<td>“”</td>
<td>输出结果出现匹配字符串时视为执行异常</td>
</tr>
<tr>
<td>terminator</td>
<td>string</td>
<td>r’#’</td>
<td>配置模式下判定命令输出结束的正则字符串</td>
</tr>
<tr>
<td>bypass_commands</td>
<td>string</td>
<td>None</td>
<td>与要执行的命令匹配，如果匹配成功则关闭cmd_verify功能</td>
</tr>
</tbody></table>
<p>上述参数虽然比较多，但都较好理解，部分参数我也会在视频中更通俗易懂的讲解一下，但这个函数封装的比较完善，绝大多数情况都只需要传递<code>config_command</code>即可，该参数的值可以是字符串，或数组。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章节主要是对Netmiko中的核心函数的讲解，这些函数的参数也都给大家分类展示了出来，更容易理解和使用，但还是需要从实践中加深理解；而且Netmiko的封装过程都是基于网络设备的交互逻辑，所以大家也不需要死记硬背，只要结合网络运维的经验即可理解掌握。</p>
<p>下一章节我会给大家代入一个简单的巡检场景，讲解如何真正编写一个健壮的与网络设备交互的代码。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>Netmiko</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>2.4 自动化运维初级村-Netmiko-巡检-1</title>
    <url>/posts/937e7568.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>人工定期巡检，应该是大多数做运维工作的朋友的一大心病，面对几十上百台机器，执行相同的命令，要仔细得从输出里提取信息，然后把最终的结果整理到Excel里，发一份邮件抄送老板。</p>
<p>我刚开始工作时巡检也是平台规划中优先级较高的一个模块，需要提供灵活的设备筛选，执行用户指定的命令，应用相应的解析规则，最终把结果导出成Excel。</p>
<p>大多数系统的巡检模块也都具备这些功能，那么今天我们就一起来做一个简易的巡检工具，带着大家边实践边趟一趟用Netmiko巡检的坑。</p>
<span id="more"></span>

<h1 id="巡检工具"><a href="#巡检工具" class="headerlink" title="巡检工具"></a>巡检工具</h1><p>这里要说一点的是，不管做什么需求，无论是大到系统的设计，还是一个小的脚本，在动手做之前都需要提前做好充分的思考，思考究竟要实现什么功能，这些功能都会涉及到哪些东西，是否需要引入中间件，比如数据库，缓存库等。</p>
<p>如果盲目的开始动手，那么后果就是一直修修改改，既想要这个功能，又想新加那个功能，而由于没有做好充分的设计，而导致扩展性很差，最后堆成了“屎山”；这也是在做功能模块之前需要编写方案设计文档和技术评审的主要原因。</p>
<h2 id="模块设计图"><a href="#模块设计图" class="headerlink" title="模块设计图"></a>模块设计图</h2><p><img src="https://s2.loli.net/2023/04/08/hQuMan3L8oScINz.png" alt="img"></p>
<p>上述流程图就是我们要实现的巡检工具的大概功能设计。</p>
<h2 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h2><h3 id="设备筛选"><a href="#设备筛选" class="headerlink" title="设备筛选"></a>设备筛选</h3><p>在新手村中我们曾经讲解过一个简易的CMDB，即支持从json文件中读写设备信息，也支持从MySQL数据库中读写设备信息，那么这个CMDB功能就可以为我们提供设备筛选的能力，而恰好实际工作中，CMDB同样是会承担这个作用。</p>
<h2 id="命令筛选"><a href="#命令筛选" class="headerlink" title="命令筛选"></a>命令筛选</h2><p>由于不同厂商的设备执行的巡检命令会不一样，例如同一个查看镜像版本的操作，可能会对应不同的具体指令；那么我们就需要先根据不同厂商录入好相应的命令，然后巡检的时候可以根据具体要检查的指标项来筛选命令。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>整个巡检工具中最为关键的就是执行器，我们需要实现一个封装好的执行器对象，这个对象对外暴露参数以供其他模块传入；并且它是一个较为抽象的对象，并不是单指通过SSH方式来执行操作，也可以是以API的形式调用厂商API，或者以Netconf的方式对设备进行相应的操作。</p>
<h2 id="解析规则筛选"><a href="#解析规则筛选" class="headerlink" title="解析规则筛选"></a>解析规则筛选</h2><p>执行器进行相应的操作之后的回显通常都需要提取关键信息，尤其是以SSH的方式执行完命令后，因此需要针对不同的命令录入其解析规则，这个规则可以是正则表达式，也可以是TextFSM模版，这样就可以在执行完命令之后直接根据相应的规则解析出结构化的数据。</p>
<h2 id="保存结果"><a href="#保存结果" class="headerlink" title="保存结果"></a>保存结果</h2><p>巡检的结果需要进行持久化存储，我们可以选择将其保存到MySQL数据库中，并且保存的内容除了处理完的结构化数据之外，也需要将原始输出进行存储，方便后续追溯。</p>
<h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>当需要将结果展示或者发送的时候，需要具有导出的功能，具体的细节就是在一定的时间范围内，根据设备和指标项来把之前持久化的数据导出成Excel或CSV。</p>
<h1 id="方案细节"><a href="#方案细节" class="headerlink" title="方案细节"></a>方案细节</h1><h2 id="设备筛选-1"><a href="#设备筛选-1" class="headerlink" title="设备筛选"></a>设备筛选</h2><p>暂且忽略，后续补充</p>
<h2 id="执行器-1"><a href="#执行器-1" class="headerlink" title="执行器"></a>执行器</h2><p>由于最近的几个章节都在讲解关于Netmiko相关的知识，并且执行器中最为重要的远程执行命令行这一动作，但前期为了便于理解，我们不对执行器做过多的设计，单纯只实现SSH类型的执行器，</p>
<p>执行器必须要具备的几个功能如下：</p>
<ul>
<li>初始化执行器</li>
<li>获取目标对象</li>
<li>获取执行动作</li>
<li>执行</li>
<li>解析执行结果</li>
<li>保存执行结果</li>
</ul>
<p>基本代码框架如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Executor_Mapping = &#123;</span><br><span class="line">    <span class="string">&quot;SSH&quot;</span>: SSHExecutor,  <span class="comment"># SSH执行器对象</span></span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Executor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, executor_type, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> Executor_Mapping.get(executor_type):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;has no %s executor&quot;</span> % executor_type)</span><br><span class="line">        self.executor = Executor_Mapping[executor_type](*args, **kwargs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fetch_object</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fetch_action</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_result</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="SSH执行器"><a href="#SSH执行器" class="headerlink" title="SSH执行器"></a>SSH执行器</h3><p>SSH执行器必须要具备的几个功能如上述执行器对象所需的相同。</p>
<h4 id="初始化执行器（建立连接）"><a href="#初始化执行器（建立连接）" class="headerlink" title="初始化执行器（建立连接）"></a>初始化执行器（建立连接）</h4><p>上一章节中的SSH连接代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;device_type&quot;</span>: <span class="string">&quot;cisco_ios&quot;</span>, </span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.31.149&quot;</span>, </span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;cisco&quot;</span>, </span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;cisco&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">net_connect = ConnectHandler(**params)</span><br></pre></td></tr></table></figure>

<p>首先我们需要对连接时的可能存在的异常进行处理，一般的做法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    conn = ConnectHandler(**device)</span><br><span class="line"><span class="keyword">except</span> NetmikoAuthenticationException:</span><br><span class="line">    <span class="comment"># TODO</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">except</span> NetmikoTimeoutException:</span><br><span class="line">    <span class="comment"># TODO</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="comment"># TODO</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="built_in">print</span>(conn.find_prompt()) </span><br></pre></td></tr></table></figure>

<p>大家可以发现上述代码中的异常分别为<code>NetmikoAuthenticationException</code>、<code>NetmikoTimeoutException</code>、<code>Exception</code>；其中Exception类是Python中的最底层Exception，所有的自定义Exception都需要继承Exception基类，Netmiko库中也会自定义一些异常类，这里的前两个异常类就分别是认证异常类和超时异常类。</p>
<p>自定义异常类必须写在异常基类的前面才能被捕获。</p>
<p>通常情况下会在捕获到异常之后，打印堆栈及错误信息，或者将其记录到日志文件中。</p>
<p>这一点Netmiko显然也有考虑，所以专门提供了针对设备连接阶段的异常捕获，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnUnify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;device_type&quot;</span>: <span class="string">&quot;cisco_ios&quot;</span>, </span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.31.149&quot;</span>, </span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;cisco&quot;</span>, </span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;cisco&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">conn = ConnUnify(**params)</span><br><span class="line"><span class="keyword">if</span> conn <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    sys.exit(<span class="string">&quot;Logging in failed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(conn.find_prompt())</span><br><span class="line">conn.disconnect() </span><br></pre></td></tr></table></figure>

<p><code>ConnUnify</code>函数的作用就是捕获设备连接过程中各种异常；</p>
<p>该函数的核心代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ConnUnify</span>(<span class="params"></span></span><br><span class="line"><span class="params">    **kwargs: <span class="type">Any</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="string">&quot;BaseConnection&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        kwargs[<span class="string">&quot;auto_connect&quot;</span>] = <span class="literal">False</span></span><br><span class="line">        net_connect = ConnectHandler(**kwargs)</span><br><span class="line">        hostname = net_connect.host</span><br><span class="line">        port = net_connect.port</span><br><span class="line">        device_type = net_connect.device_type</span><br><span class="line">        general_msg = <span class="string">f&quot;Connection failure to <span class="subst">&#123;hostname&#125;</span>:<span class="subst">&#123;port&#125;</span> (<span class="subst">&#123;device_type&#125;</span>)\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">        net_connect._<span class="built_in">open</span>()</span><br><span class="line">        <span class="keyword">return</span> net_connect</span><br><span class="line">    <span class="keyword">except</span> NetmikoAuthenticationException <span class="keyword">as</span> e:</span><br><span class="line">        msg = general_msg + <span class="built_in">str</span>(e)</span><br><span class="line">        <span class="keyword">raise</span> ConnectionException(msg)</span><br><span class="line">    <span class="keyword">except</span> NetmikoTimeoutException <span class="keyword">as</span> e:</span><br><span class="line">        msg = general_msg + <span class="built_in">str</span>(e)</span><br><span class="line">        <span class="keyword">raise</span> ConnectionException(msg)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        msg = <span class="string">f&quot;An unknown exception occurred during connection:\n\n<span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> ConnectionException(msg)</span><br></pre></td></tr></table></figure>

<p>在<code>try...except</code>中提取了关键字参数中的主机信息，以便打印日志时使用，除此之外，可能有朋友会对高亮处有疑惑：</p>
<p>明明在<code>BaseConnection</code>中创建连接对象的<code>__init__</code>函数中，<code>auto_connect</code>参数默认为True，会默认调用<code>_open()</code>函数；为什么在<code>ConnLogOnly</code>中要专门把<code>auto_connect</code>设为False，然后在下面单独的调用<code>net_connect._open()</code>函数呢？</p>
<p>我个人的理解是因为<code>ConnectionHandler</code>其实是一个工厂函数，它的作用就是保证根据设备类型返回创建好的连接对象，这个连接对象只要继承了<code>BaseConnection</code>就可以，但子类继承父类时，可以重写其<code>__init__</code>方法，所以可能会存在（或者不保证永远不存在）某个连接对象，在初始化连接对象时不进行<code>_open()</code>，而是在后续再额外发起连接；</p>
<p>如果一旦出现上述情况，那么在对<code>ConnectHandler</code>进行异常捕获时就会无法捕获到建立连接时的异常现象，导致程序中断，这也是为什么这里会显示地调用<code>_open()</code>来建立连接的原因，目的就是为了保证这个<code>try...except</code>一定可以捕获到连接异常。</p>
<p>SSHExecutor的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        host: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">        username: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">        password: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        secret: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">        port: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        device_type: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">        conn_timeout: <span class="built_in">int</span> = <span class="number">10</span>,</span></span><br><span class="line"><span class="params">        auth_timeout: <span class="built_in">int</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        banner_timeout: <span class="built_in">int</span> = <span class="number">15</span>,</span></span><br><span class="line"><span class="params">        log_file: <span class="built_in">str</span> = <span class="string">&quot;ssh_executor.log&quot;</span>,</span></span><br><span class="line"><span class="params">        log_level: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        log_format: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self.secret = secret</span><br><span class="line">        self.device_type = device_type</span><br><span class="line">        self.conn_timeout = conn_timeout</span><br><span class="line">        self.auth_timeout = auth_timeout</span><br><span class="line">        self.banner_timeout = banner_timeout</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">import</span> logging</span><br><span class="line">        <span class="keyword">if</span> log_level <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            log_level = logging.ERROR</span><br><span class="line">        <span class="keyword">if</span> log_format <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            log_format = <span class="string">&quot;%(asctime)s %(levelname)s %(name)s %(message)s&quot;</span></span><br><span class="line"></span><br><span class="line">        logging.basicConfig(filename=log_file, level=log_level, <span class="built_in">format</span>=log_format)</span><br><span class="line">        self.logger = logging.getLogger(__name__)</span><br><span class="line">        self.conn = self.connect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn = ConnUnify(**self.__dict__)</span><br><span class="line">            msg = <span class="string">f&quot;Netmiko connection successful to <span class="subst">&#123;self.host&#125;</span>:<span class="subst">&#123;self.port&#125;</span>&quot;</span></span><br><span class="line">            self.logger.info(msg)</span><br><span class="line">            <span class="keyword">return</span> conn</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            self.logger.error(<span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

<p>初始化函数冲需要传入一个关键参数<code>log_file</code>，该参数表示连接过程中的日志输出文件，包括Info日志或者Error日志；如果不传的话默认会保存在同级目录下的ssh_executor.log文件中。</p>
<p>如果有需要还可以传入<code>log_level</code>修改日志打印等级，默认为只打印Error等级，或者传入<code>log_format</code>来修改日志格式</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章节主要给大家讲解了如何设计一个巡检模块，并对其中的基本组成做了初步的介绍，尤其是针对初始化SSH执行器做了较为深入的讲解，下一章节我们继续巡检模块的讲解，带领大家实现设备和命令的获取。</p>
]]></content>
      <tags>
        <tag>Netmiko</tag>
        <tag>SSH</tag>
        <tag>巡检</tag>
      </tags>
  </entry>
  <entry>
    <title>2.5 自动化运维初级村-Netmiko-巡检-2</title>
    <url>/posts/4d64d229.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>上一章节中讲解了巡检的设计方案，并实现了SSH执行器的连接功能，不过更为重要的还是希望培养大家一些基础的编程思想和良好的习惯；那么这一章节会着重讲解获取命令和设备的功能，并逐步完善SSH执行器。</p>
<p>一方面由于部分朋友第一次接触较为复杂的模块设计，其次这几个章节中还包含一些Python中较高级的用法，为了让大家便于理解，就先以文件为存储介质，实现命令筛选和设备筛选，后续的话会扩展到与Flask结合，并使用ORM来操作MySQL实现这些功能。</p>
<span id="more"></span>

<h1 id="命令筛选"><a href="#命令筛选" class="headerlink" title="命令筛选"></a>命令筛选</h1><p>由于是巡检的场景，所以必然是有不同的巡检项的，这些巡检项不需要使用实际的命令行表示，而是统一使用通俗易懂的文字代替，比如：fans_check、power_check等，这样不同厂商实际的命令行就可以对外屏蔽了。</p>
<p>获取命令可以分为两种实现方式，分别是JSON文件和MySQL存储下的数据读写（本章节以JSON文件为主）；虽然是两种实现方式，但理论上它们都应该具备“增删改查”的功能，这就恰好可以应用之前讲到的面向对象中的继承的概念。</p>
<p>首先定义一个<code>ActionHandler</code>表示存储命令的抽象类，该类具有增删改查数据的方法，另外再分别实现<code>ActionJSONHandler</code>和<code>ActionDBHandler</code>继承自<code>ActionHandler</code>。这样的话后续进行命令筛选就不需要区分JSON还是DB类型，因为它们两个都是ActionHandler类型.</p>
<h2 id="ActionHandler："><a href="#ActionHandler：" class="headerlink" title="ActionHandler："></a>ActionHandler：</h2><p>定义一个具备读写方法的抽象类如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActionHandler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, condition</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>上述代码定义了ActionHandler的初始化及增删改查方法，我们想要的效果是：不管什么存储介质，只要继承了ActionHandler并且实现它所有的实例方法即可。但怎么可以保证所有子类都实现这些方法呢？万一不小心忘了怎么办，或者别人接手代码不知道这个规则又怎么办？可能会导致代码异常，并且还较难察觉，而且基于Python解释型语言的特性，运行时才会抛出异常，这种情况显然不是我们想看到的。</p>
<p>但这个问题有办法可以解决，只需要对上述代码加一点点细节即可。</p>
<h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># action.py</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span>:</span><br><span class="line">    name = <span class="string">&quot;&quot;</span></span><br><span class="line">    description = <span class="string">&quot;&quot;</span></span><br><span class="line">    vendor = <span class="string">&quot;&quot;</span></span><br><span class="line">    model = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    parse_type = <span class="string">&quot;&quot;</span></span><br><span class="line">    parse_content = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionHandler</span>(abc.ABC):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, data: <span class="type">List</span>[<span class="type">Dict</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, data: <span class="type">Dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, data: <span class="type">Dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span></span>) -&gt; <span class="type">List</span>[Action]:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>上面的代码看起来好像跟之前章节中写的Python代码有些不一样，多了很多陌生的东西，下面我们就依次来给大家进行讲解。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>上述代码将ActionHandler定义为了抽象类，并且初始化及增删改查方法都定义成了抽象方法，这时候如果某个类继承了它，但没有实现任意一个方法，那么就会IDE会有提示，并且还会及时抛出异常；</p>
<p>Python中有关于抽象类的工具包——abc（Abstract Base Classes），继承了abc.ABC的类不可被实例化（实际上也不需要被实例化，因为它只是我们规范命令存储对象的抽象类），同时添加了<code>abc.abstractmethod</code>装饰器的方法必须被子类实现，如果编写代码时某个子类未实现其中某个方法，IDE则会出现如下飘黄报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class ActionJSONMarket must implement all abstract methods </span><br></pre></td></tr></table></figure>

<p>抽象类的使用在很多第三方库的源码中比较常见，Netmiko中就有用到，<code>netmiko.Channel</code>就是一个抽象基类，要求子类必须实现初始化和读写通道的方法，<code>netmiko.SSHChannel</code>和<code>netmiko.TelnetChannel</code>都继承了<code>Channel</code>基类。</p>
<p>所以在阅读源码的过程中也可以不断的学习到Python的一些高阶技巧，让我们能够把自己的代码编写的更为健壮和可扩展。</p>
<h4 id="函数和变量注解"><a href="#函数和变量注解" class="headerlink" title="函数和变量注解"></a>函数和变量注解</h4><p>由于Python是动态语言类型，变量的命名和实际变量指向的对象保存在内存的不同地方，所以在3.5版本之前，变量只是一个名字，它并没有类型，但变量指向的实际对象是有类型的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var1 = <span class="number">1</span>  <span class="comment"># 整型</span></span><br><span class="line">var1 = <span class="string">&quot;1&quot;</span>  <span class="comment"># 字符串</span></span><br></pre></td></tr></table></figure>

<p>上述代码var1先后从整数变成了字符串，但并不是改变的var1的类型，而是改变了var1的引用对象。</p>
<p>基于上述原因Python会给人一种上手很简单，代码写起来很快的错觉；但应用在大型项目中的时候，就会阅读和维护起来很抓狂，尤其是多人协作时，由于类型信息丢失，看到一个函数或方法，都不知道如何传递参数，该函数会返回什么结果。所以使得代码并不健壮，也不易维护。</p>
<p>在Python3.5和3.6版本先后加入了函数注解和类型注解，不过注解也只是给IDE和人看的，实际运行中并不会进行强制校验；但可以结合pylint对代码做检查，这样对代码的可靠性起到不小的帮助。</p>
<p>后续由于模块的代码量变多，非常有必要引入注解，但注解也并不复杂，所有的类型都在<code>typing</code>内置库中可以找到，而且常用的也不多，大家可以慢慢熟悉（我也会在视频中提到）。</p>
<h3 id="ActionJSONHandler"><a href="#ActionJSONHandler" class="headerlink" title="ActionJSONHandler"></a>ActionJSONHandler</h3><p>可以利用JSON文件作为存储介质，实现命令的读写，数据格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// action.json</span></span><br><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fans_check&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;风扇检查&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;vendor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;h3c&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;display fans&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;show&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;regexp&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fans_check&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;风扇检查&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;vendor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;h3c&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;display fans&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;show&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;textfsm&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fans_check&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;风扇检查&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;vendor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nexus&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;show fans&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;show&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;regexp&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fans_check&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;风扇检查&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;vendor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cisco&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ios&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;show fans&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;show&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;regexp&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fans_check&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;风扇检查&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;vendor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;huawei&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;display fans&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;show&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;regexp&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parse_content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span>:</span><br><span class="line">    name = <span class="string">&quot;&quot;</span></span><br><span class="line">    description = <span class="string">&quot;&quot;</span></span><br><span class="line">    vendor = <span class="string">&quot;&quot;</span></span><br><span class="line">    model = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    parse_type = <span class="string">&quot;&quot;</span></span><br><span class="line">    parse_content = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_model</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line">        action = Action()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(action, k):</span><br><span class="line">                <span class="built_in">setattr</span>(action, k, v)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> json.dumps(self.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionHandler</span>(abc.ABC):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, data: <span class="type">List</span>[<span class="type">Dict</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, data: <span class="type">Dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, data: <span class="type">Dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span></span>) -&gt; <span class="type">List</span>[Action]:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionJSONHandler</span>(<span class="title class_ inherited__">ActionHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, location: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param location: 文件的路径</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> os</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(location):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;%s path has no exists&quot;</span> % location)</span><br><span class="line">        self.path = location</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, data: <span class="type">List</span>[<span class="type">Dict</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param data: List[Dict] 保存的数据</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.path, <span class="string">&quot;r+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                _data = json.load(f)</span><br><span class="line">                _data.extend(data)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.path, <span class="string">&quot;w+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                json.dump(_data, f, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;save action failed, error: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, condition: <span class="type">Dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param condition: List[str] 删除的命令</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.path, <span class="string">&quot;r+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                _data = json.load(f)</span><br><span class="line">                _data: <span class="type">List</span>[<span class="type">Dict</span>]</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.path, <span class="string">&quot;w+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                result = []</span><br><span class="line">                <span class="keyword">for</span> idx, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(_data):</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">for</span> k, v <span class="keyword">in</span> condition.items():</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> v <span class="keyword">or</span> item[k] != v:</span><br><span class="line">                            flag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                        result.append(item)</span><br><span class="line">                json.dump(result, f, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;delete action failed, error: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, data: <span class="type">Dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param data: List[Dict] 更新的数据</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span></span>) -&gt; <span class="type">List</span>[Action]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param condition: Dict[Str, Any] 筛选条件</span></span><br><span class="line"><span class="string">        :return: List[Dict]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.path, <span class="string">&quot;r+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                data = json.load(f)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> condition:</span><br><span class="line">                    <span class="keyword">return</span> [Action.to_model(**item) <span class="keyword">for</span> item <span class="keyword">in</span> data]</span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">                    <span class="keyword">for</span> k, v <span class="keyword">in</span> condition.items():</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> v:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="keyword">if</span> item[k] != v:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        result.append(Action.to_model(**item))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;search action by condition failed, error: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>上述代码就是通过JSON文件来实现命令的增删改查，可以通过以下方法测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># action.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    action_json = ActionJSONHandler(<span class="string">&quot;action.json&quot;</span>)</span><br><span class="line">    <span class="comment"># res = action_json.get(&#123;&quot;vendor&quot;: &quot;cisco&quot;, &quot;model&quot;: &quot;nexus&quot;&#125;)  # get by conditions</span></span><br><span class="line">    <span class="comment"># action_json.add([&#123; &quot;name&quot;: &quot;fans_check&quot;, &quot;description&quot;: &quot;风扇检查&quot;, &quot;vendor&quot;: &quot;huawei&quot;, &quot;model&quot;: &quot;&quot;, &quot;cmd&quot;: &quot;display fans&quot;, &quot;type&quot;: &quot;show&quot;, &quot;parse_type&quot;: &quot;regexp&quot;, &quot;parse_content&quot;: &quot;&quot; &#125;])</span></span><br><span class="line">    <span class="comment"># action_json.delete(&#123;&quot;cmd&quot;: &quot;display fans&quot;, &quot;vendor&quot;: &quot;h3c&quot;&#125;)</span></span><br><span class="line">    res = action_json.get()</span><br><span class="line">    <span class="built_in">print</span>(res[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h1 id="设备筛选"><a href="#设备筛选" class="headerlink" title="设备筛选"></a>设备筛选</h1><p>之前的章节中已经将设备的数据保存到了MySQL数据库中，并使用ORM来进行了增删改查的操作；有朋友向我咨询问题的过程中谈到觉得ORM要比SQL更复杂，那么这一章节，我就用原生SQL来实现一下设备筛选，大家也可以自行判断一下究竟是哪个更为简单易用。</p>
<h2 id="DeviceHandler"><a href="#DeviceHandler" class="headerlink" title="DeviceHandler"></a>DeviceHandler</h2><p>同样定义一个具备增删改查方法的抽象类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># device.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceHandler</span>(abc.ABC):</span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, data: <span class="type">List</span>[<span class="type">Dict</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, data: <span class="type">Dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, data: <span class="type">Dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span></span>) -&gt; <span class="type">List</span>[Device]:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="DeviceDBHandler"><a href="#DeviceDBHandler" class="headerlink" title="DeviceDBHandler"></a>DeviceDBHandler</h3><p>原先存在两张设备表，分别是devices和device_detail，现在需要修改一下device_detail，增加两列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> device_detail <span class="keyword">add</span> <span class="keyword">column</span> (device_type <span class="type">varchar</span>(<span class="number">32</span>), channel <span class="type">varchar</span>(<span class="number">8</span>));</span><br><span class="line"># device.py</span><br><span class="line">import pymysql</span><br><span class="line"><span class="keyword">from</span> pymysql.cursors import <span class="keyword">Cursor</span>, DictCursor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Device:</span><br><span class="line">    ip <span class="operator">=</span> &quot;&quot;</span><br><span class="line">    hostname <span class="operator">=</span> &quot;&quot;</span><br><span class="line">    vendor <span class="operator">=</span> &quot;&quot;</span><br><span class="line">    model <span class="operator">=</span> &quot;&quot;</span><br><span class="line">    hardware <span class="operator">=</span> &quot;&quot;</span><br><span class="line">    channel <span class="operator">=</span> &quot;ssh&quot;</span><br><span class="line">    channel_port <span class="operator">=</span> <span class="number">22</span></span><br><span class="line">    device_type <span class="operator">=</span> &quot;&quot;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@classmethod</span></span><br><span class="line">    def to_model(cls, <span class="operator">*</span><span class="operator">*</span>kwargs):</span><br><span class="line">        device <span class="operator">=</span> Device()</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            if hasattr(device, k):</span><br><span class="line">                setattr(device, k, v)</span><br><span class="line">        if device.channel <span class="operator">=</span><span class="operator">=</span> &quot;telnet&quot;:</span><br><span class="line">            device.channel_port <span class="operator">=</span> <span class="number">23</span></span><br><span class="line">        <span class="keyword">return</span> device</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        <span class="keyword">return</span> json.dumps(self.__dict__)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"> class DeviceDBHandler(DeviceHandler):</span><br><span class="line">    def __init__(self, <span class="keyword">user</span>: str, password: str, host: str, database: str, port: <span class="type">int</span> <span class="operator">=</span> <span class="number">3306</span>) <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">None</span>:</span><br><span class="line">        self.conn <span class="operator">=</span> pymysql.connect(<span class="keyword">user</span><span class="operator">=</span><span class="keyword">user</span>, password<span class="operator">=</span>password, host<span class="operator">=</span>host, port<span class="operator">=</span>port, database<span class="operator">=</span>database, cursorclass<span class="operator">=</span>DictCursor)</span><br><span class="line">        self.conn: pymysql.connections.Connection</span><br><span class="line"></span><br><span class="line">    def get_conn(self) <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Cursor</span>:</span><br><span class="line">        if self.conn <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            raise Exception(&quot;mysql is lost connection&quot;)</span><br><span class="line">        <span class="keyword">return</span> self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    def close_db(self):</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    def <span class="keyword">add</span>(self, data: List[Dict]) <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">cursor</span> <span class="operator">=</span> self.get_conn()</span><br><span class="line">        device_sql <span class="operator">=</span> &quot;insert into devices (sn, ip, hostname, idc, vendor, model, role) values (%s, %s, %s, %s, %s, %s, %s);&quot;</span><br><span class="line">        device_detail_sql <span class="operator">=</span> &quot;insert into device_detail values (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s);&quot;</span><br><span class="line">        device_data <span class="operator">=</span> []</span><br><span class="line">        device_detail_data <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">            device_data.append([</span><br><span class="line">                item.get(&quot;sn&quot;, &quot;&quot;), item.get(&quot;ip&quot;, &quot;&quot;), item.get(&quot;hostname&quot;, &quot;&quot;), item.get(&quot;idc&quot;, &quot;&quot;),</span><br><span class="line">                item.get(&quot;vendor&quot;, &quot;&quot;), item.get(&quot;model&quot;, &quot;&quot;), item.get(&quot;role&quot;, &quot;&quot;)</span><br><span class="line">            ])</span><br><span class="line">            device_detail_data.append([</span><br><span class="line">                item.get(&quot;sn&quot;, &quot;&quot;), item.get(&quot;ipv6&quot;, &quot;&quot;), item.get(&quot;console_ip&quot;, &quot;&quot;), item.get(&quot;row&quot;, &quot;&quot;),</span><br><span class="line">                item.get(&quot;column&quot;, &quot;&quot;), item.get(&quot;last_start&quot;, &quot;&quot;), item.get(&quot;runtime&quot;, &quot;&quot;), item.get(&quot;image_version&quot;, &quot;&quot;),</span><br><span class="line">                item.get(&quot;over_warrant&quot;), item.get(&quot;warrant_time&quot;)</span><br><span class="line">            ])</span><br><span class="line">        try:</span><br><span class="line">            cursor.executemany(device_sql, device_data)</span><br><span class="line">            cursor.executemany(device_detail_sql, device_detail_data)</span><br><span class="line">            self.conn.commit()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            self.conn.rollback()</span><br><span class="line">            raise Exception(&quot;db insert failed, error: %s&quot; <span class="operator">%</span> str(e))</span><br><span class="line">        finally:</span><br><span class="line">            cursor.close()</span><br><span class="line"></span><br><span class="line">    def <span class="keyword">delete</span>(self, data: Dict) <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">None</span>:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def <span class="keyword">update</span>(self, data: Dict) <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">None</span>:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def <span class="keyword">get</span>(self, <span class="keyword">condition</span>: Optional[Dict] <span class="operator">=</span> <span class="keyword">None</span>) <span class="operator">-</span><span class="operator">&gt;</span> List[Device]:</span><br><span class="line">        <span class="keyword">cursor</span> <span class="operator">=</span> self.get_conn()</span><br><span class="line">        <span class="keyword">sql</span> <span class="operator">=</span> &quot;select ip, hostname, vendor, model, hardware, channel, device_type from devices &quot; \</span><br><span class="line">              &quot;join device_detail on devices.sn = device_detail.sn&quot;</span><br><span class="line">        where_str <span class="operator">=</span> []</span><br><span class="line">        if <span class="keyword">condition</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> condition.items():</span><br><span class="line">                if isinstance(v, <span class="type">int</span>):</span><br><span class="line">                    where_str.append(&quot;%s=%d&quot; <span class="operator">%</span> (k, v))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    where_str.append(&quot;%s=&#x27;%s&#x27;&quot; <span class="operator">%</span> (k, v))</span><br><span class="line">        if len(where_str) <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">sql</span> <span class="operator">+</span><span class="operator">=</span> (&quot; where %s&quot; <span class="operator">%</span> &quot;,&quot;.<span class="keyword">join</span>(where_str))</span><br><span class="line">        cursor.execute(<span class="keyword">sql</span>)</span><br><span class="line">        <span class="keyword">result</span> <span class="operator">=</span> cursor.fetchall()</span><br><span class="line">        devices <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">result</span>:</span><br><span class="line">            devices.append(Device().to_model(<span class="operator">*</span><span class="operator">*</span>item))</span><br><span class="line">        <span class="keyword">return</span> devices</span><br></pre></td></tr></table></figure>

<p>上述代码中呢，我引入的一个新的第三方库<code>pymysql</code>，这个库就是Python中用来连接MySQL数据库的最常用的轮子，大多数兼容MySQL的ORM框架也是用<code>pymysql</code>作为底层驱动。</p>
<p>我们可以直接使用这个库执行原生SQL，虽然我之前有长期使用过这个库，但在编写上述代码的时候仍然会有诸多细节需要仔细确认（我会在视频中详细提到）；</p>
<p>相比前面章节使用ORM来操作增删改查，易用性的差距简直不是一点半点；除此之外，由于定义了<code>devices</code>和<code>device_detail</code>两张表进行关联，所以大家可以发现，在做数据库操作时会格外的复杂繁琐，如果使用ORM的关联查询的话，处理起这些问题来就非常得心应手。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过这一章节的讲解，我们已经基本准备好了执行命令必须的几个模块：执行器初始化连接，命令筛选，设备筛选，关于保存和解析部分会在后面章节提到，在阅读完这一章节之后，大家便可以自己尝试一下编写SSHExecutor的代码了。我会在下一章节中手把手带领大家来写SSHExecutor。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>Netmiko</tag>
        <tag>巡检</tag>
      </tags>
  </entry>
  <entry>
    <title>2.6 自动化运维初级村-Netmiko-巡检-3</title>
    <url>/posts/f357f9b2.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>上一章节已经完成了命令筛选和设备筛选部分的代码，接下来就是将其整合到执行器中，今天的章节中，我会在视频里带领大家完善SSHExecutor，大家也可以体会一下写代码的过程，以及其中体现的编程思想，对后续的学习和发展会有很大帮助。</p>
<span id="more"></span>

<h1 id="SSHExecutor"><a href="#SSHExecutor" class="headerlink" title="SSHExecutor"></a>SSHExecutor</h1><p>这里再次巩固一下整体巡检的设计图，如下所示：</p>
<p><img src="https://xzsh9e8v26.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQwN2M0MGQ5ZDFiNWUzZjViM2Q5MTgxODg0M2VhYjFfTGFNU1ZTQXlrbnpSN3RqZHdxWUxPeHh1aHJCRGJ2eUJfVG9rZW46S2RJZmJuR2dvb3ZCU0l4N0s2UWN5TW9WbnJmXzE2ODA5MjM2Njc6MTY4MDkyNzI2N19WNA" alt="img"></p>
<h1 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h1><p>之前章节已经实现的SSHExecutor初始化代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        host: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">        username: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">        password: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        secret: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">        port: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        device_type: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">        conn_timeout: <span class="built_in">int</span> = <span class="number">10</span>,</span></span><br><span class="line"><span class="params">        auth_timeout: <span class="built_in">int</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        banner_timeout: <span class="built_in">int</span> = <span class="number">15</span>,</span></span><br><span class="line"><span class="params">        log_file: <span class="built_in">str</span> = <span class="string">&quot;ssh_executor.log&quot;</span>,</span></span><br><span class="line"><span class="params">        log_level: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        log_format: <span class="built_in">str</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line">        self.secret = secret</span><br><span class="line">        self.device_type = device_type</span><br><span class="line">        self.conn_timeout = conn_timeout</span><br><span class="line">        self.auth_timeout = auth_timeout</span><br><span class="line">        self.banner_timeout = banner_timeout</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">import</span> logging</span><br><span class="line">        <span class="keyword">if</span> log_level <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            log_level = logging.ERROR</span><br><span class="line">        <span class="keyword">if</span> log_format <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            log_format = <span class="string">&quot;%(asctime)s %(levelname)s %(name)s %(message)s&quot;</span></span><br><span class="line"></span><br><span class="line">        logging.basicConfig(filename=log_file, level=log_level, <span class="built_in">format</span>=log_format)</span><br><span class="line">        self.logger = logging.getLogger(__name__)</span><br><span class="line">        self.conn = self.connect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn = ConnUnify(**self.__dict__)</span><br><span class="line">            msg = <span class="string">f&quot;Netmiko connection successful to <span class="subst">&#123;self.host&#125;</span>:<span class="subst">&#123;self.port&#125;</span>&quot;</span></span><br><span class="line">            self.logger.info(msg)</span><br><span class="line">            <span class="keyword">return</span> conn</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            self.logger.error(<span class="built_in">str</span>(e))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fetch_object</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fetch_action</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="获取执行设备-x2F-命令"><a href="#获取执行设备-x2F-命令" class="headerlink" title="获取执行设备&#x2F;命令"></a>获取执行设备&#x2F;命令</h2><p>上述代码中的执行、获取执行对象、获取执行动作这三个方法都还没有实现，基于设计图中所示，如果想要实现执行，首先需要获取到执行的对象和动作，那么我们上一章节中又分别实现了<code>ActionHandler</code>和<code>DeviceHandler</code>这两个类，并且具有增删改查的功能，那直接将这两个对象传入到执行器中不就可以实现<code>fetch_object()</code>和<code>fetch_action</code>了吗？</p>
<p>所以SSHExecutor的初始化函数改造如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> action <span class="keyword">import</span> ActionHandler, Action</span><br><span class="line"><span class="keyword">from</span> device <span class="keyword">import</span> DeviceHandler, Device</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            ...</span></span><br><span class="line"><span class="params">            <span class="comment"># action</span></span></span><br><span class="line"><span class="params">            action_handler: <span class="type">Optional</span>[ActionHandler] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">            <span class="comment"># object</span></span></span><br><span class="line"><span class="params">            object_handler: <span class="type">Optional</span>[DeviceHandler] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        ...</span><br><span class="line">        self.action_handler = action_handler</span><br><span class="line">        self.object_handler = object_handler</span><br></pre></td></tr></table></figure>

<p>获取执行对象和执行动作的函数实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fetch_action</span>(<span class="params">self, condition: <span class="type">Dict</span></span>) -&gt; Action:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.action_handler:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;has no action handler instance&quot;</span>)</span><br><span class="line">        filter_actions = self.action_handler.get(condition)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filter_actions:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;not found action by <span class="subst">&#123;condition&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(filter_actions) &gt; <span class="number">1</span>:</span><br><span class="line">            self.logger.warning(<span class="string">f&quot;<span class="subst">&#123;condition&#125;</span> has more than one action&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> filter_actions[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fetch_object</span>(<span class="params">self, condition: <span class="type">Dict</span></span>) -&gt; Device:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.device_handler:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;has no object handler instance&quot;</span>)</span><br><span class="line">        devices = self.device_handler.get(condition)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(devices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;not found device by %s&quot;</span> % <span class="built_in">str</span>(condition))</span><br><span class="line">        <span class="keyword">return</span> devices[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>既然已经具备了根据条件筛选设备的函数，那么初始化函数中就不需要传入关于device的全部参数，只需要传入设备筛选条件即可，因此初始化函数进一步改造如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            <span class="comment"># device</span></span></span><br><span class="line"><span class="params">            <span class="comment"># ...</span></span></span><br><span class="line"><span class="params">            device_condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">            <span class="comment"># logger</span></span></span><br><span class="line"><span class="params">            ...</span></span><br><span class="line"><span class="params">            <span class="comment"># action</span></span></span><br><span class="line"><span class="params">            action_handler: <span class="type">Optional</span>[ActionHandler] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">            <span class="comment"># object</span></span></span><br><span class="line"><span class="params">            object_handler: <span class="type">Optional</span>[DeviceHandler] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># device params</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        self.action_handler = action_handler</span><br><span class="line">        self.object_handler = object_handler</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.host <span class="keyword">or</span> <span class="keyword">not</span> self.port:</span><br><span class="line">            device = self.fetch_object(device_condition)</span><br><span class="line">            self.host = device.ip</span><br><span class="line">            self.port = device.channel_port</span><br><span class="line">            self.device_type = device.device_type</span><br><span class="line"></span><br><span class="line">        <span class="comment"># logging</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">       </span><br><span class="line">        self.conn = self.connect()</span><br></pre></td></tr></table></figure>

<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>最后就是执行的代码，这一部分需要格外注意。</p>
<p>执行的前提是要有执行的动作，所以需要将执行的动作当作参数传入execute函数中，如果没有指定Action的话就需要传入动作的筛选条件进行筛选，然后再根据Action是查看类型还是配置类型去调用Netmiko不同的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">Optional</span>, <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnUnify</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> action <span class="keyword">import</span> ActionHandler, CommandType, Action</span><br><span class="line"><span class="keyword">from</span> device <span class="keyword">import</span> DeviceHandler, Device</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, action: Action, action_condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span>, read_timeout: <span class="built_in">float</span> = <span class="number">100.0</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> action:  <span class="comment"># 根据条件筛选action</span></span><br><span class="line">            action = self.fetch_action(action_condition)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> action.cmd:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;action has cmd attribute, action: <span class="subst">&#123;action&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.conn <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.conn = self.connect()</span><br><span class="line">        <span class="comment"># 根据action类型执行</span></span><br><span class="line">        <span class="keyword">if</span> action.<span class="built_in">type</span> == CommandType.Config:</span><br><span class="line">            output = self.conn.send_config_set(action.cmd, read_timeout=read_timeout)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output = self.conn.send_command(action.cmd, expect_string=self.conn.base_prompt, read_timeout=read_timeout)</span><br><span class="line">        self.result[action.cmd] = output</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>这里首先要注意的就是异常前置，将对命令的判断逻辑放在最前面；其次就是对Action类型的判断，这里引入了一个自定义类，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># action.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandType</span>:</span><br><span class="line">    Show = <span class="string">&quot;show&quot;</span></span><br><span class="line">    Config = <span class="string">&quot;config&quot;</span></span><br></pre></td></tr></table></figure>

<p>在生产环境的代码中，原则上不要出现字面变量（也就是数字或者字符串），尽量将字面量替换为常量，比如时间长了你可能忘了配置类型是config还是configuration，或者在多处用到Action的类型的时候会很难统一；</p>
<p>所以这里定义了一个自定义类来表示两种不同的类型，这样对于代码的可读性和可维护性有很大帮助。</p>
<h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>到目前为止还没有讲到保存结果的功能，因为保存需要在完成解析之后再做，所以这一部分我们后面再讲，但有个地方大家需要仔细思考一下：在self.execute函数中直接把output返回了出来，那岂不是执行变成了单个Action粒度，如果我想多执行几个Action应该怎么做呢？</p>
<p>有一种做法是调用多次execute并将结果保存下来，然后解析或者保存的时候再把结果当作参数传入到函数中，这种做法理论上也可以，但就让执行结果这一对象脱离了执行器的上下文；可能有的朋友听起来有些模糊，我们对代码稍加改动大家再看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># executor.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            <span class="comment"># device</span></span></span><br><span class="line"><span class="params">            <span class="comment"># ...</span></span></span><br><span class="line"><span class="params">            device_condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">            <span class="comment"># logger</span></span></span><br><span class="line"><span class="params">            ...</span></span><br><span class="line"><span class="params">            <span class="comment"># action</span></span></span><br><span class="line"><span class="params">            action_handler: <span class="type">Optional</span>[ActionHandler] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">            <span class="comment"># object</span></span></span><br><span class="line"><span class="params">            object_handler: <span class="type">Optional</span>[DeviceHandler] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        self.result = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, action: Action, action_condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span>, read_timeout: <span class="built_in">float</span> = <span class="number">100.0</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># TODO parse_result = self.parse()</span></span><br><span class="line">        parse_result = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.save(action.cmd, output, parse_result)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self, cmd: <span class="built_in">str</span>, output: <span class="built_in">str</span>, parse_result: <span class="built_in">str</span></span>):</span><br><span class="line">        self.result.append(&#123;<span class="string">&quot;cmd&quot;</span>: cmd, <span class="string">&quot;output&quot;</span>: output, <span class="string">&quot;timestamp&quot;</span>: time.time(), <span class="string">&quot;parse_result&quot;</span>: parse_result&#125;)</span><br></pre></td></tr></table></figure>

<p>经过上面的修改，就把执行的结果作为了执行器对象的一个属性，一方面更符合面向对象的封装原则，另一方面也更有利于我们后续对结果进行保存。</p>
<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.conn <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.conn.disconnect()</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>下面我们就直接测试写好的SSHExecutor，让他连接到我局域网内的一台模拟器设备上完成执行命令的动作，测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> device <span class="keyword">import</span> DeviceDBHandler</span><br><span class="line"><span class="keyword">from</span> action <span class="keyword">import</span> ActionJSONHandler, Action</span><br><span class="line"><span class="keyword">from</span> executor <span class="keyword">import</span> SSHExecutor</span><br><span class="line"></span><br><span class="line">SSH_USERNAME = <span class="string">&quot;cisco&quot;</span></span><br><span class="line">SSH_PASSWORD = <span class="string">&quot;cisco&quot;</span></span><br><span class="line"></span><br><span class="line">device_filter = &#123;<span class="string">&quot;ip&quot;</span>: <span class="string">&quot;192.168.31.149&quot;</span>&#125;</span><br><span class="line">action_filter = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;power_check&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig(filename=<span class="string">&quot;ssh_executor.log&quot;</span>, level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">    logger = logging.getLogger(__name__)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        device_handler = DeviceDBHandler(<span class="string">&quot;root&quot;</span>, <span class="string">&quot;Yfy98333498&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;python_ops&quot;</span>)</span><br><span class="line">        action_handler = ActionJSONHandler(<span class="string">&quot;action.json&quot;</span>)</span><br><span class="line">        executor = SSHExecutor(username=SSH_USERNAME, password=SSH_PASSWORD, device_condition=device_filter,</span><br><span class="line">                               device_handler=device_handler, action_handler=action_handler, logger=logger)</span><br><span class="line">        output = executor.execute(action=Action.to_model(cmd=<span class="string">&quot;show ip interface brief&quot;</span>))</span><br><span class="line">        logger.info(output)</span><br><span class="line">        executor.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

<p>执行后日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ssh_executor.log</span><br><span class="line"></span><br><span class="line">2022-12-01 20:10:18,466 - __main__ - INFO - Netmiko connection successful to 192.168.31.149:22</span><br><span class="line">2022-12-01 20:10:18,617 - __main__ - INFO - Interface                  IP-Address      OK? Method Status                Protocol</span><br><span class="line">Ethernet0/0                192.168.31.149  YES DHCP   up                    up      </span><br><span class="line">Ethernet0/1                unassigned      YES unset  administratively down down    </span><br><span class="line">Ethernet0/2                unassigned      YES unset  administratively down down    </span><br><span class="line">Ethernet0/3                unassigned      YES unset  administratively down down    </span><br><span class="line"># netmiko.log</span><br><span class="line"></span><br><span class="line">#####################################################</span><br><span class="line"># Welcome to Cisco, Please quit if not administrator#</span><br><span class="line">#####################################################r1&gt;</span><br><span class="line">r1&gt;terminal width 511</span><br><span class="line">r1&gt;terminal length 0</span><br><span class="line">r1&gt;</span><br><span class="line">r1&gt;show ip interface brief</span><br><span class="line">Interface                  IP-Address      OK? Method Status                Protocol</span><br><span class="line">Ethernet0/0                192.168.31.149  YES DHCP   up                    up      </span><br><span class="line">Ethernet0/1                unassigned      YES unset  administratively down down    </span><br><span class="line">Ethernet0/2                unassigned      YES unset  administratively down down    </span><br><span class="line">Ethernet0/3                unassigned      YES unset  administratively down down    </span><br><span class="line">r1&gt;</span><br><span class="line">r1&gt;exit</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章节给大家演示如何逐步完善SSH执行器的代码，其中涉及到面向对象的特性、Python中的函数注解、异常处理和日志记录等诸多知识点，希望大家可以反复观看视频进行深入理解。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>Netmiko</tag>
        <tag>巡检</tag>
      </tags>
  </entry>
  <entry>
    <title>2.7 自动化运维初级村-巡检-Flask大型应用-上</title>
    <url>/posts/ccee86b7.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>经过前面几个章节的学习，大家应该已经对巡检模块的整体设计以及各个部分的实现都有了清晰的了解，但之前的代码其实只是小试牛刀，主要是为了让大家能够更方便的理解各个部分的功能，并且让刚接触较为复杂的程序设计的朋友更容易上手。</p>
<p>今天的章节中，我们会把巡检的代码和新手村中的CMDB结合起来，将巡检集成到Flask后端应用中。</p>
<span id="more"></span>

<h1 id="设备-x2F-命令Handler实现"><a href="#设备-x2F-命令Handler实现" class="headerlink" title="设备&#x2F;命令Handler实现"></a>设备&#x2F;命令Handler实现</h1><p>之前的章节中DeviceHandler和ActionHandler都各自实现了一个具备增删改查功能的子类，今天我们就用ORM将其改造一下，使其能结合到Flask应用中。</p>
<h2 id="ActionORMHandler"><a href="#ActionORMHandler" class="headerlink" title="ActionORMHandler"></a>ActionORMHandler</h2><p>首先创建Action的数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `action` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;动作名称&#x27;</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;动作描述&#x27;</span>,</span><br><span class="line">  `vendor` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;厂商&#x27;</span>,</span><br><span class="line">  `model` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;型号&#x27;</span>,</span><br><span class="line">  `cmd` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;命令行&#x27;</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;命令类型[show|config]&#x27;</span>,</span><br><span class="line">  `parse_type` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;解析类型[regexp|textfsm]&#x27;</span>,</span><br><span class="line">  `parse_content` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;解析内容&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>然后定义两个与数据模型相关的工具方法，负责从数据模型转成字典，或者从字典转成数据模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_model</span>(<span class="params">cls: <span class="type">Any</span>, **kwargs: <span class="type">Dict</span></span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据关键字参数生成对象</span></span><br><span class="line"><span class="string">    :param cls: ClassVar 目标对象</span></span><br><span class="line"><span class="string">    :param kwargs: Dict 关键字字典</span></span><br><span class="line"><span class="string">    :return: ClassVar</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    device = cls()  <span class="comment"># 实例化一个对象</span></span><br><span class="line">    columns = [c.name <span class="keyword">for</span> c <span class="keyword">in</span> cls.__table__.columns]  <span class="comment"># 获取模型定义的所有列属性的名字</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():  <span class="comment"># 遍历传入kwargs的键值</span></span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">in</span> columns:  <span class="comment"># 如果键包含在列名中，则为该对象赋加对应的属性值</span></span><br><span class="line">            <span class="built_in">setattr</span>(device, k, v)</span><br><span class="line">    <span class="keyword">return</span> device</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self: <span class="type">Any</span></span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将实例对象的属性生成字典</span></span><br><span class="line"><span class="string">    :param self: ClassVar 对象实例</span></span><br><span class="line"><span class="string">    :return: Dict</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;c.name: <span class="built_in">getattr</span>(self, c.name) <span class="keyword">for</span> c <span class="keyword">in</span> self.__table__.columns&#125;</span><br></pre></td></tr></table></figure>

<p>下面在原先的app.py文件中定义Action的数据模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_model, to_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;action&quot;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;动作名称&quot;</span>)</span><br><span class="line">    description = db.Column(db.String(<span class="number">256</span>), comment=<span class="string">&quot;动作描述&quot;</span>)</span><br><span class="line">    vendor = db.Column(db.String(<span class="number">64</span>), comment=<span class="string">&quot;厂商&quot;</span>)</span><br><span class="line">    model = db.Column(db.String(<span class="number">64</span>), comment=<span class="string">&quot;型号&quot;</span>)</span><br><span class="line">    cmd = db.Column(db.String(<span class="number">256</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;命令行&quot;</span>)</span><br><span class="line">    <span class="built_in">type</span> = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;命令类型[show|config]&quot;</span>)</span><br><span class="line">    parse_type = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;解析类型[regexp|textfsm]&quot;</span>)</span><br><span class="line">    parse_content = db.Column(db.String(<span class="number">1024</span>), comment=<span class="string">&quot;解析内容&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_model</span>(<span class="params">cls, **kwargs</span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">        <span class="keyword">return</span> to_model(cls, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>) -&gt; db.Model:</span><br><span class="line">        <span class="keyword">return</span> to_dict(self)</span><br></pre></td></tr></table></figure>

<p>有了数据模型之后，就可以定义ActionORMHandler类，该类初始化的时候接收一个handler参数，该参数就是SQLAlchemy的db实例，可以通过这个handler来操作数据库，实现增删改查，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># action.py</span></span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> Action</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionORMHandler</span>(<span class="title class_ inherited__">ActionHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, handler</span>):</span><br><span class="line">        self.handler = handler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, args: <span class="type">List</span>[<span class="type">Dict</span>]</span>):</span><br><span class="line">        <span class="keyword">if</span> self.handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;has no active db handler&quot;</span>)</span><br><span class="line">        actions = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> args:</span><br><span class="line">            actions.append(Action.to_model(**item))</span><br><span class="line">        self.handler.add_all(actions)</span><br><span class="line">        self.handler.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, args: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="keyword">if</span> self.handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;has no active db handler&quot;</span>)</span><br><span class="line">        Action.query.<span class="built_in">filter</span>(Action.<span class="built_in">id</span>.in_(args)).delete()</span><br><span class="line">        self.handler.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, args: <span class="type">List</span>[<span class="type">Dict</span>]</span>):</span><br><span class="line">        <span class="keyword">if</span> self.handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;has no active db handler&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> args:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;id&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> item:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            Action.query.filter_by(<span class="built_in">id</span>=item.pop(<span class="string">&quot;id&quot;</span>)).update(item)</span><br><span class="line">        self.handler.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, filters: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> Action.query.filter_by(**(filters <span class="keyword">or</span> &#123;&#125;)).<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure>

<p>利用orm进行增删改动作之后，均需要调用commit完成提交，否则操作会被回滚。</p>
<h2 id="DeviceORMHandler"><a href="#DeviceORMHandler" class="headerlink" title="DeviceORMHandler"></a>DeviceORMHandler</h2><p>由于之前我们已经在app.py中定义过Device和DeviceDetail的数据模型，但之前的章节中给device_detail表增加了两列，所以现在需要修改DeviceDetail模型的属性，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> text, DateTime, Numeric</span><br><span class="line"><span class="keyword">from</span> ..utils <span class="keyword">import</span> to_model <span class="keyword">as</span> tm, to_dict <span class="keyword">as</span> td</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;devices&quot;</span></span><br><span class="line">    sn = db.Column(db.String(<span class="number">128</span>), primary_key=<span class="literal">True</span>, comment=<span class="string">&quot;资产号&quot;</span>)</span><br><span class="line">    ip = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;IP地址&quot;</span>)</span><br><span class="line">    hostname = db.Column(db.String(<span class="number">128</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;主机名&quot;</span>)</span><br><span class="line">    idc = db.Column(db.String(<span class="number">32</span>), comment=<span class="string">&quot;机房&quot;</span>)</span><br><span class="line">    vendor = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;厂商&quot;</span>)</span><br><span class="line">    model = db.Column(db.String(<span class="number">16</span>), comment=<span class="string">&quot;型号&quot;</span>)</span><br><span class="line">    role = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;角色&quot;</span>)</span><br><span class="line">    created_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line">    updated_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), server_onupdate=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;修改时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">    detail = db.relationship(<span class="string">&quot;DeviceDetail&quot;</span>, uselist=<span class="literal">False</span>, backref=<span class="string">&quot;device&quot;</span>)</span><br><span class="line">    ports = db.relationship(<span class="string">&quot;Ports&quot;</span>, uselist=<span class="literal">True</span>, backref=<span class="string">&quot;device&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_model</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> tm(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>):</span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> self.__table__.columns:</span><br><span class="line">            val = <span class="built_in">getattr</span>(self, col.name)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(col.<span class="built_in">type</span>, DateTime):  <span class="comment"># 判断类型是否为DateTime</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> val:  <span class="comment"># 判断实例中该字段是否有值</span></span><br><span class="line">                    value = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 进行格式转换</span></span><br><span class="line">                    value = val.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(col.<span class="built_in">type</span>, Numeric):  <span class="comment"># 判断类型是否为Numeric</span></span><br><span class="line">                value = <span class="built_in">float</span>(val)  <span class="comment"># 进行格式转换</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 剩余的直接取值</span></span><br><span class="line">                value = val</span><br><span class="line">            res[col.name] = value</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceDetail</span>(db.Model):</span><br><span class="line">    __tablename = <span class="string">&quot;device_detail&quot;</span></span><br><span class="line">    sn = db.Column(db.String(<span class="number">128</span>), db.ForeignKey(Devices.sn, ondelete=<span class="string">&quot;cascade&quot;</span>), primary_key=<span class="literal">True</span>, comment=<span class="string">&quot;资产号&quot;</span>)</span><br><span class="line">    ipv6 = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;IPv6地址&quot;</span>)</span><br><span class="line">    console_ip = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;console地址&quot;</span>)</span><br><span class="line">    row = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜行&quot;</span>)</span><br><span class="line">    column = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;机柜列&quot;</span>)</span><br><span class="line">    last_start = db.Column(db.DateTime(), comment=<span class="string">&quot;最近启动时间&quot;</span>)</span><br><span class="line">    runtime = db.Column(db.Integer, comment=<span class="string">&quot;运行时长&quot;</span>)</span><br><span class="line">    image_version = db.Column(db.String(<span class="number">128</span>), comment=<span class="string">&quot;镜像版本&quot;</span>)</span><br><span class="line">    over_warrant = db.Column(db.BOOLEAN, comment=<span class="string">&quot;是否过保&quot;</span>)</span><br><span class="line">    warrant_time = db.Column(db.DateTime(), comment=<span class="string">&quot;过保时间&quot;</span>)</span><br><span class="line">    device_type = db.Column(db.String(<span class="number">32</span>), comment=<span class="string">&quot;远程连接设备类型&quot;</span>)</span><br><span class="line">    channel = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;远程连接方式[ssh|telnet]&quot;</span>)</span><br><span class="line">    created_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;创建时间&quot;</span>)</span><br><span class="line">    updated_at = db.Column(db.DateTime(), nullable=<span class="literal">False</span>, server_default=text(<span class="string">&#x27;NOW()&#x27;</span>), server_onupdate=text(<span class="string">&#x27;NOW()&#x27;</span>), comment=<span class="string">&quot;修改时间&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_model</span>(<span class="params">cls, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> tm(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> td(self)</span><br></pre></td></tr></table></figure>

<p>修改好数据模型后就可以利用其实现DeviceORMHandler，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># device.py</span></span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> Devices, DeviceDetail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceORMHandler</span>(<span class="title class_ inherited__">DeviceHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, handler: scoped_session</span>):</span><br><span class="line">        self.handler = handler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, args: <span class="type">List</span>[<span class="type">Dict</span>]</span>):</span><br><span class="line">        <span class="keyword">if</span> self.handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;has no active db handler&quot;</span>)</span><br><span class="line">        devices = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> args:</span><br><span class="line">            device = Devices.to_model(**item)</span><br><span class="line">            device.device = DeviceDetail.to_model(**item)</span><br><span class="line">            devices.append(device)</span><br><span class="line">        self.handler.add_all(devices)</span><br><span class="line">        self.handler.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, args: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="keyword">if</span> self.handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;has no active db handler&quot;</span>)</span><br><span class="line">        Devices.query.<span class="built_in">filter</span>(Devices.sn.in_(args)).delete()</span><br><span class="line">        self.handler.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, args: <span class="type">List</span>[<span class="type">Dict</span>]</span>):</span><br><span class="line">        <span class="keyword">if</span> self.db_handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;has no active db handler&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> args:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;sn&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> item:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            sn = item.pop(<span class="string">&quot;sn&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;detail&quot;</span> <span class="keyword">in</span> item:</span><br><span class="line">                DeviceDetail.query.filter_by(sn=sn).update(item.pop(<span class="string">&quot;detail&quot;</span>))</span><br><span class="line">            Devices.query.filter_by(sn=sn).update(item)</span><br><span class="line">        self.db_handler.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, filters: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span></span>) -&gt; <span class="type">List</span>[Devices]:</span><br><span class="line">        <span class="keyword">return</span> Devices.query.filter_by(**(filters <span class="keyword">or</span> &#123;&#125;)).<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure>

<h1 id="文件拆分"><a href="#文件拆分" class="headerlink" title="文件拆分"></a>文件拆分</h1><p>在定义了很多个数据模型之后大家应该会发现，app.py文件已经变得非常冗长，Model和Route混在一起，让代码开始变得难以阅读和维护，这时候就需要进行适当的文件拆分了。</p>
<p>大部分朋友第一反应应该就是，将Model拆出去写在另一个文件不就好了？就像如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># model.py</span></span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span>(db.Model):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceDetail</span>(db.Model):</span><br><span class="line">    <span class="keyword">pass</span> </span><br></pre></td></tr></table></figure>

<p>拆完后model.py中需要引用ORM的db对象，这个对象是在app.py中创建的。</p>
<p>device.py和action.py文件中的ORMHandler，需要引用到Action和Devices的Model类，app.py中的路由函数如果需要提供命令和设备的增删改查接口的话，就需要从device.py或action.py中引入ORMHandler，这时候就出现了让人非常头疼的circular import，也叫循环引用；如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/08/tZbjOP8D69MEXh5.png" alt="img"></p>
<p>当一个项目或者应用的体积初步变大的时候，出现循环引用的情况是必然现象，这时候就需要对项目的整体布局进行合理的规划。</p>
<h1 id="Flask大型应用"><a href="#Flask大型应用" class="headerlink" title="Flask大型应用"></a>Flask大型应用</h1><p>下面我会详细给大家讲解如何进行Flask大型应用的布局规划，并把巡检模块集成到后端中。</p>
<h2 id="工厂函数创建应用"><a href="#工厂函数创建应用" class="headerlink" title="工厂函数创建应用"></a>工厂函数创建应用</h2><p>根据上面的图示可知，循环引用的最源头其实就是app对象，所以现在首先就是要把app拆分出来，使用“应用程序工厂”来创建app，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>() -&gt; Flask:</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="comment"># 挂载各种中间件</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"><span class="comment"># run.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> create_app</span><br><span class="line"></span><br><span class="line">app = create_app()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>“应用程序工厂”的意思就是在一个函数里把app给“生产”出来，在工厂里把数据库初始化完成，或者在app上挂载其他的对象，这些下面会提到。</p>
<h2 id="ORM集成"><a href="#ORM集成" class="headerlink" title="ORM集成"></a>ORM集成</h2><p>我们需要使用到SQLAlchemy作为ORM的第三方库，并将其注册到app上，除此之外将model进行拆分，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /models/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"><span class="comment"># /models/action.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span>(db.Model):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># /models/device.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Devices</span>(db.Model):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceDetail</span>(db.Model):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># /__init__.py</span></span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>(<span class="params">env: <span class="built_in">str</span> = <span class="string">&quot;dev&quot;</span></span>) -&gt; Flask:</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="comment"># register db</span></span><br><span class="line">    db.init_app(app)</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>

<p>这里大家可能发现，在models&#x2F;<strong>init</strong>.py中的db没有传入app参数，是不是没有注册在Flask的app上呢？</p>
<p>其实并不是，我们在create_app的工厂里面引入了models中的db对象，并使用的db.init_app(app)进行了注册，在程序启动一开始创建app的过程里已经把db这个对象注册过了，因为models&#x2F;<strong>init</strong>.py是一个全局对象，所以后续用到的db都会是已经注册过的db。</p>
<h2 id="路由蓝图"><a href="#路由蓝图" class="headerlink" title="路由蓝图"></a>路由蓝图</h2><p>之前的章节中我们实现了对设备数据的增删改查，分别对应四个路由函数，那么现在又增加了命令数据的增删改查，后续又会有解析规则的增删改查，那么就有必要对路由文件进行拆分。</p>
<p>原先直接使用app.route()进行路由的注册，这种方式也会导致我们的路由文件依赖app，导致了循环引用的风险。</p>
<p>所以结合上述两点原因，把路由文件进行拆分，将路由函数进行分类，同一类的称作一个Blueprint（蓝图），代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmdb_view.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line">cmdb_blueprint = Blueprint(<span class="string">&quot;cmdb&quot;</span>, __name__, url_prefix=<span class="string">&quot;/cmdb&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cmdb_blueprint.route(<span class="params"><span class="string">&quot;/get&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;cmdb&quot;</span></span><br><span class="line"><span class="comment"># action_view.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line">action_blueprint = Blueprint(<span class="string">&quot;action&quot;</span>, __name__, url_prefix=<span class="string">&quot;/action&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@action_blueprint.route(<span class="params"><span class="string">&quot;/get&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;action&quot;</span></span><br></pre></td></tr></table></figure>

<p>如上述代码所示，从Flask中引入Blueprint对象，创建一个蓝图实例；</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>Blueprint的第一个参数是name，这个参数起到了相当重要的作用，应用程序想要区分不用的蓝图模块就是靠这个参数，现在cmdb和action蓝图模块里都存在get函数，而且都把这个函数注册成了路由函数，如果实例化cmdb_blueprint和action_blueprint的时候没有传name参数或者传了相同的值（最新版Flask该参数要求必传），那程序启动就会报错，因为Flask不允许两个路由函数的endpoints重名（函数上添加了路由装饰器，就会将该函数名称作为路由的endpoints，例如”&#x2F;get”路由对应的endpoints就是”get”）；</p>
<p>但是如果两个函数上加的是不同的蓝图装饰器，并且两个蓝图实例传入了不同name，那就会在路由注册的时候进行区分，大家可以理解成将两个函数分别注册成了“action_get”和“cmdb_get”，这样就可以避免endpoints重复。</p>
<h4 id="import-name"><a href="#import-name" class="headerlink" title="import_name"></a>import_name</h4><p>这个参数通常传__name__，通过该参数定位还蓝图的根路径，不需要深究</p>
<h4 id="url-prefix"><a href="#url-prefix" class="headerlink" title="url_prefix"></a>url_prefix</h4><p>这个参数也很重要，该参数的值会附加在路由的URL前面，比如action_blueprint注册的“&#x2F;get”路由，当传入了url_prefix&#x3D;”&#x2F;action”之后，这个函数的路由就变成了“&#x2F;action&#x2F;get”。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>有一点大家不知道发现没有，只有一个app.py的时候，创建了app，直接使用app.route进行路由注册，那现在拆分之后，Blueprint是从Flask直接引入的，貌似跟我们“工厂”中的app没有任何关系。</p>
<p>实际上到目前为止确实还没有关系，因为创建完蓝图之后还需要挂载到app，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> action_view <span class="keyword">import</span> action_blueprint</span><br><span class="line"><span class="keyword">from</span> cmdb_view <span class="keyword">import</span> cmdb_blueprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>() -&gt; Flask:</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># register blueprint</span></span><br><span class="line">    blueprints = [cmdb_blueprint, action_blueprint]</span><br><span class="line">    <span class="keyword">for</span> blueprint <span class="keyword">in</span> blueprints:</span><br><span class="line">        app.register_blueprint(blueprint)</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>

<p>挂载的形式其实在我看来是大型应用解决循环引用的一个非常好的方式。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在任何的项目中配置管理都是非常重要的一部分，通常一个应用会存在多种环境，至少会有“开发环境”和“生产环境”两个，不同环境的配置是不一样的。</p>
<p>Flask管理配置也有不同的方式，有通过文件管理的，也有直接通过变量来管理的，我们采用一个通过类的管理方式，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">    DEBUG = <span class="literal">False</span></span><br><span class="line">    LOG_LEVEL = <span class="string">&quot;info&quot;</span></span><br><span class="line">    SQLALCHEMY_ECHO = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>首先定义一个配置基类，其中包含三项基本配置，下面再定义两个不同环境的配置类，继承自基类，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">    DEBUG = <span class="literal">False</span></span><br><span class="line">    LOG_LEVEL = <span class="string">&quot;INFO&quot;</span></span><br><span class="line">    SQLALCHEMY_ECHO = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DevelopmentConfig</span>(<span class="title class_ inherited__">Config</span>):</span><br><span class="line">    DEBUG = <span class="literal">True</span></span><br><span class="line">    LOG_LEVEL = <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line">    <span class="comment"># 查询时会显示原始SQL语句</span></span><br><span class="line">    SQLALCHEMY_ECHO = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 数据库连接格式</span></span><br><span class="line">    SQLALCHEMY_DATABASE_URI = <span class="string">&quot;mysql+pymysql://root:YfyH98333498.@localhost:3306/python_ops?charset=utf8&quot;</span></span><br><span class="line">    <span class="comment"># 动态追踪修改设置，如未设置只会提示警告</span></span><br><span class="line">    SQLALCHEMY_TRACK_MODIFICATIONS = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 数据库连接池的大小</span></span><br><span class="line">    SQLALCHEMY_POOL_SIZE = <span class="number">10</span></span><br><span class="line">    <span class="comment"># 指定数据库连接池的超时时间</span></span><br><span class="line">    SQLALCHEMY_POOL_TIMEOUT = <span class="number">10</span></span><br><span class="line">    <span class="comment"># 控制在连接池达到最大值后可以创建的连接数。当这些额外的 连接回收到连接池后将会被断开和抛弃。</span></span><br><span class="line">    SQLALCHEMY_MAX_OVERFLOW = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductionConfig</span>(<span class="title class_ inherited__">Config</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config_mapper = &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: DevelopmentConfig,</span><br><span class="line">    <span class="string">&quot;prod&quot;</span>: ProductionConfig,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在“工厂应用”中给app做配置，通过环境变量区分应该使用哪一个环境的配置类，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> config_mapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>(<span class="params">env: <span class="built_in">str</span> = <span class="string">&quot;dev&quot;</span></span>) -&gt; Flask:</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="comment"># register configuration</span></span><br><span class="line">    app.config.from_object(config_mapper[env])</span><br><span class="line">    <span class="comment"># register blueprint</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"><span class="comment"># run.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> create_app</span><br><span class="line"></span><br><span class="line">env = os.getenv(<span class="string">&quot;env&quot;</span>, <span class="string">&quot;dev&quot;</span>)</span><br><span class="line">app = create_app(env)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>到目前为止已经完成了Flask应用到初步改造，下面就需要对项目的目录稍作调整即可。</p>
<h2 id="项目布局"><a href="#项目布局" class="headerlink" title="项目布局"></a>项目布局</h2><p>完整的项目布局如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/application --------- 应用目录</span><br><span class="line">||models ------------ 数据表模型目录</span><br><span class="line">||  |__init__.py</span><br><span class="line">||  |action.py ------- 执行命令模型</span><br><span class="line">||  |cmdb.py --------- 设备模型</span><br><span class="line">||  | </span><br><span class="line">||views ------------- 路由目录</span><br><span class="line">||  |__init__.py</span><br><span class="line">||  |action.py ------- 执行命令的路由</span><br><span class="line">||  |cmdb.py --------- 设备信息的路由</span><br><span class="line">||  |</span><br><span class="line">||services ---------- 业务逻辑目录</span><br><span class="line">||  |action.py ------- 获取命令的逻辑代码</span><br><span class="line">||  |cmdb.py --------- 获取设备的逻辑代码</span><br><span class="line">||  |executor.py ----- 执行器的逻辑代码</span><br><span class="line">||  |</span><br><span class="line">||__init__.py ------- 应用工厂目录</span><br><span class="line">|config.py ----------- 配置文件</span><br><span class="line">|utils.py ------------ 工具方法文件</span><br><span class="line">|run.py ------------- 启动文件</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Flask构建大型应用的基本布局就讲解完了，有很多需要注意的细节和需要大家仔细体会的编程思想，希望大家可以结合代码仔细的阅读研究。下一章节我会继续完善Flask的后段应用，让它变得更加的健壮，一起期待吧。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Netmiko</tag>
        <tag>巡检</tag>
      </tags>
  </entry>
  <entry>
    <title>2.8 自动化运维初级村-巡检-Flask大型应用-下</title>
    <url>/posts/9e8f3190.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>经过上一章节的重构之后，我们已经把设备和命令的增删改查成功的集成到了Flask应用中，并且后端应用也具备了大型项目的雏形。</p>
<p>今天的章节则会对应用做更进一步的完善和延伸处理，希望大家可以从中学到如何把自己的代码变得能够在生产环境中安全稳定的运行。</p>
<span id="more"></span>

<h1 id="路由函数"><a href="#路由函数" class="headerlink" title="路由函数"></a>路由函数</h1><p>首先需要实现设备和命令的增删改查功能的路由函数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /application/views/action.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint, request</span><br><span class="line"><span class="keyword">from</span> ..models <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> ..services <span class="keyword">import</span> ActionORMHandler</span><br><span class="line"></span><br><span class="line">action_blueprint = Blueprint(<span class="string">&quot;action&quot;</span>, __name__, url_prefix=<span class="string">&quot;/action&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@action_blueprint.route(<span class="params"><span class="string">&quot;/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    ActionORMHandler(db.session()).add(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@action_blueprint.route(<span class="params"><span class="string">&quot;delete&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    ActionORMHandler(db.session()).delete(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@action_blueprint.route(<span class="params"><span class="string">&quot;update&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    ActionORMHandler(db.session()).update(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@action_blueprint.route(<span class="params"><span class="string">&quot;/get&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    args = request.args.to_dict()</span><br><span class="line">    res = ActionORMHandler(db.session()).get(args)</span><br><span class="line">    <span class="keyword">return</span> [item.to_dict() <span class="keyword">for</span> item <span class="keyword">in</span> res]</span><br><span class="line"><span class="comment"># /application/views/cmdb.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint, request</span><br><span class="line"><span class="keyword">from</span> ..models <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> ..services <span class="keyword">import</span> DeviceORMHandler</span><br><span class="line"></span><br><span class="line">cmdb_blueprint = Blueprint(<span class="string">&quot;cmdb&quot;</span>, __name__, url_prefix=<span class="string">&quot;/cmdb&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cmdb_blueprint.route(<span class="params"><span class="string">&quot;/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    DeviceORMHandler(db.session()).add(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cmdb_blueprint.route(<span class="params"><span class="string">&quot;/delete&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    DeviceORMHandler(db.session()).delete(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cmdb_blueprint.route(<span class="params"><span class="string">&quot;/update&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    DeviceORMHandler(db.session()).update(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cmdb_blueprint.route(<span class="params"><span class="string">&quot;/get&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    res = DeviceORMHandler(db.session()).get()</span><br><span class="line">    <span class="keyword">return</span> [item.to_dict() <span class="keyword">for</span> item <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>

<p>设备和命令的相关路由函数非常简单，只需要调用services中提供的DeviceHandler和ActionHandler即可，这也是把代码合理分层的最重要原因——让代码变得更具有易读性和可维护性。</p>
<p>下面注册SSH执行器相关的路由函数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /application/views/executor.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint, request, current_app</span><br><span class="line"><span class="keyword">from</span> ..models <span class="keyword">import</span> db, Action</span><br><span class="line"><span class="keyword">from</span> ..services <span class="keyword">import</span> DeviceORMHandler, ActionORMHandler, SSHExecutor</span><br><span class="line"></span><br><span class="line">executor_blueprint = Blueprint(<span class="string">&quot;executor&quot;</span>, __name__, url_prefix=<span class="string">&quot;/executor&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@executor_blueprint.route(<span class="params"><span class="string">&quot;/prompt&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_prompt</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    device_handler = DeviceORMHandler(db.session())</span><br><span class="line">    action_handler = ActionORMHandler(db.session())</span><br><span class="line">    ssh_executor = SSHExecutor(</span><br><span class="line">        username=current_app.config.get(<span class="string">&quot;SSH_USERNAME&quot;</span>),</span><br><span class="line">        password=current_app.config.get(<span class="string">&quot;SSH_PASSWORD&quot;</span>),</span><br><span class="line">        secret=current_app.config.get(<span class="string">&quot;SSH_SECRET&quot;</span>),</span><br><span class="line">        device_condition=data.get(<span class="string">&quot;device_condition&quot;</span>),</span><br><span class="line">        device_handler=device_handler,</span><br><span class="line">        action_handler=action_handler,</span><br><span class="line">        logger=current_app.logger)</span><br><span class="line">    prompt = ssh_executor.conn.base_prompt</span><br><span class="line">    ssh_executor.close()</span><br><span class="line">    <span class="keyword">return</span> prompt</span><br></pre></td></tr></table></figure>

<p>上述代码中，创建了新的蓝图，将与执行器有关的路由都注册到executor_blueprint上；</p>
<p>除此之外我将需要注意的地方高亮了出来：</p>
<ul>
<li>路由函数允许接受的方法：methods&#x3D;[“POST”]</li>
<li>获取JSON类型的body请求体：request.get_json()</li>
<li>获取配置信息：current_app.config.get(“”)</li>
<li>获取已注册的logger（下文提到）：current_app.logger</li>
</ul>
<h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><p>之前的章节中提到过可以使用postman类型的插件或扩展进行接口测试，这一章节我们用另外一种方式进行测试；</p>
<p>如果使用的是PyCharm的话，可以在目录里新建后缀为.http的文件，内容如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"># api.http</span><br><span class="line"></span><br><span class="line">POST http://127.0.0.1:5000/executor/prompt</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;device_condition&quot;:  &#123;&quot;ip&quot;:  &quot;192.168.31.149&quot;&#125;&#125;</span><br><span class="line">###</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/04/08/eh7Tu183zUcPNWw.png" alt="img"></p>
<p>可以点击左侧的绿色箭头直接出发http请求，其中Content-Type是http请求里body的类型，该类型需要和后端保持一致。</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>一个部署在生产环境的项目，就一定需要有完整的异常处理；</p>
<p>Flask中的内部异常继承的是HTTPException这个异常类，这个异常类来自Werkzeug；</p>
<p>Werkzeug不是一个框架，它是一个 WSGI 工具集的库，你可以通过它来创建你自己的框架或 Web 应用，之前的章节中提到Web框架必须符合WSGI标准协议，而Flask就是借助Werkzeug来作为实现WSGI标准的底层库，自己再此之上构建Web框架，关系图如下：</p>
<p><img src="https://s2.loli.net/2023/04/08/QCE1M6VrfbRN9K5.png" alt="img"></p>
<p>HTTPException的源码大致如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HTTPException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    code: t.<span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span></span><br><span class="line">    description: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        description: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        response: t.<span class="type">Optional</span>[<span class="string">&quot;Response&quot;</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> description <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.description = description</span><br><span class="line">        self.response = response</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_body</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        environ: t.<span class="type">Optional</span>[<span class="string">&quot;WSGIEnvironment&quot;</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        scope: t.<span class="type">Optional</span>[<span class="built_in">dict</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Get the HTML body.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="string">&quot;&lt;!doctype html&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;&lt;html lang=en&gt;\n&quot;</span></span><br><span class="line">            <span class="string">f&quot;&lt;title&gt;<span class="subst">&#123;self.code&#125;</span> <span class="subst">&#123;escape(self.name)&#125;</span>&lt;/title&gt;\n&quot;</span></span><br><span class="line">            <span class="string">f&quot;&lt;h1&gt;<span class="subst">&#123;escape(self.name)&#125;</span>&lt;/h1&gt;\n&quot;</span></span><br><span class="line">            <span class="string">f&quot;<span class="subst">&#123;self.get_description(environ)&#125;</span>\n&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_headers</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        environ: t.<span class="type">Optional</span>[<span class="string">&quot;WSGIEnvironment&quot;</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        scope: t.<span class="type">Optional</span>[<span class="built_in">dict</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; t.<span class="type">List</span>[t.<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Get a list of headers.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> [(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html; charset=utf-8&quot;</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_response</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        environ: t.<span class="type">Optional</span>[t.<span class="type">Union</span>[<span class="string">&quot;WSGIEnvironment&quot;</span>, <span class="string">&quot;WSGIRequest&quot;</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        scope: t.<span class="type">Optional</span>[<span class="built_in">dict</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="string">&quot;Response&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> self.response <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.response</span><br><span class="line">        <span class="keyword">if</span> environ <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            environ = _get_environ(environ)</span><br><span class="line">        headers = self.get_headers(environ, scope)</span><br><span class="line">        <span class="keyword">return</span> WSGIResponse(self.get_body(environ, scope), self.code, headers)</span><br></pre></td></tr></table></figure>

<p>可以发现其中有几个最为重要的函数，分别是get_body，get_headers， get_response；get_response返回的是一个WSGIResponse的对象，它需要传入body，code， headers。</p>
<p>所以如果我们想实现一个自定义的异常类，那就只需要继承HTTPException，并且实现get_body，get_headers，并支持自定义code就可以了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /application/exception.py</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> werkzeug.exceptions <span class="keyword">import</span> HTTPException</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APIException</span>(<span class="title class_ inherited__">HTTPException</span>):</span><br><span class="line">    code = <span class="number">500</span></span><br><span class="line">    message = <span class="string">&#x27;API Exception&#x27;</span></span><br><span class="line">    data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, code=<span class="literal">None</span>, message=<span class="literal">None</span>, data=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> code <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.code = code</span><br><span class="line">        <span class="keyword">if</span> message <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.message = message</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.data = data</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(APIException, self).__init__(self.message, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_body</span>(<span class="params">self, environ=<span class="literal">None</span>, scope=<span class="literal">None</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        body = &#123;</span><br><span class="line">            <span class="string">&quot;data&quot;</span>: self.data,</span><br><span class="line">            <span class="string">&quot;status_code&quot;</span>: self.code,</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: self.message,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: request.method + <span class="string">&#x27; &#x27;</span> + self.get_url_without_param()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> json.dumps(body)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_headers</span>(<span class="params">self, environ=<span class="literal">None</span>, scope=<span class="literal">None</span></span>) -&gt; <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]]:</span><br><span class="line">        <span class="keyword">return</span> [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_url_without_param</span>() -&gt; <span class="built_in">str</span>:</span><br><span class="line">        full_url = <span class="built_in">str</span>(request.full_path)</span><br><span class="line">        <span class="keyword">return</span> full_url.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>原本的HTTPException中返回的是html文本，但我们的项目是以API的方式提供服务，所以后端的返回统一是JSON字符串，因此需要重写get_headers方法，将其返回类型改为application&#x2F;json，并且重写get_body方法，返回自定义的JSON字符串即可；初始化方法则改为可以接收code，message，data三个参数。</p>
<p>经过上述的改造就实现了一个自定义的异常类，异常类具体的使用方法如下：</p>
<p>先定义几个常见的异常类继承自APIException</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /application/exception.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(<span class="title class_ inherited__">APIException</span>):</span><br><span class="line">    code = <span class="number">200</span></span><br><span class="line">    message = <span class="string">&quot;success&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(self.code, self.message, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerError</span>(<span class="title class_ inherited__">APIException</span>):</span><br><span class="line">    code = <span class="number">500</span></span><br><span class="line">    message = <span class="string">&quot;server error&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBError</span>(<span class="title class_ inherited__">APIException</span>):</span><br><span class="line">    code = <span class="number">510</span></span><br><span class="line">    message = <span class="string">&quot;db error&quot;</span></span><br></pre></td></tr></table></figure>

<p>路由函数中抛出自定义异常类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /application/views/action.py</span></span><br><span class="line"><span class="keyword">from</span> ..exception <span class="keyword">import</span> Success, DBError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@action_blueprint.route(<span class="params"><span class="string">&quot;/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ActionORMHandler(db.session()).add(data)</span><br><span class="line">        <span class="keyword">return</span> Success()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> DBError(message=<span class="built_in">str</span>(e))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="meta">@action_blueprint.route(<span class="params"><span class="string">&quot;/get&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    args = request.args.to_dict()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = ActionORMHandler(db.session()).get(args)</span><br><span class="line">        <span class="keyword">return</span> Success(data=[item.to_dict() <span class="keyword">for</span> item <span class="keyword">in</span> res])</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> DBError(message=<span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>大型项目除了完善的异常处理，还有一个必不可少的就是日志记录，无论是在关键的逻辑处理地方主动打印的日志，还是意料之外的异常日志都需要记录下来</p>
<p>首先需要将日志的对象注册到app上，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application/__init__.py</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> RotatingFileHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>(<span class="params">env: <span class="built_in">str</span> = <span class="string">&quot;dev&quot;</span></span>) -&gt; Flask:</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="comment"># register configuration</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># register db</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># register blueprint</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># register logging</span></span><br><span class="line">    register_logging(app)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register_logging</span>(<span class="params">app</span>):</span><br><span class="line">    formatter = logging.Formatter(</span><br><span class="line">        <span class="string">&#x27;%(asctime)s %(levelname)s P[%(process)d] T[%(thread)d] %(lineno)sL@%(filename)s:&#x27;</span></span><br><span class="line">        <span class="string">&#x27; %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    handler = RotatingFileHandler(<span class="string">&quot;flask.log&quot;</span>, maxBytes=<span class="number">1024000</span>, backupCount=<span class="number">10</span>)</span><br><span class="line">    handler.setLevel(app.config.get(<span class="string">&quot;LOG_LEVEL&quot;</span>))</span><br><span class="line">    handler.setFormatter(formatter)</span><br><span class="line">    app.logger.addHandler(handler)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @app.before_request</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_each_request</span>():</span><br><span class="line">        app.logger.info(<span class="string">f&quot;[<span class="subst">&#123;request.method&#125;</span>]<span class="subst">&#123;request.path&#125;</span> from <span class="subst">&#123;request.remote_addr&#125;</span>, params <span class="subst">&#123;request.args.to_dict()&#125;</span>, body <span class="subst">&#123;request.get_data()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码中的register_logging函数中对日志做了一定的配置，包括通过formatter定义日志格式，通过RotatingFileHandler定义了根据数据大小进行切分的日志文件，并且设置了日志的打印级别，最后将日志对象添加到了app.logger上。</p>
<p>除此之外我们还希望将每次请求的信息记录下，诸如：请求的方法，路径，参数等；上述代码中用@app.before_request装饰的log_each_request就可以实现这个功能，该装饰器会在执行路由函数之前执行被装饰的函数，具体细节会在视频讲解中提到。</p>
<p>注册完日志对象后，可以通过如下方式记录日志：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /application/views/action.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> current_app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@action_blueprint.route(<span class="params"><span class="string">&quot;/add&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ActionORMHandler(db.session()).add(data)</span><br><span class="line">        current_app.logger.success(<span class="string">&quot;add success&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> Success()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> DBError(message=<span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

<p>此时访问该路由函数后，日志文件中会多一条记录：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">08</span>:<span class="number">24</span>,<span class="number">829</span> <span class="symbol">SUCCESS</span> <span class="symbol">P</span>[<span class="number">87068</span>] <span class="symbol">T</span>[<span class="number">123145357492224</span>] <span class="number">35</span><span class="symbol">L</span>@action.py: add success</span><br></pre></td></tr></table></figure>

<p>除了主动记录的日志之外，还有程序意外抛出的异常需要记录，那么这就需要对整个后端应用做一个try…except，这一点Flask已经考虑到了，并且也已经做了，我们只需要在这个地方使用刚才自定义的日志对象记录错误信息即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application/exception.py</span></span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register_errors</span>(<span class="params">app: Flask</span>):</span><br><span class="line"><span class="meta">    @app.errorhandler(<span class="params">Exception</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">framework_error</span>(<span class="params">e</span>):</span><br><span class="line">        app.logger.error(<span class="built_in">str</span>(e))</span><br><span class="line">        app.logger.error(traceback.format_exc())</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(e, APIException):  <span class="comment"># 手动触发的异常</span></span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(e, HTTPException):  <span class="comment"># 代码异常</span></span><br><span class="line">            <span class="keyword">return</span> APIException(e.code, e.description, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> app.config[<span class="string">&#x27;DEBUG&#x27;</span>]:</span><br><span class="line">                <span class="keyword">raise</span> e</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> ServerError()</span><br><span class="line"><span class="comment"># application/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> application.exception <span class="keyword">import</span> register_error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>(<span class="params">env: <span class="built_in">str</span> = <span class="string">&quot;dev&quot;</span></span>) -&gt; Flask:</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="comment"># register configuration</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># register db</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># register blueprint</span></span><br><span class="line">    <span class="comment"># ... </span></span><br><span class="line">    <span class="comment"># register logging</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    register_errors(app)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>

<h1 id="上下文（Context）"><a href="#上下文（Context）" class="headerlink" title="上下文（Context）"></a>上下文（Context）</h1><p>大家应该在最近的几个章节中可以频繁的看到，request、current_app这样的变量，这个就涉及到了Flask的上下文，也是Flask中比较难理解的部分，但对于初期的使用上来说，对这个概念是否理解并不会很大的影响应用的构建。</p>
<p>上下文顾名思义就是与某处相关的内容，那么代码中的上下文就是指与某处代码相关的变量或对象。</p>
<h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>提起上下文可能很多朋友会想到上下文管理器，这个是Python中较高级的特性，理论上属于一种语法糖；但上下文管理器和Flask中的上下文并无关联，这里只是顺便讲解一下。</p>
<p>我们可以通过改造SSHExecutor来给大家讲解一下如何使用上下文管理器，原本使用SSHExecutor的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh_executor = SSHExecutor(...)</span><br><span class="line">output = ssh_executor.execute(...)</span><br><span class="line">ssh_executor.close()</span><br></pre></td></tr></table></figure>

<p>通过上下文管理器来重构的话就可以变成如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> SSHExecutor(...) <span class="keyword">as</span> ssh:</span><br><span class="line">    output = ssh.execute(...)</span><br></pre></td></tr></table></figure>

<p>上述代码的作用就是可以在SSHExecutor创建和结束时执行相应的操作，比如结束时我们想自动关闭连接，而不是手动调用close()方法；通过这种方式就可以将SSHExecutor的上下文管理起来，故叫做上下文管理器。</p>
<p>很明显with…as…作为一种语法糖并不是可以想用就用的，因为Python不可能自动的识别某个对象在创建和结束时想执行的操作，所以需要我们基于要管理的对象来实现某些方法，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="keyword">if</span> exc_type:</span><br><span class="line">            self.logger.error(exc_type)</span><br><span class="line">            self.logger.error(exc_val)</span><br><span class="line">            self.logger.error(exc_tb)</span><br><span class="line">        self.close()</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，执行with … as …语句时，会初始化SSHExecutor并调用__enter__方法，将该方法的返回值赋值给as后的变量（这里其实相当于直接初始化了一个SSHExecutor实例，但如果有必要还可以自定义其他操作）；</p>
<p>当执行完with语句块内的内容后，就会自动调用__exit__方法结束上下文管理器，exc_type、exc_val、exc_tb变量的含义分别为：异常类型、异常值、异常堆栈；这样我们就可以在结束SSHExecutor的操作之后自动调用self.close()方法关闭连接，如果with语句块中有异常也可以进行相应的处理。</p>
<p>Python也有内置模块contextlib中提供一些装饰器实现相关的功能，但原理都是相同的。</p>
<h2 id="Flask上下文"><a href="#Flask上下文" class="headerlink" title="Flask上下文"></a>Flask上下文</h2><p>在Flask中，应用从客户端收到请求的时候，视图函数如果要处理请求，可能就要访问一些相关的对象，比如有关此次请求的各种属性，或者有关app的相关变量，这些就统称为Flask的上下文。</p>
<p>如果要清晰的解释Flask上下文，就必须要涉及到源码的解读，但考虑到部分源码讲解起来较难理解，反而会导致刚接触Flask的朋友更为困惑，所以我这里将上下文的原理通俗易懂的解释一下</p>
<p>Flask中的上下文分为两种：</p>
<ul>
<li>请求上下文：request，session</li>
<li>应用上下文：current_app，g</li>
</ul>
<h3 id="作为全局变量"><a href="#作为全局变量" class="headerlink" title="作为全局变量"></a>作为全局变量</h3><p>不管是请求上下文还是应用上下文都是全局变量，可以直接通过import的方式引入，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, session, current_app, g</span><br></pre></td></tr></table></figure>

<p>全局变量的好处就是可以不用将其作为参数传递，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, g</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">print</span>(request.args)</span><br><span class="line">    g.username = <span class="string">&#x27;ethan&#x27;</span></span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># b.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(request.method)</span><br><span class="line">    <span class="built_in">print</span>(g.username)</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，在路由函数中调用utils文件中的test()函数，两个函数中都想打印请求的method，但不需要将request作为参数传递，而是分别在两个文件中直接导入request即可；current_app、g、session同理。</p>
<h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>请求上下文或应用上下文在处理多个的请求时互相不会干扰，因为Flask内部将其处理为线程隔离的对象，大致实现的方式可以理解为将线程ID作为字典的键，存储的上下文内容作为值，跟路由区分不同蓝图的实现原理很类似。</p>
<h3 id="生命周期和存储内容"><a href="#生命周期和存储内容" class="headerlink" title="生命周期和存储内容"></a>生命周期和存储内容</h3><p>请求上下文和应用上下文都是有生命周期的，他们都伴随请求创建，并在请求结束后销毁。</p>
<ul>
<li>request：接收到请求后创建，存储了此次请求的相关信息，如请求头，请求体等</li>
<li>session：与request同时创建，默认加载请求中的cookies内容，否则创建一个空的session</li>
<li>current_app：接收到请求后创建，但稍晚于request，等同于此刻的app对象，可以完美解决对app的循环引用，</li>
<li>g：与current_app同时创建，默认没有存储值，可以用来存储自定义内容，用法如上述代码中所示，</li>
</ul>
<p>所有的上下文都会在请求结束后销毁，但session与其他的上下文有一个不同的就是，Flask会在销毁session前默认将session的内容写入到返回体的cookie中（可以新增一个配置项：SESSION_REFRESH_EACH_REQUEST，并将其设为True，则不会去更新返回体的cookie）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章节结束后Flask大型应用的构建就已经结束了，从文件拆分，到路由蓝图，再加上环境配置、异常处理，最后完成和SSH执行器的结合。现在已经具备了将远程CLI进行服务化的基本能力。</p>
<p>文章中所讲的内容只是我给大家提供一个基本的思路，以此来完成各个知识点的串联，以及对大家编程思维的培养，大家不必完全局限于文章中所讲，可以结合已有的编程知识尽情发挥。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Netmiko</tag>
        <tag>巡检</tag>
      </tags>
  </entry>
  <entry>
    <title>2.9 自动化运维初级村-巡检-文本解析-正则</title>
    <url>/posts/82c9e913.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在初级村的巡检模块涉及的章节中，我带领着大家从零开始设计规划，并且针对SSH执行器，设备和命令的增删改查，以及Flask大型应用的布局与重构，都做了非常详细的讲解；到目前为止，巡检模块已经具备雏形，但还差一个十分重要的部分——文本解析，今天及之后的几个章节我都会围绕这一部分展开讲解。</p>
<span id="more"></span>

<h1 id="正则-vs-TextFSM"><a href="#正则-vs-TextFSM" class="headerlink" title="正则 vs TextFSM"></a>正则 vs TextFSM</h1><p>文本解析看似不复杂的知识，但我在整个新手村中都没有提及，并且选择在巡检模块的最后才来讲解，这是因为我对这一部分非常重视，而较为原始的文本解析正是通过正则表达式来实现，但以我个人的经历来说，想要理解并且写好正则表达式并不是一件容易的事。</p>
<p>很多稍微了解过自动化运维的朋友可能会问为什么不直接讲解与Netmiko有很好结合的TextFSM？</p>
<p>这里我就不得不提到我出教程的宗旨——最小化上手范围，虽然我多次提及到这一点，但很多朋友其实并不理解其重要性，或者是选择性忽视。</p>
<p>我在自己或同行的交流群中每天都会看到有人问各种各样的问题，其中不乏关于TextFSM的，但说实话某些问题很难解答，比如：“这段输出内容我想用TextFSM匹配怎么没有结果？”，或者“我想要匹配出xxx应该怎么写TextFSM？”等等。结果解释到最后，提问者连最基本的正则匹配都没有概念，正所谓“授人以鱼不如授人以渔”，别人是没有办法穷举解决所有模版的，只能将原理解释清楚，剩下靠“自悟”。</p>
<p>我所推荐的“快速上手”是指尽量压缩上手成本，绝不是copy一份代码，改改运行起来就叫“上手”，而且我觉得这样做也并没有什么意义。</p>
<p>正则表达式与TextFSM之间并没有孰优孰劣，而是相辅相成。</p>
<p>正则具有灵活的匹配方式，而且是TextFSM的底层原理；而TextFSM有更加系统的匹配模式，更适合作为解析模版。</p>
<p>综上，我想表达的是正则表达式的学习其实是TextFSM的上手前提，TextFSM其实是合理运用正则的一种高级封装，我们要学习如何使用他，更要了解其原理，才能更进一步的体会其思想；切不可囫囵吞枣，事倍功半。</p>
<h1 id="正则表达式（Regexp）"><a href="#正则表达式（Regexp）" class="headerlink" title="正则表达式（Regexp）"></a>正则表达式（Regexp）</h1><p>正则匹配是一种文本匹配的模式，正则表达式则是用来描述这种匹配的一串字符。</p>
<p>百度百科对正则表达式的定义是这样的：</p>
<blockquote>
<p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>
</blockquote>
<p>在不同的编程语言中，对于正则表达式的编写都会有些微的差别，但其基本的逻辑和常用的匹配字符都是<strong>通用</strong>的。</p>
<p>正则表达式的一大特点就是灵活，但最大的缺点就是晦涩，对于新手朋友来说学习正则表达式的过程都会相对比较痛苦，但我会尽量选择性的讲解必要的知识，并通过例子来让大家尽快熟悉。</p>
<p>在之前的章节中的我们有讲到Netmiko执行完命令后获取输出结果有两种模式（基于模式&#x2F;时间），其中基于模式匹配的机制（send_command）就是运用了正则匹配的方法，通过判断输出的结果是否包含search_pattern来决定是否输出完成，这里的包含并不是指字面上的字符串是否包含，而是使用了正则匹配来判断，所以大家也可以在执行send_command的时候，将expect_string传成正则表达式。</p>
<p>讲到此处，大家对于正则表达式都只是有一个模糊的概念，下面我举一个例子：</p>
<p>假如在程序中想验证一下某个字符串是否为合法的IPv4地址格式，有很多种方法，可以通过纯代码的方式实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">valid_ipv4</span>(<span class="params">ip</span>):</span><br><span class="line">    segments = ip.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(segments) != <span class="number">4</span>:  <span class="comment"># 如果不是四段，则非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> segments:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> seg.isdigit():  <span class="comment"># 如果某一段不是0或正整数，则非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(seg) &gt; <span class="number">255</span>:  <span class="comment"># 如果大于255，则非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 合法</span></span><br></pre></td></tr></table></figure>

<p>也可以通过正则表达式来进行匹配，一般写正则表达式的思路都是循序渐进的；</p>
<p>首先IPv4地址分为四段，每一段都是0-255的数字，段和段之间由点号隔开，所以难点在于如何匹配0-255。</p>
<h2 id="字符集合匹配表达式"><a href="#字符集合匹配表达式" class="headerlink" title="字符集合匹配表达式"></a>字符集合匹配表达式</h2><p>正则表达式中，可以通过字符集合来表示匹配集合中的任意一个字符，例如：</p>
<ul>
<li>“[abc]”可以匹配目标字符串中的“a”或者“b”或者“c”，“[0-9]”可以匹配目标字符串中任意一个0-9范围内的数字。</li>
</ul>
<p>那么可不可以用“[0-255]”直接匹配呢？答案是不可以，因为字符集合的中括号内必须由一个一个的字符组成，短横线只是一种简写，比如“[a-z]”或者“[A-Z]”，假如想匹配全部的大小写字母，就必须是“[a-zA-Z]”。显然“[0-255]”只能匹配四个数字（0、1、2、5）。</p>
<h2 id="特殊字符匹配表达式"><a href="#特殊字符匹配表达式" class="headerlink" title="特殊字符匹配表达式"></a>特殊字符匹配表达式</h2><p>正则表达式中，存在一些特殊字符来表示匹配多个字符中的任意一个字符，可以认为是字符集合的特殊版，例如：</p>
<ul>
<li>“.”可以匹配除了\r和\n之外的任意字符。</li>
<li>“\d”可以匹配任意一个数字，等价于“[0-9]”。</li>
<li>“\w”可以匹配任意一个单词字符和下划线，类似于“[_a-zA-Z]”，但不完全相同，“\w”可以匹配Unicode中的任意一个字符，也包括中文，大家可以简单的理解为可以匹配任意一个字符即可。</li>
<li>“\s”可以匹配任何不可见字符，包括空格、制表符、换页符等等。等价于“[ \f\n\r\t\v]”（注意中括号里有一个空格）。</li>
<li>另外还有“\D”“\W”“\S”，均为以上小写特殊字符的反向匹配。</li>
</ul>
<p>那么可不可以用特殊字符来进行匹配，比如“\d\d\d”？答案是不完全可以。如果在确认此处一定会出现IPv4地址，只是想将其过滤出来的话可以用较为粗粒度（不怎么精确）的正则表达式对其进行匹配；</p>
<p>如果用不精确的匹配的话除了用“\d”，还可以用“\S\S\S”来表示三个任意可见字符。</p>
<h2 id="表达式重复"><a href="#表达式重复" class="headerlink" title="表达式重复"></a>表达式重复</h2><p>特殊字符里，我们用了三个相同的符号表示三个数字，在正则中可以用简单的方式来表示表达式的重复次数，例如：</p>
<ul>
<li>“?”可以匹配前面的子表达式零次或一次，比如“\d?”，表示零个或一个数字；该字符还有非贪婪匹配的含义，此处暂且不提，感兴趣的朋友可以自行研究。</li>
<li>“<em>”可以匹配前面的子表达式任意次，比如“\d</em>”，表示零个或任意多个连续的数字。</li>
<li>“+”可以匹配前面的子表达式至少一次，比如“\d+”，表示一个及以上任意多个连续的数字。</li>
<li>“{n}”可以匹配前面的子表达式n次，比如“\d{3}”，表示三个连续的数字。</li>
<li>“{n,}”可以匹配前面的子表达式至少n次，比如“\d{3,}”，表示三个或更多个连续的数字。</li>
<li>“{n,m}”可以匹配前面的子表达式至少n次，至多m次，比如“\d{1,2}”，表示一个或两个连续的数字。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除了上述几个分类外，还有几个匹配表达式平时会需要用到，例如：</p>
<ul>
<li>“|”表示或，比如“x|y”，表示匹配x或y字符</li>
<li>“\”表示转义，比如“.”，表示匹配目标字符串中的点，而非代表正则表达式中的任意字符符号</li>
<li>“(pattern)”表示获取匹配，比如“(\d{3}.){4}”，表示匹配连续三个数字加一个点号，并重复四次，并会在返回的group结果中获取到连续的三个数字，在不同的编程语言中有不同的获取方法。</li>
<li>“(?:pattern)”表示非获取匹配，比如“(?:\d{3}.){4}”，表示匹配连续三个数字加一个点号，并重复四次。</li>
<li>“^”表示匹配行首，比如“^\d”，表示目标字符串的开头必须是数字（但匹配的行为是否设置了多行匹配的模式有关，具体不做展开）。</li>
<li>“$”表示匹配行尾</li>
</ul>
<h1 id="匹配IPv4"><a href="#匹配IPv4" class="headerlink" title="匹配IPv4"></a>匹配IPv4</h1><p>经过上述知识点的讲解，大家应该可以写出匹配IPv4的表达式了，我在下面列举几种从不精确到完全精确的写法：</p>
<ul>
<li>“(?:\d+.){3}\d+”</li>
<li>“(?:\d{0,3}.){3}\d{0,3}”</li>
<li>“(?:(?:[1-9]?\d|1\d\d|2[0-4]\d|25[0-5]).){3}(?:[1-9]?\d|1\d\d|2[0-4]\d|25[0-5])”</li>
</ul>
<p>大多数情况下，在解析文本时，只需要使用第二条正则便可以过滤出IPv4，但在验证用户输入的时候，则有必要使用第三种最为精确的匹配。</p>
<p>具体上述三个表达式的讲解我会在视频中提到。</p>
<h1 id="Python正则表达式"><a href="#Python正则表达式" class="headerlink" title="Python正则表达式"></a>Python正则表达式</h1><p>上文中所讲的正则表达式都是针对所有编程语言都适用的，但一直有提到“匹配”这个词，究竟如何匹配，是在不同的编程语言中有不同方法的。</p>
<p>Python中进行正则匹配需要引入一个模块re，这是一个内置模块，不需要安装；该模块提供了很多的函数用于做正则匹配或正则替换，以及具备一些特殊的常量实现额外的匹配功能，但我们这一章节并不会讲解，我只把几个最常用的给大家解释一下，让大家先初步了解如何使用Python进行正则匹配。</p>
<h2 id="表达式写法"><a href="#表达式写法" class="headerlink" title="表达式写法"></a>表达式写法</h2><p>Python中的正则表达式通常都写为<code>r&#39;&#39;</code>，大家可以先不用深究为什么这么写，只需要知道这样写可以避免一些不必要的转义即可。</p>
<h2 id="正则匹配函数"><a href="#正则匹配函数" class="headerlink" title="正则匹配函数"></a>正则匹配函数</h2><p>re模块中有几个常见的正则匹配函数，分别是match，search，findall，正则匹配函数会将匹配到的结果返回。</p>
<h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a>re.match</h3><p>该函数的功能是使用正则表达式从目标字符串的开头去匹配，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.<span class="keyword">match</span>(<span class="string">r&#x27;(?:\d&#123;0,3&#125;\.)&#123;3&#125;\d&#123;0,3&#125;&#x27;</span>, <span class="string">&quot;127.0.0.1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># &lt;re.Match object; span=(0, 9), match=&#x27;127.0.0.1&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(res.group())</span><br><span class="line"><span class="comment"># 127.0.0.1</span></span><br><span class="line">res = re.<span class="keyword">match</span>(<span class="string">r&#x27;(?:\d&#123;0,3&#125;\.)&#123;3&#125;\d&#123;0,3&#125;&#x27;</span>, <span class="string">&quot;a127.0.0.1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res.group())</span><br><span class="line"><span class="comment"># AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;group&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上述例子中re.match返回一个Match对象，通过.group()方法可以获取到匹配结果，由于第二个匹配中目标字符串的开头有一个字母，所以匹配的结果为None，调用.group()方法时就抛出了AttributeError异常。</p>
<blockquote>
<p>re.Match对象有很多个方法和属性，其中最为常用的就是.group()，表示获取匹配结果的第一个分组，关于分组的详细原理大家可以自行了解，文章中先不做详细的解释。</p>
</blockquote>
<h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a>re.search</h3><p>该函数的功能和re.match基本相同，但并不要求必须从目标字符串的开头匹配，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = re.search(<span class="string">r&#x27;(?:\d&#123;0,3&#125;\.)&#123;3&#125;\d&#123;0,3&#125;&#x27;</span>, <span class="string">&quot;a127.0.0.1a127.0.0.3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res.group())</span><br><span class="line"><span class="comment"># 127.0.0.1</span></span><br></pre></td></tr></table></figure>

<h3 id="re-fullmatch"><a href="#re-fullmatch" class="headerlink" title="re.fullmatch"></a>re.fullmatch</h3><p>该函数的功能和re.match基本相同，但要求字符串必须完整匹配，即头尾也匹配，这里就不做举例了</p>
<h3 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall"></a>re.findall</h3><p>上述三个函数都只会返回一个匹配项，但大多数情况我们想要匹配一个文本中的内容时，都会包含一个及以上的结果，比如show ip interface的输出结果，其中就会包含多个IP地址，这时候就要使用findall函数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = re.findall(<span class="string">r&#x27;(?:\d&#123;0,3&#125;\.)&#123;3&#125;\d&#123;0,3&#125;&#x27;</span>, <span class="string">&quot;a127.0.0.1a127.0.0.3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># [&#x27;127.0.0.1&#x27;, &#x27;127.0.0.3&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>该函数匹配过程类似于re.search，但会返回多个结果，且以列表的形式返回。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章节主要是给大家做一下正则表达式的科普，本身正则表达式的编写并不会特别复杂，但需要掌握的知识点较为零碎，所以我希望尽可能的精简，并且通过匹配IP的例子将其串联起来，让大家尽快熟悉正则表达式，也能为后续学习TextFSM打好基础。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>巡检</tag>
        <tag>正则</tag>
        <tag>文本解析</tag>
      </tags>
  </entry>
  <entry>
    <title>2.10 自动化运维初级村-巡检-文本解析-从正则到TextFSM</title>
    <url>/posts/94cbed9d.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>上一章节中相信大家已经对正则表达式有了基本的概念，正如我之前提到的，单纯看完知识点的介绍只能算作“记忆”，如果没有实践，就算把正则表达式全部的规则都背会了，也不能算作“学会”。今天这一章节我会带领大家实践一下如何针对实际的文本编写正则表达式。</p>
<p>但为什么标题是“文本解析-从正则到TextFSM”呢，因为有很多朋友一开始就想从TextFSM上手，但TextFSM究竟比正则强在哪儿？TextFSM所遵循的状态转移和匹配机制究竟是如何产生又是如何运用的？</p>
<p>在我带领大家实践正则表达式的过程中，大家会发现如此灵活的正则匹配的短板在哪里？而这些短板恰恰就是催生TextFSM的重要因素。</p>
<span id="more"></span>

<h1 id="简单文本匹配"><a href="#简单文本匹配" class="headerlink" title="简单文本匹配"></a>简单文本匹配</h1><p>我们以Cisco设备上执行“show clock”的输出为原始文本，由于输出文本足够简单，非常适合作为第一个例子来讲解，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18:42:41.321 CST Sun Jan 1 2023</span><br></pre></td></tr></table></figure>

<p>现在想根据上述输出内容匹配几个关键信息，分别是：时间、时区、月份、日、年。</p>
<p>通过正则表达式来匹配的话会有好几种方式，我这里提供一个示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">stdout = <span class="string">&quot;18:42:41.321 CST Sun Jan 1 2023&quot;</span></span><br><span class="line"><span class="comment"># 括号表示获取匹配，最终会将括号内结果返回</span></span><br><span class="line">regexp = <span class="string">r&#x27;(..:..:..\....) (\w+) \w+ (\w+) (\d+) (\d+)&#x27;</span></span><br><span class="line">result = re.findall(regexp, stdout)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出结果 [(&#x27;18:42:41.321&#x27;, &#x27;CST&#x27;, &#x27;Jan&#x27;, &#x27;1&#x27;, &#x27;2023&#x27;)]</span></span><br></pre></td></tr></table></figure>

<p>对于从一串文本中想要匹配指定的几个关键信息，通过正则表达式更为方便。</p>
<p>但有一个非常显而易见的缺陷，那就是我们通过“获取匹配”的方式来筛选匹配关键信息，如果一串文本中的关键信息有很多个，那正则表达式就会变得非常冗长，且最终较难区分哪个匹配结果对应哪个信息。比如上面例子中想要返回可读的结构化数据通常还需要做如下处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res_dict = &#123;</span><br><span class="line">    <span class="string">&quot;time&quot;</span>: result[<span class="number">0</span>][<span class="number">0</span>], </span><br><span class="line">    <span class="string">&quot;timezone&quot;</span>: result[<span class="number">0</span>][<span class="number">1</span>], </span><br><span class="line">    <span class="string">&quot;month&quot;</span>: result[<span class="number">0</span>][<span class="number">2</span>], </span><br><span class="line">    <span class="string">&quot;day&quot;</span>: result[<span class="number">0</span>][<span class="number">3</span>], </span><br><span class="line">    <span class="string">&quot;year&quot;</span>: result[<span class="number">0</span>][<span class="number">4</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以到目前为止，根据一个简单的示例可以延伸分析得出，<strong>我们需要一个机制能够标识匹配表达式所对应的信息字段名称</strong>；但光有这一点，还不足以让编程人员弃用表达式，因为关键信息再多也是有限的，再不济也就是多写几个下标索引罢了。</p>
<h1 id="多行文本匹配"><a href="#多行文本匹配" class="headerlink" title="多行文本匹配"></a>多行文本匹配</h1><p>如果输出内容是多行文本时，匹配的复杂度又会有一个新的提升，比如Cisco设备执行“show version”的输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cisco IOS Software, Catalyst 4500 L3 Switch Software (cat4500-ENTSERVICESK9-M), Version 12.2(31)SGA1, RELEASE SOFTWARE (fc3)</span><br><span class="line">Technical Support: http://www.cisco.com/techsupport</span><br><span class="line">Copyright (c) 1986-2007 by Cisco Systems, Inc.</span><br><span class="line">Compiled Fri 26-Jan-07 14:28 by kellythw</span><br><span class="line">Image text-base: 0x10000000, data-base: 0x118AD800</span><br><span class="line"></span><br><span class="line">ROM: 12.2(31r)SGA</span><br><span class="line">Pod Revision 0, Force Revision 34, Gill Revision 20</span><br><span class="line"></span><br><span class="line">router.abc uptime is 11 weeks, 4 days, 20 hours, 26 minutes</span><br><span class="line">System returned to ROM by reload</span><br><span class="line">System restarted at 22:49:40 PST Tue Nov 18 2008</span><br><span class="line">System image file is &quot;bootflash:cat4500-entservicesk9-mz.122-31.SGA1.bin&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This product contains cryptographic features and is subject to United</span><br><span class="line">States and local country laws governing import, export, transfer and</span><br><span class="line">use. Delivery of Cisco cryptographic products does not imply</span><br><span class="line">third-party authority to import, export, distribute or use encryption.</span><br><span class="line">Importers, exporters, distributors and users are responsible for</span><br><span class="line">compliance with U.S. and local country laws. By using this product you</span><br><span class="line">agree to comply with applicable laws and regulations. If you are unable</span><br><span class="line">to comply with U.S. and local laws, return this product immediately.</span><br><span class="line"></span><br><span class="line">A summary of U.S. laws governing Cisco cryptographic products may be found at:</span><br><span class="line">http://www.cisco.com/wwl/export/crypto/tool/stqrg.html</span><br><span class="line"></span><br><span class="line">If you require further assistance please contact us by sending email to</span><br><span class="line">export@cisco.com.</span><br><span class="line"></span><br><span class="line">cisco WS-C4948-10GE (MPC8540) processor (revision 5) with 262144K bytes of memory.</span><br><span class="line">Processor board ID FOX111700ZN</span><br><span class="line">MPC8540 CPU at 667Mhz, Fixed Module</span><br><span class="line">Last reset from Reload</span><br><span class="line">2 Virtual Ethernet interfaces</span><br><span class="line">48 Gigabit Ethernet interfaces</span><br><span class="line">2 Ten Gigabit Ethernet interfaces</span><br><span class="line">511K bytes of non-volatile configuration memory.</span><br><span class="line"></span><br><span class="line">Configuration register is 0x2102</span><br></pre></td></tr></table></figure>

<p>现在我们的目标仍然是获取几个关键信息，包括：版本号、启动时长、镜像文件、重置原因。</p>
<p>虽然需要从多行文本中去匹配信息，但仍然可以通过正则表达式来实现，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">stdout = <span class="string">&quot;output of show version&quot;</span></span><br><span class="line">regexp = <span class="string">r&#x27;Cisco IOS .*Version (\S+),.*uptime is (.*?)\n.*System image file is &quot;(.*)&quot;.*Last reset from (\w+)&#x27;</span></span><br><span class="line">result = re.findall(regexp, stdout, re.DOTALL)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot; 输出结果 [(</span></span><br><span class="line"><span class="string">    &#x27;12.2(31)SGA1&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;11 weeks, 4 days, 20 hours, 26 minutes&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;bootflash:cat4500-entservicesk9-mz.122-31.SGA1.bin&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;Reload&#x27;</span></span><br><span class="line"><span class="string">)]&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述的代码有两个需要注意的地方：</p>
<ul>
<li>re.findall函数中多传了一个参数，re.DOTALL，表示“.”可以匹配任何字符，包括换行符（默认不包括）。</li>
<li>正则表达式中的“.*?”，因为加了re.DOTALL参数，所以“.*”可以匹配任意多个字符（贪婪匹配特性会导致尽可能多的匹配字符），这样会导致不能准确的匹配到uptime所在行尾的\n，但加了?，会将贪婪匹配转为非贪婪匹配，此时就会尽可能少的匹配字符。</li>
</ul>
<p>虽然可以成功匹配出结果，但大家应该已经发现，多行文本的匹配中会存在更多因素影响匹配结果的准确性，所以以我个人经验来看，尽量不用正则表达式来匹配多行文本。</p>
<p>那是否可以改变匹配方式来进行匹配呢，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">stdout = <span class="string">&quot;output of show version&quot;</span></span><br><span class="line">version_regexp = <span class="string">r&#x27;^Cisco IOS .*Version (\S+),&#x27;</span></span><br><span class="line">uptime_regexp = <span class="string">r&#x27;.*uptime is (.*)&#x27;</span></span><br><span class="line">image_regexp = <span class="string">r&#x27;System image file is &quot;(.*)&quot;&#x27;</span></span><br><span class="line">reset_regexp = <span class="string">r&#x27;Last reset from (\w+)&#x27;</span></span><br><span class="line">regexps = [version_regexp, uptime_regexp, image_regexp, reset_regexp]</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> regexp <span class="keyword">in</span> regexps:</span><br><span class="line">    res = re.findall(regexp, stdout)</span><br><span class="line">    result.append(res[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;unknown&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot; 输出结果 [(</span></span><br><span class="line"><span class="string">    &#x27;12.2(31)SGA1&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;11 weeks, 4 days, 20 hours, 26 minutes&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;bootflash:cat4500-entservicesk9-mz.122-31.SGA1.bin&#x27;, </span></span><br><span class="line"><span class="string">    &#x27;Reload&#x27;</span></span><br><span class="line"><span class="string">)]&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过稍加改造后，将匹配不同信息的正则表达式分开定义，然后每个表达式匹配一次完整的字符串，最终就可以得出所有的匹配结果；但理论上已经匹配过的内容实际上不需要再次被匹配了，而且仍存在准确性问题，因为某个关键信息的正则表达式是对某一行进行匹配的，所以如果用该正则去匹配全文，可能会出现相似内容导致结果不准确，所以可以将文本内容分成一行行再去进行匹配，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">stdout = <span class="string">&quot;output of show version&quot;</span></span><br><span class="line">version_regexp = <span class="string">r&#x27;^Cisco IOS .*Version (\S+),&#x27;</span></span><br><span class="line">uptime_regexp = <span class="string">r&#x27;.*uptime is (.*)&#x27;</span></span><br><span class="line">image_regexp = <span class="string">r&#x27;^System image file is &quot;(.*)&quot;&#x27;</span></span><br><span class="line">reset_regexp = <span class="string">r&#x27;^Last reset from (\w+)&#x27;</span></span><br><span class="line">regexps = [version_regexp, uptime_regexp, image_regexp, reset_regexp]</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdout.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">    <span class="keyword">for</span> regexp <span class="keyword">in</span> regexps:</span><br><span class="line">        res = re.findall(regexp, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        result.append(res[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>此时就可以正则表达式前加一个“^”来表示匹配行首，这样可以大大增加匹配结果的准确性。</p>
<p>这里我希望大家可以着重理解上述代码的逻辑，因为这个逻辑其实已经和TextFSM的基本匹配逻辑非常相似，那就是：<strong>定义多个匹配规则，一行一行的读取文本，用该行去依次匹配每个正则，如果匹配到则读取新行，再次去和所有规则进行匹配。</strong></p>
<h1 id="复杂内容的匹配"><a href="#复杂内容的匹配" class="headerlink" title="复杂内容的匹配"></a>复杂内容的匹配</h1><p>简单文本和多行文本都是针对关键字信息的提取，虽然可以总结出一些优化逻辑，但整体上匹配过程相对简单，所以仍没有办法说服我们弃用正则，而选择TextFSM。</p>
<p>因为一旦引入一个新的第三方包，就意味着增加了更多的学习成本，而且会由于对于使用方法和原理的理解不够清晰，而导致增加更多的不稳定因素。</p>
<p>那么现在除了上述的信息提取外，还有一种在网络设备非常常见的输出内容，那就是表格类型的输出，比如“show ip route”的输出内容，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">    Destination        Gateway                      Dist/Metric Last Change</span><br><span class="line">     -----------        -------                      ----------- -----------</span><br><span class="line">B EX 0.0.0.0/0          via 192.0.2.73                  20/100        4w0d</span><br><span class="line">                        via 192.0.2.201</span><br><span class="line">                        via 192.0.2.202</span><br><span class="line">                        via 192.0.2.74</span><br><span class="line">B IN 192.0.2.76/30     via 203.0.113.183                200/100        4w2d</span><br><span class="line">B IN 192.0.2.204/30    via 203.0.113.183                200/100        4w2d</span><br><span class="line">B IN 192.0.2.80/30     via 203.0.113.183                200/100        4w2d</span><br><span class="line">B IN 192.0.2.208/30    via 203.0.113.183                200/100        4w2d</span><br></pre></td></tr></table></figure>

<p>上述的输出增加了一些难处理的内容，比如<strong>表头的多余内容，表格的结构，以及某个列中可能会包含多个值</strong>。</p>
<p>我们可以仍然尝试使用正则来进行处理，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">stdout = <span class="string">&quot;output of show ip route&quot;</span></span><br><span class="line">regexp = <span class="string">r&#x27;(\w) (\w+) (\S+)\s+via (\S+)\s+(\d+)/(\d+)\s+(\S+)&#x27;</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdout.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">    res = re.findall(regexp, line)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    result.append(res[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot; 输出内容 [</span></span><br><span class="line"><span class="string">    (&#x27;B&#x27;, &#x27;EX&#x27;, &#x27;0.0.0.0/0&#x27;, &#x27;192.0.2.73&#x27;, &#x27;20&#x27;, &#x27;100&#x27;, &#x27;4w0d&#x27;), </span></span><br><span class="line"><span class="string">    (&#x27;B&#x27;, &#x27;IN&#x27;, &#x27;192.0.2.76/30&#x27;, &#x27;203.0.113.183&#x27;, &#x27;200&#x27;, &#x27;100&#x27;, &#x27;4w2d&#x27;), </span></span><br><span class="line"><span class="string">    (&#x27;B&#x27;, &#x27;IN&#x27;, &#x27;192.0.2.204/30&#x27;, &#x27;203.0.113.183&#x27;, &#x27;200&#x27;, &#x27;100&#x27;, &#x27;4w2d&#x27;), </span></span><br><span class="line"><span class="string">    (&#x27;B&#x27;, &#x27;IN&#x27;, &#x27;192.0.2.80/30&#x27;, &#x27;203.0.113.183&#x27;, &#x27;200&#x27;, &#x27;100&#x27;, &#x27;4w2d&#x27;), </span></span><br><span class="line"><span class="string">    (&#x27;B&#x27;, &#x27;IN&#x27;, &#x27;192.0.2.208/30&#x27;, &#x27;203.0.113.183&#x27;, &#x27;200&#x27;, &#x27;100&#x27;, &#x27;4w2d&#x27;)</span></span><br><span class="line"><span class="string">]&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过代码的处理貌似可以提取出部分的信息，但仍然有最为关键的内容被错过了，那就是Gateway列的多个值。</p>
<p>最终想要的结果应该是Gateway列最终匹配到的值是一个列表，可以包含多个值，那么代码改造如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">stdout = <span class="string">&quot;output of show ip route&quot;</span></span><br><span class="line">regexp = <span class="string">r&#x27;(\w) (\w+) (\S+)\s+via (\S+)\s+(\d+)/(\d+)\s+(\S+)&#x27;</span></span><br><span class="line">gateway_regexp = <span class="string">r&#x27;\s+via (\S+)&#x27;</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdout.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">    res = re.findall(regexp, line)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        route = <span class="built_in">list</span>(res[<span class="number">0</span>])</span><br><span class="line">        route[<span class="number">3</span>] = [route[<span class="number">3</span>]]</span><br><span class="line">        result.append(route)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    col = re.findall(gateway_regexp, line)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> col:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result) &gt; <span class="number">0</span>:</span><br><span class="line">        result[-<span class="number">1</span>][<span class="number">3</span>].append(col[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot;输出内容 [</span></span><br><span class="line"><span class="string">    [&#x27;B&#x27;, &#x27;EX&#x27;, &#x27;0.0.0.0/0&#x27;, [&#x27;192.0.2.73&#x27;, &#x27;192.0.2.201&#x27;, &#x27;192.0.2.202&#x27;, &#x27;192.0.2.74&#x27;], &#x27;20&#x27;, &#x27;100&#x27;, &#x27;4w0d&#x27;], </span></span><br><span class="line"><span class="string">    [&#x27;B&#x27;, &#x27;IN&#x27;, &#x27;192.0.2.76/30&#x27;, [&#x27;203.0.113.183&#x27;], &#x27;200&#x27;, &#x27;100&#x27;, &#x27;4w2d&#x27;], </span></span><br><span class="line"><span class="string">    [&#x27;B&#x27;, &#x27;IN&#x27;, &#x27;192.0.2.204/30&#x27;, [&#x27;203.0.113.183&#x27;], &#x27;200&#x27;, &#x27;100&#x27;, &#x27;4w2d&#x27;], </span></span><br><span class="line"><span class="string">    [&#x27;B&#x27;, &#x27;IN&#x27;, &#x27;192.0.2.80/30&#x27;, [&#x27;203.0.113.183&#x27;], &#x27;200&#x27;, &#x27;100&#x27;, &#x27;4w2d&#x27;], </span></span><br><span class="line"><span class="string">    [&#x27;B&#x27;, &#x27;IN&#x27;, &#x27;192.0.2.208/30&#x27;, [&#x27;203.0.113.183&#x27;], &#x27;200&#x27;, &#x27;100&#x27;, &#x27;4w2d&#x27;]</span></span><br><span class="line"><span class="string">]&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中定义了两个正则语句，并且在匹配过程中进行了额外的处理，虽然最终得到了正确的结果，但实现的过程也是非常“hack”，这种情况显然不是我们想要的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然上述三个例子都通过正则表达式+代码的逻辑完成了输出内容的结构化处理，但有几个地方是不符合预期的：</p>
<ul>
<li>匹配规则和结果缺少字段标识</li>
<li>处理多行文本+多个正则表达式时引入的额外代码逻辑</li>
<li>处理表格类型文本+多值字段时引入的额外代码逻辑</li>
</ul>
<p>讲到这里我仍然想说的是，上述的三个缺点在处理有限的内容时也并不足以让我们弃用正则表达式，而引入TextFSM，比如某个简单的需求只想要解析指定几个输出内容，那么解析的逻辑和规则时可以穷举的，只需要将对应输出内容的解析方法封装成相应的函数，然后直接的调用即可。</p>
<p>但在我们的巡检场景或者更为大型的系统中，要处理的输出内容是无法穷举的，随时会有可能新增某个巡检项，如果所有的解析逻辑都通过封装函数来一一对应处理，那么这种方式并不符合程序设计的原则。</p>
<p>我们的预期是想要通过某种方式来实现解析逻辑的抽象化，只需要维护解析模版即可，将解析模版以文件的形式保存或者存储在数据库中，这样就可以随时新增某个模版来应对需要处理的内容，而没有必要改动代码逻辑。而TextFSM正好可以帮助我们实现，而在我看来这才是需要引入TextFSM的真正原因。</p>
<p>如果大家只是想要写某个脚本来处理有限的输出内容而引入TextFSM，那显然是脱离了“最小化上手原则”，并且我希望大家能够学会根据需求合理的选择工具的使用。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>巡检</tag>
        <tag>正则</tag>
        <tag>文本解析</tag>
        <tag>TextFSM</tag>
      </tags>
  </entry>
  <entry>
    <title>2.12 自动化运维初级村-巡检-TextFSM-2</title>
    <url>/posts/af22ed7b.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>经过前面两个章节的学习，我们已经初步掌握了正则表达式的原理，并从正则解析一步一步过渡到了 TextFSM，而且 TextFSM 在匹配机制上和对于大型项目的重要性上都让我们非常有必要将他集成到巡检模块中。</p>
<p>那么这一章节我们就主要讲解一下如何在 Python 中使用 TextFSM，以及如何将其集成到巡检框架中。</p>
<span id="more"></span>

<h1 id="Python-TextFSM"><a href="#Python-TextFSM" class="headerlink" title="Python+TextFSM"></a>Python+TextFSM</h1><p>Python 中使用 TextFSM 需要安装一个第三方包，执行下列命令即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install textfsm</span><br></pre></td></tr></table></figure>

<h2 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h2><p>上一个章节中我们已经举了三个使用 TextFSM 模板进行匹配的例子，但并没有演示在 Python 中如何使用模板进行文本解析。</p>
<p>而且大家最为熟知的 TextFSM 使用方法都是直接将其和 Netmiko 等模块结合使用，这种方式也很方便，我们后续同样会使用；但在此之前，我想说的是，TextFSM 本质就是一个模板解析的第三方库，所以肯定是可以用来解析任何文本的，不光局限于网络设备的输出；所以我先给大家讲解一下 Python 中是如何直接使用 TextFSM 进行解析的。</p>
<h3 id="用模版文件解析"><a href="#用模版文件解析" class="headerlink" title="用模版文件解析"></a>用模版文件解析</h3><p>首先将模版内容保存在单独的文件中，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># route.tmpl</span></span><br><span class="line">Value Protocol (\S)</span><br><span class="line">Value Type (\S\S)</span><br><span class="line">Value Required Prefix (\S+)</span><br><span class="line">Value List Gateway (\S+)</span><br><span class="line">Value Distance (\d+)</span><br><span class="line">Value Metric (\d+)</span><br><span class="line">Value LastChange (\S+)</span><br><span class="line"></span><br><span class="line">Start</span><br><span class="line">  ^.*----- -&gt; Routes</span><br><span class="line"></span><br><span class="line">Routes</span><br><span class="line">  ^\s\s\S\s\S\S -&gt; Continue.Record</span><br><span class="line">  ^\s\s<span class="variable">$&#123;Protocol&#125;</span> <span class="variable">$&#123;Type&#125;</span> <span class="variable">$&#123;Prefix&#125;</span>\s+via <span class="variable">$&#123;Gateway&#125;</span>\s+<span class="variable">$&#123;Distance&#125;</span>/<span class="variable">$&#123;Metric&#125;</span>\s+<span class="variable">$&#123;LastChange&#125;</span></span><br><span class="line">  ^\s+via <span class="variable">$&#123;Gateway&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>这里需要说明的是，我经过测试模版文件的后缀并没有强制要求，之所以保存为 .tmpl 后缀，只是为了更为方便的识别该文件为模板文件。</strong></p>
<p>Python 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> textfsm <span class="keyword">import</span> TextFSM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_from_file</span>():</span><br><span class="line">    stdout = <span class="string">&quot;&quot;&quot;       Destination        Gateway                      Dist/Metric Last Change</span></span><br><span class="line"><span class="string">           -----------        -------                      ----------- -----------</span></span><br><span class="line"><span class="string">      B EX 0.0.0.0/0          via 192.0.2.73                  20/100        4w0d</span></span><br><span class="line"><span class="string">                              via 192.0.2.201</span></span><br><span class="line"><span class="string">                              via 192.0.2.202</span></span><br><span class="line"><span class="string">                              via 192.0.2.74</span></span><br><span class="line"><span class="string">      B IN 192.0.2.76/30     via 203.0.113.183                200/100        4w2d</span></span><br><span class="line"><span class="string">      B IN 192.0.2.204/30    via 203.0.113.183                200/100        4w2d</span></span><br><span class="line"><span class="string">      B IN 192.0.2.80/30     via 203.0.113.183                200/100        4w2d</span></span><br><span class="line"><span class="string">      B IN 192.0.2.208/30    via 203.0.113.183                200/100        4w2d&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;route.tmpl&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        fsm = TextFSM(f)</span><br><span class="line">    res = fsm.ParseTextToDicts(stdout)</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(res, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parse_from_file()</span><br></pre></td></tr></table></figure>

<p>上述代码中从 textfsm 库中引入了 TextFSM 类，之后将 “route.tmpl” 模板经过 open() 打开后得到一个文件对象，将其传入 TextFSM 类中，得到一个 TextFSM 的实例化对象。</p>
<p>该对象有两个方法是最常使用的，分别是 ParseText() 和 ParseTextToDicts()，这两个方法解析的过程都是一样的，不同的就是呈现结果的结构不一样，前者是以列表的形式返回解析结果，后者是以字典的形式。</p>
<p>通常使用的是后者，因为可以清晰的知道哪个值对应哪个字段，更有利于解析结果处理的准确性和代码的健壮性。</p>
<p>这里我将解析结果用 json 模块处理了一下，更方便打印输出展示，上述代码的输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Protocol&quot;</span>: <span class="string">&quot;B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;EX&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Prefix&quot;</span>: <span class="string">&quot;0.0.0.0/0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gateway&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;192.0.2.73&quot;</span>,</span><br><span class="line">      <span class="string">&quot;192.0.2.201&quot;</span>,</span><br><span class="line">      <span class="string">&quot;192.0.2.202&quot;</span>,</span><br><span class="line">      <span class="string">&quot;192.0.2.74&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;Distance&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Metric&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LastChange&quot;</span>: <span class="string">&quot;4w0d&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Protocol&quot;</span>: <span class="string">&quot;B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;IN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Prefix&quot;</span>: <span class="string">&quot;192.0.2.76/30&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gateway&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;203.0.113.183&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;Distance&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Metric&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LastChange&quot;</span>: <span class="string">&quot;4w2d&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Protocol&quot;</span>: <span class="string">&quot;B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;IN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Prefix&quot;</span>: <span class="string">&quot;192.0.2.204/30&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gateway&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;203.0.113.183&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;Distance&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Metric&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LastChange&quot;</span>: <span class="string">&quot;4w2d&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Protocol&quot;</span>: <span class="string">&quot;B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;IN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Prefix&quot;</span>: <span class="string">&quot;192.0.2.80/30&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gateway&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;203.0.113.183&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;Distance&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Metric&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LastChange&quot;</span>: <span class="string">&quot;4w2d&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Protocol&quot;</span>: <span class="string">&quot;B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;IN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Prefix&quot;</span>: <span class="string">&quot;192.0.2.208/30&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gateway&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;203.0.113.183&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;Distance&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Metric&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LastChange&quot;</span>: <span class="string">&quot;4w2d&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="用模板字符串解析"><a href="#用模板字符串解析" class="headerlink" title="用模板字符串解析"></a>用模板字符串解析</h3><p>目前大家常见的都是上述将模板保存到文件中，然后去解析，但实际项目中模板的内容并不一定是在文件中，因为如果要将解析过程集成到巡检功能中的话，就需要将模板的管理线上化，而通过服务器文件形式进行管理并不是很好的选择，在多进程的情况下可能会出现多个解析线程都去使用同一个模板解析内容，这时候还需要考虑文件锁。</p>
<p>那么既然 TextFSM 模板是字符串，那理所当然我们可以将它保存到数据库中进行管理，这样也更有利于更删改查。</p>
<p>所以当从数据库中读取到 TextFSM 模板后，模板内容在程序中实际是一个字符串，那这时候怎么进行解析呢？</p>
<p>从模板文件中解析的时候，初始化 TextFSM 对象需要传入一个打开的文件对象，那么我们可以从这里做文章。</p>
<p>计算机读取一个文件后，实际上是将该文件放在了内存中，供后续的程序使用，那么我们只需要传入一个内存中的文件流，就可以让 TextFSM 解析了。</p>
<p>在 Python 中，StringIO 可以将字符串转化为内存中的 IO 流，具备和使用 open() 方法打开文件后获取到的文件对象几乎相同的属性和方法，所以代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">from</span> textfsm <span class="keyword">import</span> TextFSM</span><br><span class="line"></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;Value Protocol (\S)</span></span><br><span class="line"><span class="string">Value Type (\S\S)</span></span><br><span class="line"><span class="string">Value Required Prefix (\S+)</span></span><br><span class="line"><span class="string">Value List Gateway (\S+)</span></span><br><span class="line"><span class="string">Value Distance (\d+)</span></span><br><span class="line"><span class="string">Value Metric (\d+)</span></span><br><span class="line"><span class="string">Value LastChange (\S+)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Start</span></span><br><span class="line"><span class="string">  ^.*----- -&gt; Routes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Routes</span></span><br><span class="line"><span class="string">  ^\s\s\S\s\S\S -&gt; Continue.Record</span></span><br><span class="line"><span class="string">  ^\s\s$&#123;Protocol&#125; $&#123;Type&#125; $&#123;Prefix&#125;\s+via $&#123;Gateway&#125;\s+$&#123;Distance&#125;/$&#123;Metric&#125;\s+$&#123;LastChange&#125;</span></span><br><span class="line"><span class="string">  ^\s+via $&#123;Gateway&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">stdout = <span class="string">&quot;&quot;&quot;       Destination        Gateway                      Dist/Metric Last Change</span></span><br><span class="line"><span class="string">       -----------        -------                      ----------- -----------</span></span><br><span class="line"><span class="string">  B EX 0.0.0.0/0          via 192.0.2.73                  20/100        4w0d</span></span><br><span class="line"><span class="string">                          via 192.0.2.201</span></span><br><span class="line"><span class="string">                          via 192.0.2.202</span></span><br><span class="line"><span class="string">                          via 192.0.2.74</span></span><br><span class="line"><span class="string">  B IN 192.0.2.76/30     via 203.0.113.183                200/100        4w2d</span></span><br><span class="line"><span class="string">  B IN 192.0.2.204/30    via 203.0.113.183                200/100        4w2d</span></span><br><span class="line"><span class="string">  B IN 192.0.2.80/30     via 203.0.113.183                200/100        4w2d</span></span><br><span class="line"><span class="string">  B IN 192.0.2.208/30    via 203.0.113.183                200/100        4w2d&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_from_str</span>():</span><br><span class="line">    fsm = TextFSM(StringIO(template))</span><br><span class="line">    res = fsm.ParseTextToDicts(stdout)</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(res, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parse_from_str()</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们把模板定义成了一个变量，并且在初始化 TextFSM 类的时候传入了经过 StringIO() 处理的文件流对象，这样同样可以完成解析，而且调试起来也非常方便。</p>
<p>输出结果与刚才完全相同。</p>
<h2 id="ntc-template的使用"><a href="#ntc-template的使用" class="headerlink" title="ntc-template的使用"></a>ntc-template的使用</h2><p>在开源项目中，ntc-template 这个项目将知名厂商的最为常用的交换机命令的输出结果进行了解析，并开源了对应的解析模版（值得大家致敬一下）。</p>
<p>这个库的好处就是只需要传入（厂商、命令、输出）就可以返回解析的结果，但如果要解析的命令在库中还没有对应的模板，那就需要做一些定制化的处理，具体的流程如下：</p>
<ol>
<li>将 ntc-templates 库中的 templates 目录拷贝到你的项目中</li>
<li>在环境变量 NTC_TEMPLATES_DIR 改为你上一步的自定义目录（可以在系统中更改或者在代码中更改）</li>
<li>在第一步的目录中添加自己的解析模板，并且添加相应规则到 index 文件中，格式如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“&#123;解析模板名称&#125;, .*, &#123;设备的平台&#125;, &#123;执行的命令&#125;”</span><br></pre></td></tr></table></figure>

<p>但我个人并不推荐这种方式，首先是文件形式存储模板的缺点，我们在上文中已经提到了，另外就是每次添加自己的模版都要修改 index 文件并不是很友好；但考虑到内容的完整性，所以有必要进行上述步骤的介绍，对以上方式更为认可的朋友可以采用。</p>
<h2 id="Netmiko中结合-ntc-template"><a href="#Netmiko中结合-ntc-template" class="headerlink" title="Netmiko中结合 ntc-template"></a>Netmiko中结合 ntc-template</h2><p>在Netmiko中同样集成了解析功能，包括 TTP、TextFSM、Genie三种，并且在 TextFSM 方式里将 ntc-template 集成了进去，所以我们可以直接将执行命令完输出的结果进行解析，并返回结构化的内容，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">params, command</span>):</span><br><span class="line">    conn = ConnectHandler(**params)</span><br><span class="line">    output = conn.send_command(command, use_textfsm=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(output, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&quot;device_type&quot;</span>: <span class="string">&quot;cisco_ios&quot;</span>,</span><br><span class="line">        <span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.31.149&quot;</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;cisco&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;cisco&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    command = <span class="string">&quot;show version&quot;</span></span><br><span class="line">    connect(params, command)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; output</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    &quot;version&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">    &quot;rommon&quot;: &quot;Bootstrap&quot;,</span></span><br><span class="line"><span class="string">    &quot;hostname&quot;: &quot;r1&quot;,</span></span><br><span class="line"><span class="string">    &quot;uptime&quot;: &quot;22 weeks, 23 hours, 23 minutes&quot;,</span></span><br><span class="line"><span class="string">    &quot;uptime_years&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">    &quot;uptime_weeks&quot;: &quot;22&quot;,</span></span><br><span class="line"><span class="string">    &quot;uptime_days&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="string">    &quot;uptime_hours&quot;: &quot;23&quot;,</span></span><br><span class="line"><span class="string">    &quot;uptime_minutes&quot;: &quot;23&quot;,</span></span><br><span class="line"><span class="string">    &quot;reload_reason&quot;: &quot;Unknown reason&quot;,</span></span><br><span class="line"><span class="string">    &quot;running_image&quot;: &quot;/opt/unetlab/addons/iol/bin/i86bi-linux-l3-adventerprisek9-15.4&quot;,</span></span><br><span class="line"><span class="string">    &quot;hardware&quot;: [],</span></span><br><span class="line"><span class="string">    &quot;serial&quot;: [</span></span><br><span class="line"><span class="string">      &quot;67108896&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &quot;config_register&quot;: &quot;0x0&quot;,</span></span><br><span class="line"><span class="string">    &quot;mac&quot;: [],</span></span><br><span class="line"><span class="string">    &quot;restarted&quot;: &quot;&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中我们只需要在调用 send_command 时传入 use_textfsm&#x3D;True 即可开启TextFSM的解析功能，本质上就是在获取到命令输出之后调用 ntc-template 进行了解析。</p>
<h1 id="巡检解析"><a href="#巡检解析" class="headerlink" title="巡检解析"></a>巡检解析</h1><h2 id="Netmiko-TextFSM"><a href="#Netmiko-TextFSM" class="headerlink" title="Netmiko + TextFSM"></a>Netmiko + TextFSM</h2><p>上文中介绍了 Netmiko 中内置了 TextFSM 解析的功能，本质上是调用了 ntc-template 模块，但由于 ntc-template 的自定义方式不够灵活，所以并不适合集成到我们的巡检功能中，因此需要结合「模版字符串解析」的方式进行适当的改造，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> textfsm <span class="keyword">import</span> TextFSM</span><br><span class="line"><span class="keyword">from</span> netmiko <span class="keyword">import</span> ConnectHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_from_str</span>(<span class="params">output: <span class="built_in">str</span>, template: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">Dict</span>]:</span><br><span class="line">    fsm = TextFSM(StringIO(template))</span><br><span class="line">    res = fsm.ParseTextToDicts(output)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">params: <span class="type">Dict</span>, command: <span class="built_in">str</span>, template: <span class="built_in">str</span></span>):</span><br><span class="line">    conn = ConnectHandler(**params)</span><br><span class="line">    output = conn.send_command(command)</span><br><span class="line">    res = parse_from_str(output, template)</span><br><span class="line">    <span class="built_in">print</span>(json.dumps(res, indent=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&quot;device_type&quot;</span>: <span class="string">&quot;cisco_ios&quot;</span>,</span><br><span class="line">        <span class="string">&quot;host&quot;</span>: <span class="string">&quot;192.168.31.149&quot;</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;cisco&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;cisco&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    template = <span class="string">&quot;&quot;&quot;模版内容从数据库中读取&quot;&quot;&quot;</span></span><br><span class="line">    command = <span class="string">&quot;show version&quot;</span></span><br><span class="line">    connect(params, command, template)</span><br></pre></td></tr></table></figure>

<p>上述代码中，在执行完 send_command 后，将输出内容和模板变量一起传入到 parse_from_str 方法中即可；该方法与直接使用 send_command 方法的解析功能没有本质的区别，因为底层都是用了 TextFSM进行解析，但不同的是获取模板的方式，改为了可以被灵活处理，这里为了更好的与巡检功能结合，后续我们会从数据库中获取模板内容。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章节主要介绍了如何在 Python 中使用 TextFSM，并且根据逐步的过渡，已经可以初步看出如何将其集成到我们的巡检功能中了，下一章节就正式让巡检模块具备解析功能，并将其完整的运行起来。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>巡检</tag>
        <tag>文本解析</tag>
        <tag>TextFSM</tag>
      </tags>
  </entry>
  <entry>
    <title>2.11 自动化运维初级村-巡检-TextFSM</title>
    <url>/posts/3a4924fc.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>上一章节中，我已经给大家演示了如何使用正则来应对常见的几种文本解析场景，但使用正则解析的过程中发现了几个明显的痛点，如果要在我们初级村中设计的巡检模块中补齐文本解析的功能，那么正则是无法担此重任的，所以有必要引入新的文本解析方式，那就是-TextFSM。</p>
<span id="more"></span>

<h1 id="TextFSM简介"><a href="#TextFSM简介" class="headerlink" title="TextFSM简介"></a>TextFSM简介</h1><p>首先正则解析的痛点我们已经总结了出来，如下：</p>
<ul>
<li>匹配规则和结果缺少字段标识</li>
<li>处理多行文本+多个正则表达式时引入的额外代码逻辑</li>
<li>处理表格类型文本+多值字段时引入的额外代码逻辑</li>
</ul>
<p>TextFSM本质上就是一个文本解析的工具包，谷歌的工程师研发出了TextFSM这个工具包就是为了解决解析网络设备输出过程中的痛点，TextFSM的优势如下：</p>
<ul>
<li>将待提取的信息定义为变量</li>
<li>内置匹配多行文本的逻辑，减轻编程负担</li>
<li>通过内置的状态和动作逻辑，灵活的解析表格类型文本</li>
<li>抽象匹配逻辑，让模版只做“模版”</li>
</ul>
<h1 id="TextFSM详解"><a href="#TextFSM详解" class="headerlink" title="TextFSM详解"></a>TextFSM详解</h1><p>这一章节同样以上个章节的示例进行演示，大家可以体会一下同样的场景使用TextFSM相比正则是否更为方便。</p>
<h2 id="简单文本解析"><a href="#简单文本解析" class="headerlink" title="简单文本解析"></a>简单文本解析</h2><p>以匹配Cisco设备上执行“show clock”的输出为例子，使用TextFSM模版来匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18:42:41.321 CST Sun Jan 1 2023</span><br></pre></td></tr></table></figure>

<p>现在想根据上述输出内容匹配几个关键信息，分别是：时间、时区、月份、日、年。</p>
<p>使用TextFSM进行解析需要定义一个模版，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Value Year (\d+)</span><br><span class="line">Value MonthDay (\d+)</span><br><span class="line">Value Month (\w+)</span><br><span class="line">Value Timezone (\S+)</span><br><span class="line">Value Time (..:..:..)</span><br><span class="line"></span><br><span class="line">Start</span><br><span class="line">  ^$&#123;Time&#125;.* $&#123;Timezone&#125; \w+ $&#123;Month&#125; $&#123;MonthDay&#125; $&#123;Year&#125; -&gt; Record</span><br></pre></td></tr></table></figure>

<p>上述的模版由两部分组成，分别是<strong>变量定义部分</strong>和<strong>状态转移</strong>部分；状态转移部分又包含状态定义和规则。</p>
<h2 id="模版格式"><a href="#模版格式" class="headerlink" title="模版格式"></a>模版格式</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>格式是<code>Value 选项 变量名 (正则表达式)</code>，其实就是将想要匹配的信息字段定义成一个变量，一个字段就被称为一个“Value”。</p>
<p>选项字段大家可以大概了解一下，但从定义看可能不太好理解，后续可以在例子中进行体会：</p>
<p>Filldown：如果该值在这一行为匹配到，那么将该变量填充为上一次匹配到的值。</p>
<p>Fillup：与Filldown类似，但是填充为下一次匹配到的值。</p>
<p>List：如果该字段不是List，那么在记录的时候会记录最新的一次匹配值，如果是List则会把该字段处理为列表，把匹配到的值都加在列表里。</p>
<p>Required：表示该变量为必须，如果某一行文本没匹配到这个变量，那么其他匹配到的值也丢弃。</p>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><p>可以理解为从某个状态开始然后转换到另一个状态。</p>
<h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><p>TextFSM中的状态转移是从Start状态开始，最终到EOF状态结束；</p>
<p>Start是必须在模版里写上的，下面必须包含匹配规则，当逐行读取文本读取到EOF时，表示匹配结束，则执行 <strong>EOF</strong> 状态，这是一个隐式状态，不需要写在模版里。</p>
<p>像这种有始有终的状态机就叫做有限状态机。</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p><strong>在状态的下面一行可以写多个规则（Rule），但缩进必须是一个空格，且必须有</strong>**<code>^</code>**<strong>代表从行首进行匹配。</strong></p>
<p>TextFSM匹配的逻辑是进入到一个状态后，读取当前的文本行，用该文本行去和该状态下的每个规则去匹配，“匹配”的过程其实就是正则匹配，不同的是“规则”中的变量是提前定义的。</p>
<p><code>^$&#123;Time&#125;.* $&#123;Timezone&#125; \w+ $&#123;Month&#125; $&#123;MonthDay&#125; $&#123;Year&#125;</code>规则</p>
<p>等同于<code>^(..:..:..).* (\S+) \w+ (\w+) (\d+) (\d+)</code>。</p>
<blockquote>
<p>所以说TextFSM本质上还是正则匹配，只不过是封装了很多逻辑来简化除正则匹配之外的代码逻辑。</p>
</blockquote>
<p>如果单纯的看操作的定义可能会有些晦涩，不过可以结合我们上一章节的内容进行理解就会非常清晰，上一章节中我们用代码实现了逐行匹配的逻辑，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">version_regexp = <span class="string">r&#x27;^Cisco IOS .*Version (\S+),&#x27;</span></span><br><span class="line">uptime_regexp = <span class="string">r&#x27;.*uptime is (.*)&#x27;</span></span><br><span class="line">image_regexp = <span class="string">r&#x27;^System image file is &quot;(.*)&quot;&#x27;</span></span><br><span class="line">reset_regexp = <span class="string">r&#x27;^Last reset from (\w+)&#x27;</span></span><br><span class="line">regexps = [version_regexp, uptime_regexp, image_regexp, reset_regexp]</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdout.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">    <span class="keyword">for</span> regexp <span class="keyword">in</span> regexps:</span><br><span class="line">        res = re.findall(regexp, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        result.append(res[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>上述代码中的多个regexp变量就等同于TextFSM中的Value定义；</p>
<p><code>regexps</code>是一个包含多个正则的数组，那么它就相当于TextFSM某个状态下的多个规则，可以看做我们的代码中所有的规则都在Start状态下。</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>TextFSM的机制里，命中某个规则后会执行规则后衔接的操作。</p>
<p>每条规则后面可以使用<code>-&gt;</code>衔接一个或多个操作，多个操作的格式为<code>-&gt; A.B.C</code>，操作共分为四类：</p>
<h5 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h5><ul>
<li>Next：表示命中该规则后继续读取下一行，并从当前状态的第一个规则开始重新匹配；</li>
<li>Continue：表示命中该规则后仍然使用这一行，继续进行下一个规则的匹配；</li>
</ul>
<p>上述代码匹配的过程就是逐行读取文本，然后用regexps数组中的每个规则去匹配，如果匹配到，就读取下一行，然后再用regexps中的每个规则去匹配；这就相当于行操作里的“Next”；</p>
<p>而Continue就是把代码中的“break”去掉，在匹配到regexps中的某个规则后，继续用下一个规则去匹配，而不去读取新行。</p>
<h5 id="记录操作"><a href="#记录操作" class="headerlink" title="记录操作"></a>记录操作</h5><p>“记录”大家可以理解为上述代码中的<code>result.append(res[0])</code>，就是把匹配的结果保存下来的意思</p>
<ul>
<li>NonRecord：表示什么都不做。</li>
<li>Record：从上次执行记录之后匹配到的所有值进行记录，当指定了该规则中某个变量为Required，且该变量没匹配到值时，则全都不做记录。<ul>
<li>还有另外两个操作很少用到，这里就不做解释。</li>
</ul>
</li>
</ul>
<h5 id="状态转移操作"><a href="#状态转移操作" class="headerlink" title="状态转移操作"></a>状态转移操作</h5><ul>
<li>新状态：读取下一行，并进入到指定状态，进行规则匹配。</li>
</ul>
<h5 id="错误操作"><a href="#错误操作" class="headerlink" title="错误操作"></a>错误操作</h5><ul>
<li>Error 错误信息：表示匹配到该行后则抛出错误信息，终止匹配，并丢弃全部记录。</li>
</ul>
<p><strong>未指定任何action的时候相当于执行Next.NoRecord</strong></p>
<h2 id="匹配多行文本"><a href="#匹配多行文本" class="headerlink" title="匹配多行文本"></a>匹配多行文本</h2><p>我们再以匹配多行文本为例子，看看如何写TextFSM的模版。</p>
<p>匹配的内容仍然用上一章节中的”show version”的输出，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cisco IOS Software, Catalyst 4500 L3 Switch Software (cat4500-ENTSERVICESK9-M), Version 12.2(31)SGA1, RELEASE SOFTWARE (fc3)</span><br><span class="line">Technical Support: http://www.cisco.com/techsupport</span><br><span class="line">Copyright (c) 1986-2007 by Cisco Systems, Inc.</span><br><span class="line">Compiled Fri 26-Jan-07 14:28 by kellythw</span><br><span class="line">Image text-base: 0x10000000, data-base: 0x118AD800</span><br><span class="line"></span><br><span class="line">ROM: 12.2(31r)SGA</span><br><span class="line">Pod Revision 0, Force Revision 34, Gill Revision 20</span><br><span class="line"></span><br><span class="line">router.abc uptime is 11 weeks, 4 days, 20 hours, 26 minutes</span><br><span class="line">System returned to ROM by reload</span><br><span class="line">System restarted at 22:49:40 PST Tue Nov 18 2008</span><br><span class="line">System image file is &quot;bootflash:cat4500-entservicesk9-mz.122-31.SGA1.bin&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This product contains cryptographic features and is subject to United</span><br><span class="line">States and local country laws governing import, export, transfer and</span><br><span class="line">use. Delivery of Cisco cryptographic products does not imply</span><br><span class="line">third-party authority to import, export, distribute or use encryption.</span><br><span class="line">Importers, exporters, distributors and users are responsible for</span><br><span class="line">compliance with U.S. and local country laws. By using this product you</span><br><span class="line">agree to comply with applicable laws and regulations. If you are unable</span><br><span class="line">to comply with U.S. and local laws, return this product immediately.</span><br><span class="line"></span><br><span class="line">A summary of U.S. laws governing Cisco cryptographic products may be found at:</span><br><span class="line">http://www.cisco.com/wwl/export/crypto/tool/stqrg.html</span><br><span class="line"></span><br><span class="line">If you require further assistance please contact us by sending email to</span><br><span class="line">export@cisco.com.</span><br><span class="line"></span><br><span class="line">cisco WS-C4948-10GE (MPC8540) processor (revision 5) with 262144K bytes of memory.</span><br><span class="line">Processor board ID FOX111700ZN</span><br><span class="line">MPC8540 CPU at 667Mhz, Fixed Module</span><br><span class="line">Last reset from Reload</span><br><span class="line">2 Virtual Ethernet interfaces</span><br><span class="line">48 Gigabit Ethernet interfaces</span><br><span class="line">2 Ten Gigabit Ethernet interfaces</span><br><span class="line">511K bytes of non-volatile configuration memory.</span><br><span class="line"></span><br><span class="line">Configuration register is 0x2102</span><br></pre></td></tr></table></figure>

<p>现在我们的目标是获取几个关键信息，包括：版本号、启动时长、镜像文件、重置原因，模版如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value Version (\S+)</span><br><span class="line">Value Uptime (.*)</span><br><span class="line">Value Image (\S+)</span><br><span class="line">Value ResetReason (\w+)</span><br><span class="line"></span><br><span class="line">Start</span><br><span class="line">  ^Cisco IOS .*Version $&#123;Version&#125;,</span><br><span class="line">  ^.*uptime is $&#123;Uptime&#125;</span><br><span class="line">  ^System image file is &quot;&#123;Image&#125;&quot;</span><br><span class="line">  ^Last reset from $&#123;ResetReason&#125; -&gt; Record</span><br></pre></td></tr></table></figure>

<p>这个模版整体上来看还是比较简单的，跟我们上述的代码逻辑也是几乎一致，但区别在于Record操作放在了最后，那么就是在匹配到最后一个ResetReason之后再把之前到几个变量一起保存下来，相当于把我们代码的append操作后移了一下，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">tmp = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdout.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">    <span class="keyword">for</span> index, regexp <span class="keyword">in</span> <span class="built_in">enumerate</span>(regexps):</span><br><span class="line">        res = re.findall(regexp, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        tmp.append(res[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(regexps):</span><br><span class="line">            result.append(tmp)</span><br><span class="line">            tmp = []  <span class="comment"># clear tmp</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>先把规则中命中的值暂存在tmp中，如果出现Record操作呢，就把tmp添加到最终的结果里，这里<code>index == len(regexps)</code>表示当前规则是最后一个规则的时候，做Record。</p>
<h2 id="匹配复杂格式文本"><a href="#匹配复杂格式文本" class="headerlink" title="匹配复杂格式文本"></a>匹配复杂格式文本</h2><p>同样以我们上一章节匹配路由表的输出为例，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     Destination        Gateway                      Dist/Metric Last Change</span><br><span class="line">     -----------        -------                      ----------- -----------</span><br><span class="line">B EX 0.0.0.0/0          via 192.0.2.73                  20/100        4w0d</span><br><span class="line">                        via 192.0.2.201</span><br><span class="line">                        via 192.0.2.202</span><br><span class="line">                        via 192.0.2.74</span><br><span class="line">B IN 192.0.2.76/30     via 203.0.113.183                200/100        4w2d</span><br><span class="line">B IN 192.0.2.204/30    via 203.0.113.183                200/100        4w2d</span><br><span class="line">B IN 192.0.2.80/30     via 203.0.113.183                200/100        4w2d</span><br><span class="line">B IN 192.0.2.208/30    via 203.0.113.183                200/100        4w2d</span><br></pre></td></tr></table></figure>

<p>TextFSM模版如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value Protocol (\S)</span><br><span class="line">Value Type (\S\S)</span><br><span class="line">Value Required Prefix (\S+)</span><br><span class="line">Value List Gateway (\S+)</span><br><span class="line">Value Distance (\d+)</span><br><span class="line">Value Metric (\d+)</span><br><span class="line">Value LastChange (\S+)</span><br><span class="line"></span><br><span class="line">Start</span><br><span class="line">  ^.*----- -&gt; Routes</span><br><span class="line"></span><br><span class="line">Routes</span><br><span class="line">  ^\s\s\S\s\S\S -&gt; Continue.Record</span><br><span class="line">  ^\s\s$&#123;Protocol&#125; $&#123;Type&#125; $&#123;Prefix&#125;\s+via $&#123;Gateway&#125;\s+$&#123;Distance&#125;/$&#123;Metric&#125;\s+$&#123;LastChange&#125;</span><br><span class="line">  ^\s+via $&#123;Gateway&#125;</span><br></pre></td></tr></table></figure>

<p>上述的模版就会略微复杂了，我们下面结合上一章节中的代码逐步进行讲解，如果能完全理解这个模版，那么就算是基本入门TextFSM了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">stdout = <span class="string">&quot;output of show ip route&quot;</span></span><br><span class="line">regexp = <span class="string">r&#x27;(\w) (\w+) (\S+)\s+via (\S+)\s+(\d+)/(\d+)\s+(\S+)&#x27;</span></span><br><span class="line">gateway_regexp = <span class="string">r&#x27;\s+via (\S+)&#x27;</span></span><br><span class="line">result = []</span><br><span class="line">tmp = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdout.split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">    res = re.findall(regexp, line)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        <span class="keyword">if</span> tmp <span class="keyword">and</span> <span class="built_in">len</span>(tmp[-<span class="number">1</span>]) &gt; <span class="number">5</span>:</span><br><span class="line">            result.append(tmp)</span><br><span class="line">            tmp = []  <span class="comment"># clear tmp</span></span><br><span class="line">        route = <span class="built_in">list</span>(res[<span class="number">0</span>])</span><br><span class="line">        route[<span class="number">3</span>] = [route[<span class="number">3</span>]]</span><br><span class="line">        tmp.append(route)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    col = re.findall(gateway_regexp, line)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> col:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tmp) &gt; <span class="number">0</span>:</span><br><span class="line">        tmp[-<span class="number">1</span>][<span class="number">3</span>].append(col[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<h3 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h3><p>用到了“选项”中的Required和List：</p>
<p>Required表示匹配的时候必须存在路由前缀字段的值，如果该值没有，那么Record的时候就不会进行记录；</p>
<p>List表示网关字段在Record的时候要处理成一个列表，而不是字符串，这个就等同于上述代码中高亮的一段逻辑<code>route[3] = [route[3]]</code>。</p>
<h3 id="状态转移-1"><a href="#状态转移-1" class="headerlink" title="状态转移"></a>状态转移</h3><p>这里其实没必要使用状态转移，但一个是可以提高准确性，另外是可以让大家熟悉一下状态转移怎么用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Start</span><br><span class="line">  ^.*----- -&gt; Routes</span><br></pre></td></tr></table></figure>

<p>默认匹配的时候直接进入Start状态下进行匹配，当匹配到有<code>^.*-----</code>的时候，说明下面的输出都是路由表的内容了，这时候就通过状态转移，进入到“Routes”中进行匹配。</p>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>Routes下的规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Routes</span><br><span class="line">  ^\s\s\S\s\S\S -&gt; Continue.Record</span><br><span class="line">  ^\s\s$&#123;Protocol&#125; $&#123;Type&#125; $&#123;Prefix&#125;\s+via $&#123;Gateway&#125;\s+$&#123;Distance&#125;/$&#123;Metric&#125;\s+$&#123;LastChange&#125;</span><br><span class="line">  ^\s+via $&#123;Gateway&#125;</span><br></pre></td></tr></table></figure>

<p>大家可以思考一下为什么要这么写？为什么把Record加在最上面，还有一个Continue操作？</p>
<p>这里最开始的第一想法肯定是如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Routes</span><br><span class="line">  ^\s\s$&#123;Protocol&#125; $&#123;Type&#125; $&#123;Prefix&#125;\s+via $&#123;Gateway&#125;\s+$&#123;Distance&#125;/$&#123;Metric&#125;\s+$&#123;LastChange&#125; -&gt; Record</span><br><span class="line">  </span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">Routes</span><br><span class="line">  ^\s\s$&#123;Protocol&#125; $&#123;Type&#125; $&#123;Prefix&#125;\s+via $&#123;Gateway&#125;\s+$&#123;Distance&#125;/$&#123;Metric&#125;\s+$&#123;LastChange&#125;</span><br><span class="line">  ^\s+via $&#123;Gateway&#125; -&gt; Record</span><br></pre></td></tr></table></figure>

<p>上面第一种的结果会只有全部值都匹配到才会记录，因为我们把“Prefix”字段声明成了Required，所以当某一行只有一个Gateway字段的时候，Record就无效了，最终的结果肯定匹配不到全部的Gateway。</p>
<p>第二种写法呢，虽然有一条单独匹配Gateway的规则，但同样受限于Prefix的Required字段，导致结果不完整；</p>
<p>那如果取消掉Required是不是可以匹配完整呢？答案是同样不可以。</p>
<p>如果去掉了Required，那么最终的结果就会出现只有Gateway有值，而其他字段都是“”，类似于这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;EX&#x27;</span>, <span class="string">&#x27;0.0.0.0/0&#x27;</span>, [<span class="string">&#x27;192.0.2.73&#x27;</span>], <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;4w0d&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, [<span class="string">&#x27;192.0.2.201&#x27;</span>], <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, [<span class="string">&#x27;192.0.2.202&#x27;</span>], <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>],</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>所以我们需要重新考虑一下执行Record的时机，以及Record的定义，Record可以将上一次记录之后匹配到的值进行记录，那么把执行Record操作的时机改到匹配到<code>B EX 0.0.0.0/0    ...</code>的时候是不是也可以。</p>
<p>相当于把Record后移了一下，把原先的在匹配到路由条目之后记录，改成在匹配下一个完整的路由条目之前记录，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Routes</span><br><span class="line">  ^\s\s\S\s\S\S -&gt; Record</span><br><span class="line">  ^\s\s$&#123;Protocol&#125; $&#123;Type&#125; $&#123;Prefix&#125;\s+via $&#123;Gateway&#125;\s+$&#123;Distance&#125;/$&#123;Metric&#125;\s+$&#123;LastChange&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p><code>^\s\s\S\s\S\S</code>这个规则就相当于匹配到了<code>B EX 0.0.0.0/0    ...</code>内容，但命中某个规则后如果没有指定行操作，那么默认会执行Next，相当于<code>-&gt; Next.Record</code>；那命中的这行完整路由条目岂不是提取不到字段了？</p>
<p>别忘了，行操作里还有一个Continue，Continue的定义是“命中该规则后仍然使用这一行，继续进行下一个规则的匹配”，所以在<code>^\s\s\S\s\S\S</code>后衔接<code>-&gt; Continue.Record</code>就可以把之前匹配的结果记录下来，并且保留当前行，去做下一个匹配。</p>
<p>那么匹配路由条目的完整规则就演变成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Routes</span><br><span class="line">  ^\s\s\S\s\S\S -&gt; Continue.Record</span><br><span class="line">  ^\s\s$&#123;Protocol&#125; $&#123;Type&#125; $&#123;Prefix&#125;\s+via $&#123;Gateway&#125;\s+$&#123;Distance&#125;/$&#123;Metric&#125;\s+$&#123;LastChange&#125;</span><br><span class="line">  ^\s+via $&#123;Gateway&#125;</span><br></pre></td></tr></table></figure>

<p>大家可以再回看一下上面的代码，是不是和这里的逻辑基本吻合。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这三个TextFSM模版的举例大家可以发现，TextFSM恰好解决了我们一开始遇到的三大痛点，而且模版本身的匹配机制和行操作于我们的代码逻辑几乎一致。</p>
<p>所以可以看到TextFSM是将匹配过程或者逻辑进行抽象封装，这样就可以让匹配的模版以文本的形式存在，定义一个模版其实相当于同时定义了解析的正则和匹配的逻辑，这样可以大大简化系统设计时的复杂度，并且对加强可扩展性起到了非常重要的作用。</p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>巡检</tag>
        <tag>文本解析</tag>
        <tag>TextFSM</tag>
      </tags>
  </entry>
  <entry>
    <title>2.13 自动化运维初级村-巡检-解析</title>
    <url>/posts/380a5944.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>经过前面几个章节的学习，总算是初步上手了文本的解析功能，那么这一章节中我们就来完善巡检框架，让它具备解析能力，这样才是一个完整巡检模块。</p>
<span id="more"></span>

<h1 id="模版管理线上化"><a href="#模版管理线上化" class="headerlink" title="模版管理线上化"></a>模版管理线上化</h1><h2 id="Action-模型改造"><a href="#Action-模型改造" class="headerlink" title="Action 模型改造"></a>Action 模型改造</h2><p>上一章节中提到，考虑到程序设计的可扩展性，我们希望把解析模板做线上管理，这里采用的方式是把模板的内容保存到数据库中，以供我们在需要的时候查询检索。</p>
<p>巡检框架已存在的实体中，有一个 Action 实体，这个实体用来表示执行的巡检动作，它所对应的表结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;action&quot;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;动作名称&quot;</span>)</span><br><span class="line">    description = db.Column(db.String(<span class="number">256</span>), comment=<span class="string">&quot;动作描述&quot;</span>)</span><br><span class="line">    vendor = db.Column(db.String(<span class="number">64</span>), comment=<span class="string">&quot;厂商&quot;</span>)</span><br><span class="line">    model = db.Column(db.String(<span class="number">64</span>), comment=<span class="string">&quot;型号&quot;</span>)</span><br><span class="line">    cmd = db.Column(db.String(<span class="number">256</span>), nullable=<span class="literal">False</span>, comment=<span class="string">&quot;命令行&quot;</span>)</span><br><span class="line">    <span class="built_in">type</span> = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;命令类型[show|config]&quot;</span>)</span><br><span class="line">    parse_type = db.Column(db.String(<span class="number">8</span>), comment=<span class="string">&quot;解析类型[regexp|textfsm]&quot;</span>)</span><br><span class="line">    parse_content = db.Column(db.String(<span class="number">1024</span>), comment=<span class="string">&quot;解析内容&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上述 Action 的属性中有两个属性就是专门预留来做解析时用的，因为每一个巡检动作都会对应一条具体的命令，而解析功能必然是和命令挂钩的，所以解析的相关属性理所当然应该与 Action 存放在一起。</p>
<p>parse_type 属性是用来表示解析类型的，理想情况下我们希望每个命令都有 TextFSM 模板，但也不排除有其他特殊情况需要用到正则表达式来解析，所以专门设置了该属性来进行区分。</p>
<p>parse_content 属性就是用来保存模板内容（或者正则表达式）的，但之前的设计中，把这一列设置成了 Varchar(1024)，那么通过上一章节的学习，大家应该会发现在 ntc-template 库中提供的解析模板会存在较长的情况，所以我们需要将该列在数据库中改为 Text，使其可以保存更多的字符（65535个字符）。</p>
<p>修改数据库列字段的 DDL 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> action MODIFY <span class="keyword">COLUMN</span> parse_content TEXT COMMENT <span class="string">&#x27;解析内容&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>同时 Action Model 中的 parse_content 修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parse_content = db.Column(db.Text, comment=<span class="string">&quot;解析内容&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Action-录入"><a href="#Action-录入" class="headerlink" title="Action 录入"></a>Action 录入</h2><p>之前的章节中已经实现巡检动作的增删改查，所以我们可以通过接口来进行 Action 的操作，其中就可以包含对解析模板的管理。</p>
<p>比如增加一个巡检动作的请求如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:5000/action/add</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;name&quot;:  &quot;version_check&quot;, </span><br><span class="line">      &quot;description&quot;:  &quot;版本检查&quot;, </span><br><span class="line">      &quot;vendor&quot;: &quot;cisco&quot;, </span><br><span class="line">      &quot;model&quot;:  &quot;ios&quot;, </span><br><span class="line">      &quot;cmd&quot;:  &quot;show version&quot;, </span><br><span class="line">      &quot;type&quot;: &quot;show&quot;,</span><br><span class="line">      &quot;parse_type&quot;: &quot;textfsm&quot;,</span><br><span class="line">      &quot;parse_content&quot;: &quot;&#123;模版内容&#125;&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>或者对已存在的巡检动作来修改其解析模板，请求如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:5000/action/update</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot; , </span><br><span class="line">      &quot;parse_type&quot;: &quot;textfsm&quot;,</span><br><span class="line">      &quot;parse_content&quot;: &quot;&#123;模版内容&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>通过以上的方式就可以将模板与巡检动作+执行的命令进行绑定，统一进行管理，而不是通过额外的文件形式来做。</p>
<h1 id="执行-解析"><a href="#执行-解析" class="headerlink" title="执行+解析"></a>执行+解析</h1><p>在之前章节中我们已经实现了基于SSH的执行器，并且可以在初始化执行器时，传入 ActionHandler 与 DeviceHandler 进行后续的创建连接和执行命令使用，其中用于执行命令的 execute() 方法代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, action: <span class="type">Optional</span>[Action] = <span class="literal">None</span>, action_condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span>, read_timeout: <span class="built_in">int</span> = <span class="number">10</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        action_condition.update(&#123;<span class="string">&quot;vendor&quot;</span>: self.device.vendor.lower(), <span class="string">&quot;model&quot;</span>: self.device.model.lower()&#125;)</span><br><span class="line">        <span class="keyword">if</span> action <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            action = self.fetch_action(action_condition)</span><br><span class="line">        <span class="keyword">if</span> action.<span class="built_in">type</span> == CommandType.Config:</span><br><span class="line">            output = self.conn.send_config_set(action.cmd, read_timeout=read_timeout)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conn.enable()</span><br><span class="line">            output = self.conn.send_command(action.cmd, read_timeout=read_timeout)</span><br><span class="line">        <span class="comment"># TODO parse_result = self.parse()</span></span><br><span class="line">        parse_result = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.save(action.cmd, output, parse_result)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>上述代码中我们预留了一个 TODO 部分，用来添加解析逻辑，现在的目标就是将解析功能添加在这里。</p>
<h2 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h2><p>因为现在默认执行 execute 后是不进行解析的，所以需要在该方法中设置一个参数 parse，来表示是否在执行完命令后，对输出结果进行解析。</p>
<p>大家可以回想一下上一章节中介绍的 Netmiko 里自带的 send_command 函数也有解析的功能，并且还支持三种解析方式，分别是 TextFSM、TTP、Genie，只需传入对应的 use_textfsm、use_ttp、use_genie 即可；我们执行器中的 execute 也可以支持多种解析，目前支持 regexp 和 textfsm，如果后续想支持 ttp 或者其他也是可以的，但为什么只需要设置一个 parse 参数呢？</p>
<p>原因是 execute 方法中传入的 action 参数是一个巡检项模型，这个对象里就已经包含了其所对应的执行命令和解析方式以及解析模板，所以就不需要像 send_command 一样将解析的参数与执行的命令拆开传递，这也是大型项目的设计与工具包的设计之间的差异，大家可以下来仔细体会一下。</p>
<h2 id="解析逻辑"><a href="#解析逻辑" class="headerlink" title="解析逻辑"></a>解析逻辑</h2><h3 id="ActionHandler-改造"><a href="#ActionHandler-改造" class="headerlink" title="ActionHandler 改造"></a>ActionHandler 改造</h3><p>这里的 parse 参数是一个 bool 类型的变量，需要解析时该变量为 True，所以在执行完命令之后需要加一段逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> parse:</span><br><span class="line">    <span class="comment"># parse</span></span><br></pre></td></tr></table></figure>

<p>现在需要考虑的就是解析的逻辑应该属于哪个对象？</p>
<p>既然解析类型和模板内容是属于 Action 对象的，那么解析的逻辑其实顺理成章的应该属于 ActionHandler 对象，因为这个对象就是用来处理 Action 相关的衍生逻辑的。</p>
<p>所以我们在 ActionHandler 类中增加解析的逻辑，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ntc-template <span class="keyword">import</span> parse_output</span><br><span class="line"><span class="keyword">from</span> ..models.action <span class="keyword">import</span> ParseTypeEnum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionHandler</span>(abc.ABC):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 该类为 Handler 的抽象类 &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, device_type: <span class="built_in">str</span>, action: <span class="type">Any</span>, output: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">Dict</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 抽象方法，继承了 ActionHandler 的子类必须实现该方法 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionJSONHandler</span>(<span class="title class_ inherited__">ActionHandler</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 基于 json 文件实现的 Handler 类 &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, device_type: <span class="built_in">str</span>, action: <span class="type">Dict</span>, output: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">Dict</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 使用 ntc-template 进行解析 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> action[<span class="string">&quot;parse_type&quot;</span>] == ParseTypeEnum.TextFSM.value:</span><br><span class="line">                <span class="keyword">return</span> parse_output(platform=device_type, command=action[<span class="string">&quot;cmd&quot;</span>], data=output)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">             </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionORMHandler</span>(<span class="title class_ inherited__">ActionHandler</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 基于 ORM 实现的 Handler 类 &quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, device_type: <span class="built_in">str</span>, action: Action, output: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">Dict</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 使用基于字符串的 TextFSM 进行解析 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> action.parse_type == ParseTypeEnum.TextFSM.value:</span><br><span class="line">                fsm = TextFSM(StringIO(action.parse_content))</span><br><span class="line">                <span class="keyword">return</span> fsm.ParseTextToDicts(output)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<p>大家可以回想之前我们实现了两种 ActionHandler，第一种是基于 JSON 文件的，可以处理 action 不存在数据库的情况，第二种是基于 ORM 的，处理在数据库中保存 action 的情况，同时还定义了一个抽象的 ActionHandler，利用 abc.ABC 来实现对其子类方法的约束。</p>
<p>当需要增加 parse 逻辑时，应该先在抽象类 ActionHandler 中增加该抽象方法，以此来约束 ActionJSONHandler 和 ActionORMHandler 必须实现 parse 逻辑。</p>
<p>对于 ActionJSONHandler 来说，适用于小范围的场景，action 和 device 都通过文件形式管理，所以 parse 逻辑就恰好适合使用通过文件管理模板的 ntc-template。</p>
<p>对于 ActionORMHandler 来说，所有的数据都通过数据库进行存储，所以 parse 逻辑中通过基于字符串的 TextFSM 模板进行解析。</p>
<p>有一个小细节就是在解析的时候判断了一下 parse_type，判断的时候引用了 model.py 中定义的枚举类 ParseTypeEnum，关于为什么使用枚举类而不直接用 if parse_type &#x3D;&#x3D; “textfsm” 来判断，之前的文章中也提到过；</p>
<p>在程序中尽量不使用字面量，其一是因为字面量不易读，其二是因为字面量扩展性差，不易维护。</p>
<h3 id="Execute-改造"><a href="#Execute-改造" class="headerlink" title="Execute 改造"></a>Execute 改造</h3><p>现在已经实现了 parse 逻辑，那么 execute 函数要如何补全逻辑呢？代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, action: <span class="type">Optional</span>[Action] = <span class="literal">None</span>, </span></span><br><span class="line"><span class="params">        action_condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span>, </span></span><br><span class="line"><span class="params">        read_timeout: <span class="built_in">int</span> = <span class="number">10</span>, parse: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="type">Union</span>[<span class="type">List</span>, <span class="built_in">str</span>]:</span><br><span class="line">        ...</span><br><span class="line">        parse_result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> parse:</span><br><span class="line">            parse_result = self.action_handler.parse(self.device_type, action, output)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> parse_result <span class="keyword">if</span> parse_result <span class="keyword">else</span> output</span><br></pre></td></tr></table></figure>

<p>上述代码省略了 execute 方法中的其他逻辑，解析的部分实际上只增加了一行；在初始化 SSHExecutor 的时候已经传入了 ActionHandler，所以这里只需要调用 self 本身的 action_handler 中的 parse 方法，传入 device_type、action、output 参数即可完成解析。</p>
<p>该函数的返回值也做了一下处理，在可以正确解析的情况下返回 parse_result，否则直接返回 output。</p>
<h2 id="执行接口"><a href="#执行接口" class="headerlink" title="执行接口"></a>执行接口</h2><p>我们已经实现了通过接口来触发执行器，所以还需要改造一下路由函数，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@executor_blueprint.route(<span class="params"><span class="string">&quot;/execute&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">execute</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        device_condition = data.get(<span class="string">&quot;device_condition&quot;</span>)</span><br><span class="line">        action_condition = data.get(<span class="string">&quot;action_condition&quot;</span>)</span><br><span class="line">        action = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;action&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">            action = Action.to_model(**data.get(<span class="string">&quot;action&quot;</span>))</span><br><span class="line">        device_handler = DeviceORMHandler(db.session())</span><br><span class="line">        action_handler = ActionORMHandler(db.session())</span><br><span class="line">        <span class="keyword">with</span> SSHExecutor(</span><br><span class="line">                username=current_app.config.get(<span class="string">&quot;SSH_USERNAME&quot;</span>),</span><br><span class="line">                password=current_app.config.get(<span class="string">&quot;SSH_PASSWORD&quot;</span>),</span><br><span class="line">                secret=current_app.config.get(<span class="string">&quot;SSH_SECRET&quot;</span>),</span><br><span class="line">                device_condition=device_condition,</span><br><span class="line">                device_handler=device_handler,</span><br><span class="line">                action_handler=action_handler,</span><br><span class="line">                logger=current_app.logger) <span class="keyword">as</span> ssh:</span><br><span class="line">            output = ssh.execute(</span><br><span class="line">                        action=action, </span><br><span class="line">                        action_condition=action_condition,</span><br><span class="line">                        parse=data.get(<span class="string">&quot;parse&quot;</span>, <span class="literal">False</span>)</span><br><span class="line">                     )</span><br><span class="line">            <span class="keyword">return</span> Success(data=output)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ExecutorError(message=<span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

<h2 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h2><p>执行器作为提供底层支持能力的模块，在健壮性方面必须足够强，所以现在还需要做一些额外的处理以应对异常状况。</p>
<h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><p>创建连接是最容易发生错误的地方，可能会由于网络抖动或者设备繁忙导致连接失败，所以重试是非常有必要的，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    ...</span><br><span class="line">    self.retry_times = <span class="number">3</span></span><br><span class="line">    self.conn = self.connect(self.retry_times)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, retry: <span class="built_in">int</span></span>) -&gt; BaseConnection:</span><br><span class="line">        <span class="keyword">if</span> retry == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Retry to connect over maximum&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn = ConnUnify(host=self.host, port=self.port, username=self.username, password=self.password,</span><br><span class="line">                             secret=self.secret, device_type=self.device_type, conn_timeout=self.conn_timeout,</span><br><span class="line">                             auth_timeout=self.auth_timeout, banner_timeout=self.banner_timeout, session_log=<span class="string">&quot;netmiko.log&quot;</span>,</span><br><span class="line">                             session_log_file_mode=<span class="string">&quot;append&quot;</span>)</span><br><span class="line">            msg = <span class="string">f&quot;Netmiko connection successful to <span class="subst">&#123;self.host&#125;</span>:<span class="subst">&#123;self.port&#125;</span>&quot;</span></span><br><span class="line">            self.logger.info(msg)</span><br><span class="line">            <span class="keyword">return</span> conn</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            self.logger.error(<span class="built_in">str</span>(e))</span><br><span class="line">            <span class="keyword">return</span> self.connect(retry - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码中，定义了一个最大重试次数，并且在调用 ConnUnify 失败后重试次数减一再次调用自身，直至重试次数为 0 后抛出连接异常。</p>
<p>这里抛出异常是非常有必要的，因为如果没有成功创建连接，那么 self.conn 属性将会是 None，但其他实例方法使用 self.conn 时是默认该属性有值的。</p>
<p>所以我们要在连接异常的情况下，及时抛出异常，避免将异常“吞掉”而导致下游方法发生不可预知的错误。</p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>在 execute 方法中使用了创建好的连接，大家可以一种场景：初始化执行器的时候连接创建成功，但由于长时间未使用，或者网络质量不佳，导致连接丢失或被关闭，那此时 execute 执行命令就会出现异常。</p>
<p>所以最佳的做法是在 execute 中使用连接前获取连接即可，而不需要在初始化执行器的时候就去创建连接，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SSHExecutor</span>:</span><br><span class="line">    ...</span><br><span class="line">    self.conn = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connection</span>(<span class="params">self</span>) -&gt; BaseConnection:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.conn <span class="keyword">or</span> <span class="keyword">not</span> self.conn.is_alive():</span><br><span class="line">            self.conn = self.connect(self.retry_times)</span><br><span class="line">        <span class="keyword">return</span> self.conn</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, action: <span class="type">Optional</span>[Action] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        action_condition: <span class="type">Optional</span>[<span class="type">Dict</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        read_timeout: <span class="built_in">int</span> = <span class="number">10</span>, parse: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="type">Union</span>[<span class="type">List</span>, <span class="built_in">str</span>]:</span><br><span class="line">        action_condition.update(&#123;<span class="string">&quot;vendor&quot;</span>: self.device.vendor.lower(), <span class="string">&quot;model&quot;</span>: self.device.model.lower()&#125;)</span><br><span class="line">        <span class="keyword">if</span> action <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            action = self.fetch_action(action_condition)</span><br><span class="line">        <span class="keyword">if</span> action.<span class="built_in">type</span> == CommandType.Config:</span><br><span class="line">            output = self.connection.send_config_set(action.cmd, read_timeout=read_timeout)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.connection.enable()</span><br><span class="line">            output = self.connection.send_command(action.cmd, read_timeout=read_timeout)</span><br><span class="line">    </span><br><span class="line">        parse_result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> parse:</span><br><span class="line">            parse_result = self.action_handler.parse(self.device_type, action, output)</span><br><span class="line">        self.save(action.cmd, output, parse_result)</span><br><span class="line">        <span class="keyword">return</span> parse_result <span class="keyword">if</span> parse_result <span class="keyword">else</span> output</span><br></pre></td></tr></table></figure>

<p>上述代码中用到了 Python 中的属性装饰器 @property，被该装饰器装饰的实例方法可以直接作为实例属性使用，因此在 execute 方法中将 self.conn 均改为 self.connection。</p>
<p>而 connection() 的逻辑是，判断此刻如果不存在 self.conn 或者 self.conn 不是可用状态，则发起连接获取 self.conn，最后将 self.conn 返回。</p>
<p>这种模式是在大型项目中非常常见的懒加载模式，有两点好处，一是可以避免在初始化对象时耗时过多或者产生当下的资源；二是在需要时获取可以保证资源的实时性。</p>
<h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>执行器到目前为止已经改造完成，我们发送请求测试一下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:5000/executor/execute</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;device_condition&quot;: &#123;</span><br><span class="line">    &quot;ip&quot;:  &quot;192.168.31.149&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;action_condition&quot;:  &#123;</span><br><span class="line">    &quot;name&quot;:  &quot;version_check&quot;,</span><br><span class="line">    &quot;model&quot;:  &quot;cisco&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;parse&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 execute 请求中传入 parse 参数，代表在执行完命令后进行解析，返回结构化数据。</p>
<p>这里我们将模拟器关闭，测试连接失败的情况，返回内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_code&quot;</span><span class="punctuation">:</span> <span class="number">520</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Retry to connect over maximum&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;POST /executor/execute&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>模拟器正常运行时，再次发起请求，返回如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;VERSION&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ROMMON&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bootstrap&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;HOSTNAME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;r1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UPTIME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0 minutes&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UPTIME_YEARS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UPTIME_WEEKS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UPTIME_DAYS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UPTIME_HOURS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UPTIME_MINUTES&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;RELOAD_REASON&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unknown reason&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;RUNNING_IMAGE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/opt/unetlab/addons/iol/bin/i86bi-linux-l3-adventerprisek9-15.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;HARDWARE&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;SERIAL&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;67108896&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;CONFIG_REGISTER&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MAC&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;RESTARTED&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status_code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;POST /executor/execute&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到目前为止，我们已经完成了执行器的全部设计，但是对于巡检模块来说，还缺少一个重要的功能，那就是巡检项的结果校验以及导出，在后面的章节，我会带大家逐步进行这一功能的设计和实现。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>github分支：<a href="https://github.com/EthanYue/PythonAutoOps/tree/junior-parse">https://github.com/EthanYue/PythonAutoOps/tree/junior-parse</a></p>
]]></content>
      <categories>
        <category>初级村</category>
      </categories>
      <tags>
        <tag>巡检</tag>
        <tag>文本解析</tag>
        <tag>TextFSM</tag>
      </tags>
  </entry>
  <entry>
    <title>0.1 自动化运维番外篇-数据结构-1</title>
    <url>/posts/556857df.html</url>
    <content><![CDATA[<hr>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h3><p><strong>首先说明，以下几类读者请自行对号入座：</strong></p>
<ul>
<li><p>刚接触编程并对底层原理知之甚少，但又想了解一下数据结构的读者，强烈建议阅读此篇；</p>
</li>
<li><p>计算机专业在读，对编程有一定了解，但对数据结构不够熟悉的读者，强烈建议阅读此篇；</p>
</li>
<li><p>传统运维想要快速上手自动化，没有精力对底层原理做深入了解的，请跳过此番外篇系列；</p>
</li>
<li><p>计算机专业出身并对数据结构有系统了解的读者，请跳过此系列番外篇。</p>
</li>
</ul>
<p><strong>首先和大家说明一下，计算机专业必学的四大科目：</strong></p>
<ul>
<li><strong>计算机组成原理</strong></li>
<li><strong>操作系统</strong></li>
<li><strong>数据结构</strong></li>
<li><strong>计算机网络</strong></li>
</ul>
<p>这四大科目可以说是奠定一个人将来技术成长的基石，并且不管是考研还是面试都是一定会考察的内容，我相信很多读者都有在知乎或者其他地方看到过类似的提问：培训机构出身的就一定比不过科班的吗？</p>
<p>实事求是的讲，<strong>答案是肯定的</strong>。首先培训机构以就业为目的，必然就导致要在短时间内教会学员求职工作中所需要掌握的技巧和框架，但却没有考虑到学员的基础知识劳不牢靠；</p>
<p>而科班出身的同学，因为系统的掌握了很多底层原理，所以在<strong>应对层出不穷的技术迭代时，会显得游刃有余</strong>。</p>
<p>所以读者中有一部分是想在传统运维工作之外，掌握一些自动化的技巧来提升工作效率，那么<strong>大可不必对底层原理揪着不放，一是为大大拖慢学习的节奏，二是可能大家的时间和精力也不允许</strong>，当然如果真的对这方面感兴趣，也提倡大家能多了解最好；</p>
<p>但有一部分读者可能本身就是计算机专业，但上课没有好好听讲，那么这一系列可能就是你<strong>曾经欠下的技术债了，出来混迟早要还了</strong>，如果还抱有一颗做技术的心，那么还是趁早还比较好。</p>
<span id="more"></span>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>我们这一系列主要是讲解数据结构相关的内容，这门学科可以说是<strong>编程之路上必备的</strong>，因为任何编程语言都逃不开数据结构，虽然不同编程语言的变量类型各有不同，但它们本质上都是由底层的数据结构衍化而来。</p>
<p>而且我们面试中经常遇到的算法题，也都是由数据结构衍生而来，诸如翻转链表问题，打家劫舍问题等，实际上都是对数据结构的深入考察，所以一句话总结就是<strong>要想好编程，就必须学好数据结构</strong>。</p>
<h4 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a><strong>什么是数据结构</strong></h4><blockquote>
<p>百度百科上对其的定义为：</p>
</blockquote>
<blockquote>
<p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。</p>
</blockquote>
<blockquote>
<p>简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p>
</blockquote>
<p>通俗的讲，数据是存储在计算机的内存里，在存储时，决定了<strong>数据顺序和位置关系的便是“数据结构“</strong>，数据结构几乎可以体现到在计算机的任何一处地方，我可以举一个生活中应用数据结构的例子：</p>
<p><img src="https://s2.loli.net/2023/04/08/oUKvzSW9TJeAEdj.jpg" alt="img"></p>
<p>在手机没有出现之前，我们记录电话号码的方式就是一行一行的把电话抄在笔记本上，那么如果把笔记本当作计算机内存的话，这种数据结构就是数组；</p>
<p>当有了手机之后，我们可以添加联系人，然后手机会根据联系人名字拼音的顺序进行分组，这样在查找的时候就会方便很多，那么这里就又用到了散列表的数据结构。</p>
<p>所以由这个例子，大家应该也可以体会到，当<strong>选择合适的数据结构时，可以提高解决问题的效率，而如何高效的解决问题就是算法的内容，所以数据结构的重要性就不言而喻了</strong>。</p>
<h4 id="数据结构的分类"><a href="#数据结构的分类" class="headerlink" title="数据结构的分类"></a><strong>数据结构的分类</strong></h4><p>数据结构分为<strong>逻辑结构</strong>和<strong>物理结构</strong>。</p>
<ul>
<li>逻辑结构：指数据元素之间逻辑关系的数据结构，这里的逻辑关系是指数据元素之间的<strong>前后间关系</strong>，与数据在计算机中的存储位置无关。</li>
<li>物理结构：指数据的逻辑结构在计算机存储空间中的<strong>存放形式</strong>称为数据的物理结构，也叫做存储结构。</li>
</ul>
<p>数据的逻辑结构主要分为<strong>线性结构</strong>和<strong>非线性结构</strong>。</p>
<ul>
<li>线性结构：数据结构的元素之间存在<strong>一对一线性关系</strong>，所有结点都最多只有一个直接前趋结点和一个直接后继结点。常见的有数组、队列、链表、栈。</li>
<li>非线性结构：各个结点之间具有<strong>多个对应关系</strong>，一个结点可能有多个直接前趋结点和多个直接后继结点。常见的有多维数组、广义表、树结构和图结构等。</li>
</ul>
<p>数据的物理结构（以后我都统一称存储结构），表示数据元素之间的逻辑关系，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有：</p>
<ul>
<li><strong>顺序存储</strong>：存储顺序是连续的，在内存中用一组地址连续的存储单元依次存储线性表的各个数据元素。</li>
<li><strong>链式存储</strong>：在内存中的存储元素不一定是连续的，用任意地址的存储单元存储元素，元素节点存放数据元素以及通过指针指向相邻元素的地址信息。</li>
<li><strong>索引存储</strong>：除建立存储结点信息外，还建立附加的索引表来标识节点的地址。索引表由若干索引项组成。</li>
<li><strong>散列存储</strong>：又称Hash存储，由节点的关键码值决定节点的存储地址。</li>
</ul>
<h4 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a><strong>常用的数据结构</strong></h4><ul>
<li><strong>数组（Array）</strong></li>
<li><strong>队列（Queue）</strong></li>
<li><strong>链表（Linked List）</strong></li>
<li><strong>栈（Stack）</strong></li>
<li><strong>树（Tree）</strong></li>
<li><strong>散列表（Hash）</strong></li>
<li><strong>堆（Heap）</strong></li>
<li><strong>图（Graph）</strong></li>
</ul>
<h5 id="一、数组（Array）"><a href="#一、数组（Array）" class="headerlink" title="一、数组（Array）"></a><strong>一、数组（Array）</strong></h5><p>数组是最简单、使用最频繁的一种数据结构。它一种线性表数据结构，用一组连续的内存空间来存储一组相同类型的数据。</p>
<p><img src="https://s2.loli.net/2023/04/08/Xvkb6TEA3ftmwM9.jpg" alt="img"></p>
<p>如上图所示，数据是<strong>按照顺序存储在内存的连续空间</strong>内，arr后面的[]代表下标，由于数据是存储在连续空间内的，所以每个数据的内存地址(在内存上的位置)都可以通过数组下标计算出来，从而可以直接访问目标数据，达到随机访问的目的。</p>
<h5 id="二、队列（Queue）"><a href="#二、队列（Queue）" class="headerlink" title="二、队列（Queue）"></a><strong>二、队列（Queue）</strong></h5><p>队列也是一种非常基础的数据结构，其特点是<strong>先入先出</strong>，也就是我们常听到的FIFO（First in First Out），即操作数据是从两端进行的。</p>
<p><img src="https://s2.loli.net/2023/04/08/cjHxK7iR3yaOZJW.jpg" alt="img"></p>
<h5 id="三、链表（Linked-List）"><a href="#三、链表（Linked-List）" class="headerlink" title="三、链表（Linked List）"></a><strong>三、链表（Linked List）</strong></h5><p>链表是一种物理存储单元上<strong>非连续，非顺序</strong>的存储结构。链表有一系列节点组成，所谓节点就是指链表中的每一个元素，每个节点包含两个数据，一个是存储元素的数据域（值），另一个是存储下一个节点地址的指针域。 </p>
<p><img src="https://s2.loli.net/2023/04/08/ITSbMrkWGxHLBzE.jpg" alt="img"></p>
<h5 id="四、栈（Stack）"><a href="#四、栈（Stack）" class="headerlink" title="四、栈（Stack）"></a><strong>四、栈（Stack）</strong></h5><p>栈也是一种数据呈线性排列的数据结构，和上面的队列相反，栈的特点<strong>先进后出、后进先出</strong>，就是常说的LIFO（Last in First Out）。</p>
<p><img src="https://s2.loli.net/2023/04/08/i4F2ZqgMk3SVPuW.jpg" alt="img"></p>
<h5 id="五、树（Tree）"><a href="#五、树（Tree）" class="headerlink" title="五、树（Tree）"></a><strong>五、树（Tree）</strong></h5><p>树形结构是一种<strong>层级式</strong>的数据结构，由顶点（节点）和连接它们的边组成。树的结构特点是：</p>
<ul>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树。</li>
</ul>
<p>我们平时用到最多的就是二叉树，我也以二叉树来为例，先看一下树结构：</p>
<p><img src="https://s2.loli.net/2023/04/08/GNDuadz9nEq3cov.jpg" alt="img"></p>
<h5 id="六、散列表（Hash）"><a href="#六、散列表（Hash）" class="headerlink" title="六、散列表（Hash）"></a><strong>六、散列表（Hash）</strong></h5><p>散列表又叫哈希表，存储的是由**键(key)和值(value)**组成的数据，根据键直接访问存储在内存存储位置的数据结构。</p>
<p><img src="https://s2.loli.net/2023/04/08/H9UIjLxZNRnzqCl.jpg" alt="img"></p>
<h5 id="七、图（Graph）"><a href="#七、图（Graph）" class="headerlink" title="七、图（Graph）"></a><strong>七、图（Graph）</strong></h5><p>图是相对复杂的一种数据结构，由<strong>顶点和连接每对顶点的边</strong>所构成的图形就是图。</p>
<p><img src="https://s2.loli.net/2023/04/08/3d2fJSX89xQAIbq.jpg" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>因为数据结构是一个比较系统的学科，所以我认为有必要整体的讲一下常用的数据结构，让大家能有一个基本的该概念，我们在后续会结合我们代码来介绍在实际场景中数据结构的运用，敬请期待。</p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>0.3 自动化运维番外篇-数据结构-3</title>
    <url>/posts/b03811f0.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li><p>刚接触编程并对底层原理知之甚少，但<strong>又想了解一下数据结构的读者</strong>，强烈建议阅读此篇；</p>
</li>
<li><p>计算机专业在读，对编程有一定了解，但<strong>对数据结构不够熟悉的读者</strong>，强烈建议阅读此篇；</p>
</li>
<li><p>传统运维想要快速上手自动化，没有精力对底层原理做深入了解的，请跳过此番外篇系列；</p>
</li>
<li><p>计算机专业出身并对数据结构有系统了解的读者，请跳过此系列番外篇。</p>
</li>
</ul>
<p>我们在<strong>【自动化运维番外篇】数据结构-2</strong> 中讲Python中的列表类型与数据结构中的数组进行了详细的讲解和比较，相信大家在操作列表的时候应该都心里更有底了。</p>
<p>这篇我们就来着重讲解一下数据结构中的<strong>哈希表</strong>与Python中的<strong>字典</strong>类型，并且告诉大家为什么字典是无序的，顺带破除一下网上大部分博客对于这一知识点的误解。</p>
<span id="more"></span>

<h2 id="哈希表（Hash-Table）"><a href="#哈希表（Hash-Table）" class="headerlink" title="哈希表（Hash Table）"></a><strong>哈希表（Hash Table）</strong></h2><blockquote>
<p><strong>百度百科：</strong></p>
</blockquote>
<blockquote>
<p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。</p>
</blockquote>
<blockquote>
<p>它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录。</p>
</blockquote>
<blockquote>
<p>这加快了查找速度，这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
</blockquote>
<p>我觉得一般百度百科对专业名词做出的解释，都让人一脸懵X，本来想搞懂一个知识点，结果它一解释，不懂的知识点更多了，因为我们完全不知道这个东西的用途，也就无法对其有准确的认知。</p>
<p>我下面用一个生活中最常用到的东西来给大家讲解一下<strong>哈希表</strong>。</p>
<p>微信好友列表中好友排列就是一个按名字散列的哈希表。</p>
<p>大家可以假设如果没有按名字散列，那么微信好友的展示就只能按添加的先后顺序排列，这样我们在找某个好友时的效率就会很低，<strong>因为我们知道TA的名字，但不知道他保存在什么位置，只能从头翻到尾</strong>。</p>
<p><strong>但如果我们按名称散列之后，我们就可以按照好友名称的拼音首字母很快的检索到好友。</strong></p>
<p>这里取一个人名字的首字母，就是一种十分简单的<strong>哈希</strong>方法，而按名字哈希之后存放的容器就是一个<strong>表</strong>，我们上一讲中提到<strong>决定了数据顺序和位置关系的便是“数据结构“</strong>，那么上述的这种方式就是决定了我们好友数据的顺序和储存的位置关系，它就属于数据结构的一种：<strong>哈希表</strong>。</p>
<p>回过头来我们将百度百科的定义用微信好友的场景翻译一下就是：</p>
<blockquote>
<p>散列表（Hash table，也叫哈希表），是根据<strong>首字母</strong>而直接访问<strong>好友位置</strong>的数据结构。</p>
</blockquote>
<blockquote>
<p>它通过计算一个关于<strong>名字首字母</strong>函数，将所需查询的<strong>好友</strong>映射到表中一个位置来访问记录。</p>
</blockquote>
<blockquote>
<p>这加快了查找速度，这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
</blockquote>
<p>这下是不是清晰很多了，当我们对哈希表的应用有了大致的了解之后，我们就该着重深入一下具体的实现方式。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a><strong>哈希函数</strong></h3><p>上面我们提到关于名字首字母的函数可以称为哈希函数，而哈希函数的构造方法有很多种，哈希算法也是千变万化的，但大多都需要考虑以下五个因素：</p>
<p>1.计算散列地址所需要的时间（即hash函数本身不要太复杂）</p>
<p>2.关键字的长度</p>
<p>3.表长</p>
<p>4.关键字分布是否均匀，是否有规律可循</p>
<p>5.设计的hash函数在满足以上条件的情况下尽量减少冲突</p>
<p>所以哈希函数十分好理解，就是将我们要存储的元素按某种方式计算出一个值，这个值对应数组的某个位置，然后将这个元素存储进去。</p>
<p><img src="https://s2.loli.net/2023/04/08/dIj2UD8HOAoQqxf.png" alt="img"></p>
<p>比如我有一个上述元素的数组，哈希函数为：H(key) &#x3D; key mod 11，现有17，60，29三个元素，分别做哈希之后，得到的下标分别就是6，5，7，所以将他们存储在数组的指定位置上，但是聪明的读者这时候就会有一个疑问，如果再存一个38怎么办，它对应的下标仍然是5，这就涉及到了<strong>哈希冲突</strong>。</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a><strong>哈希冲突</strong></h3><p>任何哈希函数，都会出现两个不同元素映射到同一个位置上的情况，这种情况叫做哈希冲突，解决哈希冲突的方法一般有：<strong>开放定址法、链地址法（拉链法）、再哈希法</strong>等方法。</p>
<h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a><strong>开放定址法</strong></h4><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。<strong>开放定址法需要的表长度要大于等于所需要存放的元素</strong>。在开放定址法中解决冲突的方法有：<strong>线性探查法、平方探查法、双散列函数</strong>探查法。</p>
<p>\1. 线行探查法线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，比如元素38，对11取余之后为5，但5位置已经被占了，那就继续看6，但6也被占了，以此类推，最终发现8位置是空的，所以存在8位置上。</p>
<p>\2. 平方探查法平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。</p>
<p>3 伪随机数探测法每次加上一个随机数，直到探测到空闲位置结束。</p>
<h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a><strong>再哈希法</strong></h4><p>当通过哈希函数求得的哈希地址同其他关键字产生冲突时，使用另一个哈希函数计算，直到冲突不再发生。</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a><strong>链地址法</strong></h4><p>将所有产生冲突的关键字所对应的数据全部存储在同一个线性链表中。例如有一组关键字为{19,14,23,01,68,20,84,27,55,11,10,79}，其哈希函数为：H(key)&#x3D;key MOD 13，使用链地址法所构建的哈希表如下图所示：</p>
<p>所以了解到哈希函数和哈希冲突之后，几乎就掌握了哈希表的基本原理，下面我们就看看Python中的字典和哈希表究竟有什么样的关系？</p>
<h2 id="字典（Dict）"><a href="#字典（Dict）" class="headerlink" title="字典（Dict）"></a><strong>字典（Dict）</strong></h2><p><strong>Python的字典格式就是键值类型，每个键对应一个值，使用的是伪随机数探测法解决哈希冲突。</strong></p>
<p>但根据我们对数据结构中哈希表的学习来看，我们在<strong>遍历字典的时候并不会按我们存进去元素的顺序取出来的</strong>，<strong>这就是为什么说Python的字典是无序的，但为什么又说Python3.6之后又是有序的了呢，这就要看字典的底层实现了</strong></p>
<h3 id="Python3-6之前"><a href="#Python3-6之前" class="headerlink" title="Python3.6之前"></a><strong>Python3.6之前</strong></h3><p>字典的底层实现实际就是一张hash表，简单可以理解为一个列表，列表中的每一个元素又保存了三个元素，分别是哈希值（hash value）、键（key）和值（value）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这时的内存如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">entries = [</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当我们往字典里添加一个数据的时候</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict[<span class="string">&quot;test&quot;</span>] = <span class="string">&quot;ethan&quot;</span>  <span class="comment"># 通过计算 hash(&quot;test&quot;) % 5 = -3002718498575948766 % 5 = 4</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这时的内存示意图如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">entries = [</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[-3002718498575948766, 指向name的内存地址, 指向ehtan的内存地址],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>当我们要按test键对应的值时，同样会经过计算 hash(“test”) % 5，得到结果为4，然后从entries中读取4下标对应的值。</strong></p>
<p>当我们继续往字典里添加数据时同理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">my_dict[<span class="string">&quot;locate&quot;</span>] = <span class="string">&quot;BJ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这时的内存示意图如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">entries = [</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[-6504424719545881419, 指向locate的内存地址, 指向BJ的内存地址],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[-9004587017580859628, 指向age的内存地址, 指向18的内存地址],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[-3002718498575948766, 指向name的内存地址, 指向ehtan的内存地址],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[--, --, --]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当要循环遍历字典的时候，Python<strong>底层会遍历这个二维数组</strong>，如果当前行有数据，那么就返回Key指针对应的内存里面的值。如果当前行没有数据，那么就跳过。所以总是会遍历整个二位数组的每一行。<strong>所以可以很直观的看到，遍历时候的顺序并不是我们插入时的顺序</strong>。</p>
<h3 id="Python3-6之后"><a href="#Python3-6之后" class="headerlink" title="Python3.6之后"></a><strong>Python3.6之后</strong></h3><p>在Python3.6的版本之后，字典的底层实现发生了很明显的变化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这时的内存示意图如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">indices = [None, None, None, None, None] 索引表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">entries = [] 哈希表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当我们插入数据时内存的变化如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 使用hash(&quot;age&quot;) % 5 = 2, 所以在indices下标为2的位置存储0，这个0对应entries中实际元素存储的下标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这时的内存示意图如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">indices = [None, None, 0, None, None]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">entries = [</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[-9004587017580859628, 指向age的内存地址, 指向18的内存地址],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">] 哈希表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以此类推</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict[<span class="string">&quot;test&quot;</span>] = <span class="string">&quot;ethan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 使用hash(&quot;test&quot;) % 5 = 4, 所以在indices下标为4的位置存储1，这个1对应entries中实际元素存储的下标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这时的内存示意图如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">indices = [None, None, 0, None, 1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">entries = [</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[-9004587017580859628, 指向age的内存地址, 指向18的内存地址],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[-3002718498575948766, 指向name的内存地址, 指向ehtan的内存地址],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">] 哈希表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>当要读取test键对应的值时，hash(“test”) % 5 &#x3D; 4，我们查找indices中下标为4的位置存的是1，这时候再去entries中取出下标为1的位置存放的元素。</strong></p>
<p>当使用新的底层结构后发现，插入和索引依然有效，<strong>而且可以解决entries中存在空余空间的问题</strong>，并且在对字典进行遍历的时候，<strong>可以直接遍历entries，而entries中存储的顺序就是我们插入数据时的顺序</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这一节我们主要由浅入深了解了<strong>数据结构中的哈希表的应用和底层的原理，并且对Python中的字典也做出了详细的解释</strong>，而且解决了一个很大的知识点，那就是<strong>字典有序性问题</strong>，所以如果读者朋友你的Python环境还在3.6版本之前，那就需要在写代码的时候格外注意这个问题了。</p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>0.2 自动化运维番外篇-数据结构-2</title>
    <url>/posts/2f28b1c7.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>首先说明，以下几类读者请自行对号入座：</p>
<ul>
<li><p>刚接触编程并对底层原理知之甚少，但又<strong>想了解一下数据结构的读者，强烈建议阅读此篇</strong>；</p>
</li>
<li><p>计算机专业在读，对编程有一定了解，但<strong>对数据结构不够熟悉的读者，强烈建议阅读此篇</strong>；</p>
</li>
<li><p>传统运维想要快速上手自动化，没有精力对底层原理做深入了解的，请跳过此番外篇系列；</p>
</li>
<li><p>计算机专业出身并对数据结构有系统了解的读者，请跳过此系列番外篇。</p>
</li>
</ul>
<p>我们在【自动化运维新手村】初见Python 一文中涉及到了Python中的列表和字典，我们提到<strong>列表是有序的，而字典不是有序的</strong>，大家可能对这个概念会有疑问？</p>
<p>列表有序性并不是指<strong>存储的元素是按顺序排列的</strong>，而是指元素存储的顺序会保持不变，<strong>任何时候遍历都会是创建时的顺序</strong>；</p>
<p>但字典却不是，在Python3.6之前，字典在<strong>每次遍历的时候顺序都可能是不同的</strong>（仅限于3.6版本之前，之后的版本字典就变为有序字典，所以再看到有的文章盲目说Python是无序的，那要么是这个文章太老了，要不就….)</p>
<p><strong>今天我们就带着大家从计算机的底层结构来深入理解一下Python中的列表和字典。</strong></p>
<span id="more"></span>

<h2 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a><strong>数组（Array）</strong></h2><p><strong>Python中的列表对应的数据结构就是数组</strong>，数组是一种十分常见的数据结构，属于线性表的一种。在计算机中的存储的样子大概是如下：</p>
<p><img src="https://xzsh9e8v26.feishu.cn/space/api/box/stream/download/asynccode/?code=NTJmYTgzZjEwZWFmMGU1ZGUyYzZhYjRmNWJiMGNlMzhfT1lqcXNCclNjQnJlMDRCRGhibHExM2J1OFlIQ0s0OHVfVG9rZW46Ym94Y25jd2lQM2JzdkNzTE53bmFNd2d6ZUZnXzE2ODA5MzUyNzQ6MTY4MDkzODg3NF9WNA" alt="img"></p>
<p><strong>数组可以实现的操作有下面几种：</strong></p>
<ul>
<li><strong>存储</strong></li>
<li><strong>按下标索引</strong></li>
<li><strong>插入和删除</strong></li>
<li><strong>修改</strong></li>
<li><strong>遍历</strong></li>
</ul>
<p>那我们就根据数组的存储原理来依次讲解：</p>
<h3 id="1-存储"><a href="#1-存储" class="headerlink" title="1. 存储"></a><strong>1. 存储</strong></h3><p>任何一种数据结构在计算机中存储的时候都需要考虑所占用空间大小的问题，<strong>那么数组究竟占用多少空间呢</strong>？</p>
<p>在数据结构中，<strong>数组中只能存储相同类型的元素</strong>，所以整个数组的空间大小其实<strong>取决于数组中元素的类型和元素的数量</strong>，不同数据类型占用的空间如下表：</p>
<p>无法复制加载中的内容</p>
<p>所以，假设我们定义了一个10个长度的int类型的数组变量 <code>int_array</code>，那么它在内存中占用的空间大小为40个字节，并且是<strong>连续的40个字节</strong>。</p>
<h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a><strong>2. 索引</strong></h3><p>数组一个很大的好处就是可以<strong>按下标进行索引</strong>，假设我们有一个数组<code>int_array = [1, 2, 3, 4, 5, 6]</code>，那么我们可以直接根据下标取到对应的元素，比如<code>int_array[3]</code>，就是取下标为3的元素。</p>
<p><strong>划重点：数组下标从0开始</strong></p>
<p>有个有意思的梗：<strong>想要看一个人是不是程序员，只要让他数十个数就可以，如果他从0开始数，那就铁定是程序员了</strong>。</p>
<p>很多人可能也会有疑问，为什么下标会从0开始，其实这也和数据的底层存储有关。</p>
<p>我们这里定义一个具有10个int元素的数组变量<code>int_array</code>，当我们定义一个变量时，这个变量在内存中就有了一个地址，我们假设它为<code>base_address</code></p>
<p>那么<code>int_array</code>所占的内存空间就是从<code>base_address</code>到<code>base_address+10*4</code>，10为元素数量，4为元素类型大小。</p>
<p>由此可知，当我们要找<code>int_array</code>的第一个元素时，我们需要知道他的内存地址，他的内存地址的计算方法就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">int_array[i]_address = base_address + i * sizeOf(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>所以数组中我们常说的下标其实也叫做<strong>偏移量</strong>，想要按下标寻址某个元素，就是知道它的偏移量，那么<strong>理所当然数组中第一个元素肯定偏移量是0</strong>。</p>
<h3 id="3-插入删除"><a href="#3-插入删除" class="headerlink" title="3. 插入删除"></a><strong>3. 插入删除</strong></h3><p>数组的插入和删除分为在末尾进行插入和删除，以及在中间进行插入和删除</p>
<h5 id="数组尾部插入和删除"><a href="#数组尾部插入和删除" class="headerlink" title="数组尾部插入和删除"></a><strong>数组尾部插入和删除</strong></h5><p>我们根据上面的介绍已经知道了数组在内存中是一块连续的空间，所以当在数组的尾部进行插入和删除时，不需要任何额外的操作，**时间复杂度为O(1)**。</p>
<h5 id="数组中间插入和删除"><a href="#数组中间插入和删除" class="headerlink" title="数组中间插入和删除"></a><strong>数组中间插入和删除</strong></h5><p>当我们在数组的中间进行插入时，我们需要将插入位置之后的元素<strong>都向后挪动一位</strong>，然后将要插入的元素放在指定下标处；</p>
<p>而在数组中间进行删除时，为了保证数组内存空间的连续性，就需要将<strong>该下标位置之后的元素依次向前挪动一位</strong>；</p>
<p>当在数组的开头位置处进行插入删除时，<strong>性能耗费最大，时间复杂度为O(n)</strong></p>
<h3 id="4-修改"><a href="#4-修改" class="headerlink" title="4. 修改"></a><strong>4. 修改</strong></h3><p>数组的修改的话其实就是先根据下标索引到该元素所在的内存地址，然后再对其进行修改，我们这里不做赘述。</p>
<h3 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5. 遍历"></a><strong>5. 遍历</strong></h3><p><strong>由于数组内存空间的连续性，我们创建数组时元素的排列，无论何时遍历都可以保证是相同的，所以我们称数组具有有序性。</strong></p>
<h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a><strong>列表（List）</strong></h2><p>由于Python中的列表对应的数据结构就是数组，所以我们<strong>搞清楚了数组的原理，对于列表的理解就会容易很多</strong>。</p>
<p>Python的列表具有和数组相同的操作方法，即遍历，索引，插入，删除，但也有<strong>不同之处</strong></p>
<h3 id="1-元素"><a href="#1-元素" class="headerlink" title="1. 元素"></a><strong>1. 元素</strong></h3><p>我们默认数据结构中的数组所存储的元素都是相同类型的，事实上很多语言，例如C，Golang，Java等都要求在定义数组时声明其类型。</p>
<p>比如Golang的数组创建的语法就为<code>var intArray = []int&#123;&#125;</code>，但Python做为动态语言，并不要求类型定义，所以我们可以定义一个数组，<strong>存储任意类型的元素类型</strong>，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; array = [1]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; array.append(<span class="string">&quot;2&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">array 为 [1, <span class="string">&quot;2&quot;</span>]</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; array.append([3, 4])</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">array 为 [1, <span class="string">&quot;2&quot;</span>, [3, 4]]</span></span><br></pre></td></tr></table></figure>

<p>所以Python中的列表虽然<strong>仍保留了数组的空间连续性，但它所占用的空间大小，却是和数组中存储的元素类型密切相关</strong>。</p>
<h3 id="2-长度"><a href="#2-长度" class="headerlink" title="2. 长度"></a><strong>2. 长度</strong></h3><p>我们默认数据结构中的数组在<strong>定义时需要初始化其长度</strong>，也就是其存储的元素数量，这样方便程序为其分配固定大小的内存空间，如C语言中数组的定义为<code>int a[10]=&#123;0&#125;;</code>，含义为初始化一个包含10个int类型元素的数组，每个元素默认赋值为0。</p>
<p>但<strong>Python在定义数组时并不要求定义其长度</strong>，语法为<code>array = []</code>，我们定义了一个数组变量为<code>array</code>，后续可以向其任意添加元素。</p>
<p>&#x2F;&#x2F; List列表的具体结构如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// List列表的具体结构如下所示</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line"></span><br><span class="line">    /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */</span><br><span class="line"></span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    /* ob_item contains space for &#x27;allocated&#x27; elements. The number</span><br><span class="line"></span><br><span class="line">     * currently in use is ob_size.</span><br><span class="line"></span><br><span class="line">     * Invariants:</span><br><span class="line"></span><br><span class="line">     * 0 &lt;= ob_size &lt;= allocated</span><br><span class="line"></span><br><span class="line">     * len(list) == ob_size</span><br><span class="line"></span><br><span class="line">     * ob_item == NULL implies ob_size == allocated == 0</span><br><span class="line"></span><br><span class="line">     * list.sort() temporarily sets allocated to -1 to detect mutations.</span><br><span class="line"></span><br><span class="line">     *</span><br><span class="line"></span><br><span class="line">     * Items must normally not be NULL, except during construction when</span><br><span class="line"></span><br><span class="line">     * the list is not yet visible outside the function that builds it.</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line"></span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>

<p>Python中的List<strong>本质上是一个长度可变的连续数组</strong>。其中存在一个指针列表<code>ob_item</code>，里边的每一个指针都指向列表中的元素，而 <code>allocated</code>则用于存储该列表目前已被分配的空间大小。</p>
<p>需要注意的是，<code>allocated</code> 和列表的实际空间大小不同，列表实际空间大小，指的是 <code>len(list)</code> 返回的结果，也就是上边代码中注释中的 <code>ob_size</code>，表示该列表总共存储了多少个元素。</p>
<p>而在实际情况中，为了<strong>优化存储结构，避免每次增加元素都要重新分配内存，列表预分配的空间</strong> <code>**allocated**</code> <strong>往往会大于</strong> <code>**ob_size**</code><strong>。</strong></p>
<p>因此 <code>allocated</code> 和 <code>ob_size</code> 的关系是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">allocated &gt;= len(<span class="built_in">list</span>) = ob_size &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果当前列表分配的空间已满（即 <code>allocated == len(list)</code>），则会向系统请求更大的内存空间，并把原来的元素全部拷贝过去。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这篇文章我们<strong>着重理解了数组的底层原理以及Python中的List</strong>，这对于后续我们的编程会起到很大的帮助。</p>
<p>如果把用Python编程比作是在计算机上蒙了一块黑布的话，那么对于计算机底层原理的学习，就会让我们一点点揭开这块黑布，<strong>最终直到我们写下每一行代码都能够清晰的了解到其真正的底层运行逻辑</strong>。</p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>0.4 自动化运维番外篇-Python参数</title>
    <url>/posts/31708b27.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>这是自动化运维新手村中除了数据结构番外篇之外的另一个番外，这个番外主要给大家详细讲解一下Python中的一些<strong>特殊技巧。</strong></p>
<p>这些技巧在平时写代码的过程中会极大的帮助我们快速的解决问题，所以你想成为一个真正的<strong>Pythoner</strong>，想让自己的代码更<strong>Pythonic</strong>，一定要仔细阅读这个番外！</p>
<p>在之前的文章中我们偶尔有使用到<code>*args</code>作为函数参数，与之对应的还有<code>**kwargs</code>，这对于刚接触Python的朋友会有点儿晕，这篇文章我就<strong>一次性将Python中的参数讲解清楚。</strong></p>
<p>Python的参数可分为<strong>必传参数</strong>（必填）、<strong>默认参数</strong>（有默认值的非必填）、<strong>可变参数</strong>，这三种参数适用的场景不同，主要区别在于实参与形参的映射关系。</p>
<span id="more"></span>

<blockquote>
<p>形参 -&gt; 实参</p>
</blockquote>
<p>本文以实现一个学生的个人情况函数为例。</p>
<h2 id="必传参数"><a href="#必传参数" class="headerlink" title="必传参数"></a><strong>必传参数</strong></h2><p>通俗来说，<strong>必传参数</strong>就是必须传入的参数，其特点就是<strong>必填</strong>。定义<code>student()</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name, age</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am %s years old.&quot;</span> % age)</span><br></pre></td></tr></table></figure>

<p>我们可以通过调用<code>student()</code>函数来观察一下必传参数有什么特点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student(<span class="string">&quot;ethan&quot;</span>, <span class="number">18</span>) <span class="comment"># 输出 My name is ethan \n Iam 18 years old.</span></span><br><span class="line"></span><br><span class="line">student(<span class="number">18</span>, <span class="string">&quot;ethan&quot;</span>) <span class="comment"># 输出 My name is 18 \n Iam ethan years old.</span></span><br></pre></td></tr></table></figure>

<p>\1. 一般来说，必传参数会按照<strong>函数定义时的顺序传入</strong>，即按位置进行映射。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student(name=<span class="string">&quot;ethan&quot;</span>, age=<span class="number">18</span>) <span class="comment"># 输出 My name is ethan \n Iam 18 years old.</span></span><br><span class="line"></span><br><span class="line">student(age=<span class="number">18</span>, name=<span class="string">&quot;ethan&quot;</span>) <span class="comment"># 输出 My name is ethan \n Iam 18 years old.</span></span><br></pre></td></tr></table></figure>

<p>\2. 如果<strong>指定了所有必传参数的名称，则可以不按顺序传入</strong>，即按名称进行映射。</p>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a><strong>默认参数</strong></h2><p>此时有一个新需求，需要给学生的<code>age</code>设置默认值为18，即</p>
<ul>
<li>不传<code>age</code>时，<code>age</code>为默认值（18）。</li>
<li>传<code>age</code>为18时，<code>age</code>为传入值。</li>
</ul>
<p>这里，使用默认参数（又叫关键字参数，非必填且有默认值），其表现形式为在形参后接 <code>=默认值</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name, age=<span class="number">18</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am %s years old.&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">student(<span class="string">&quot;ethan&quot;</span>) <span class="comment"># 输出 My name is ethan \n Iam 18 years old.</span></span><br><span class="line"></span><br><span class="line">student(<span class="string">&quot;ethan&quot;</span>, age=<span class="number">20</span>) <span class="comment"># 输出 My name is ethan \n Iam 20 years old.</span></span><br></pre></td></tr></table></figure>

<p>上述指定了默认的<code>age</code>参数为18。</p>
<p>我们下面分为<strong>仅定义默认参数时</strong>、<strong>同时定义必传参数和默认参数时</strong>两种情况来讨论默认参数的具体特点。</p>
<h3 id="仅定义默认参数时"><a href="#仅定义默认参数时" class="headerlink" title="仅定义默认参数时"></a><strong>仅定义默认参数时</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name=<span class="string">&quot;ethan&quot;</span>, age=<span class="number">18</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am %s years old.&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">student(<span class="string">&quot;ethan&quot;</span>) <span class="comment"># 输出 My name is ethan \n Iam 18 years old.</span></span><br><span class="line"></span><br><span class="line">student(age=<span class="number">20</span>, name=<span class="string">&quot;ethan&quot;</span>) <span class="comment"># 输出 My name is ethan \n Iam 18 years old.</span></span><br></pre></td></tr></table></figure>

<p><em>1.1</em> 函数调用时，默认参数的映射规则与必传参数相似，即：</p>
<ul>
<li>一般情况下按位置；</li>
<li>指定全部名称情况下按名称。</li>
</ul>
<h3 id="同时定义必传参数和默认参数时"><a href="#同时定义必传参数和默认参数时" class="headerlink" title="同时定义必传参数和默认参数时"></a><strong>同时定义必传参数和默认参数时</strong></h3><p><em>2.1</em> 定义函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name, city=<span class="string">&quot;HZ&quot;</span>, nation=<span class="string">&quot;CN&quot;</span>, age</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># SyntaxError: non-default argument follows default argument</span></span><br></pre></td></tr></table></figure>

<p>定义函数时，<strong>必传参数不可以定义在默认参数后面</strong>。</p>
<p><em>2.2</em> 调用函数时，以下定义一个<code>student()</code>函数来讨论。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name, age, city=<span class="string">&quot;HZ&quot;</span>, nation=<span class="string">&quot;CN&quot;</span></span>): <span class="comment"># name，age为必传，city，nation是默认</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am %s years old.&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am located at %s, %s&quot;</span> % (city, nation))</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>name</code>，<code>age</code>为必传参数，</li>
<li><code>city</code>，<code>nation</code>为默认参数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student(<span class="string">&quot;ethan&quot;</span>, nation=<span class="string">&quot;SG&quot;</span>, <span class="number">18</span>, city=<span class="string">&quot;BJ&quot;</span>) <span class="comment"># SyntaxError: positional argument follows keyword argument</span></span><br><span class="line"></span><br><span class="line">student(<span class="string">&quot;ethan&quot;</span>, nation=<span class="string">&quot;SG&quot;</span>, age=<span class="number">18</span>, city=<span class="string">&quot;BJ&quot;</span>) <span class="comment"># 输出 name=ethan age=18 city=BJ nation=SG</span></span><br></pre></td></tr></table></figure>

<p>\1. 一般情况下，<strong>必传参数必须出现在默认参数前面</strong>，否则映射关系不明确，会报错。</p>
<blockquote>
<p>可以这么理解，若默认参数出现在必传参数前面，那第一个参数到底是有传入的默认参数还是在不传默认参数的情况下的必传参数呢？</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student(name=<span class="string">&quot;ethan&quot;</span>, nation=<span class="string">&quot;SG&quot;</span>, age=<span class="number">18</span>, city=<span class="string">&quot;BJ&quot;</span>) <span class="comment"># 输出 name=ethan age=18 city=BJ nation=SG</span></span><br></pre></td></tr></table></figure>

<p>\2. 如果指定了所有必传参数的名称，则可以不考虑传入的顺序。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变参数</strong></h2><p>现在新增一个需求，需要计算学生的学科总分，并且学科的数量不定，最多3个。</p>
<p>这个需求可以通过默认参数来实现，设置3个默认参数，其默认值为<code>None</code>，在函数内部进行判断该值是否传入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name, age, subject_1=<span class="literal">None</span>, subject_2=<span class="literal">None</span>, subject_3=<span class="literal">None</span></span>): <span class="comment"># subject_*为穷举出来的学科分数</span></span><br><span class="line"></span><br><span class="line">    sum_score = <span class="number">0</span> <span class="comment">## 总分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subject_1) &#123;</span><br><span class="line"></span><br><span class="line">        sum_score += subject_1</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subject_2) &#123;</span><br><span class="line"></span><br><span class="line">        sum_score += subject_2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subject_3) &#123;</span><br><span class="line"></span><br><span class="line">        sum_score += subject_3</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My sum score is &quot;</span> % sum_score)</span><br></pre></td></tr></table></figure>

<ul>
<li>在不定参数有限可穷举的情况下，才能通过默认参数来实现，且代码冗余较多。</li>
<li>但是如果不定参数数量不可估算，则默认参数无法实现。</li>
</ul>
<p>因此，为了解决这一问题，Python引入了<strong>可变参数（非必传且传入个数可变）</strong>，在之前的文章中我们偶尔有使用到<code>*args</code>、<code>**kwargs</code>作为函数参数，这两个都属于可变参数。</p>
<p>可变参数使用到了Python中的一个语法特性：<strong>打包和解包</strong></p>
<blockquote>
<p>打包：把多个值打包成一个元组。</p>
</blockquote>
<blockquote>
<p>解包：把一个元组或数组解析成多个值。</p>
</blockquote>
<h3 id="打包和解包"><a href="#打包和解包" class="headerlink" title="打包和解包"></a><strong>打包和解包</strong></h3><p>关于打包和解包在很多语言中都支持这个特性，但使用的语法略有不同，下面通过几个例子了解一下Python中的打包解包如何使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = <span class="number">80</span>, <span class="number">90</span>, <span class="number">98</span> <span class="comment"># 打包语法</span></span><br><span class="line"></span><br><span class="line">chinese, math, english = val <span class="comment"># 解包语法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chinese, math, english) <span class="comment"># 输出 80, 90, 98</span></span><br><span class="line"></span><br><span class="line">chinese, math, english = scores <span class="comment"># ValueError: not enough values to unpack (expected 4, got 3)</span></span><br></pre></td></tr></table></figure>

<p>\1. 在其他编程语言中，不会出现<strong>一个等号左边多个变量而右边只有一个变量的语法</strong>，这种写法是Python中特有的解包语法。</p>
<p>\2. 被解包的序列中的元素数量必须与赋值符号<code>=</code>左边元素的<strong>数量完全一样。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = <span class="number">80</span>, <span class="number">90</span>, <span class="number">98</span>, <span class="number">100</span> <span class="comment"># 打包语法</span></span><br><span class="line"></span><br><span class="line">a, b = scores <span class="comment"># ValueError: too many values to unpack (expected 2)</span></span><br><span class="line"></span><br><span class="line">a, *b, c = scores <span class="comment"># 打包和解包语法一起使用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># [90, 98]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<p>\3. 可以在<strong>等号左边使用打包语法，如*b</strong>，<strong>将等号右边变量的多个值打包赋值给变量b，此时b为列表类型的变量</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = [<span class="number">80</span>, <span class="number">90</span>]</span><br><span class="line"></span><br><span class="line">chinese, math = *scores <span class="comment"># SyntaxError: can&#x27;t use starred expression here</span></span><br></pre></td></tr></table></figure>

<p>\4. <strong>不能将</strong><code>*****</code><strong>操作符用于表达式的右边</strong>，这是需要特别注意的，如果要解包，直接使用<code>a, b = val</code>即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name, age, city, nation</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am %s years old.&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am located at %s, %s&quot;</span> % (city, nation))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">student(*[<span class="string">&quot;ethan&quot;</span>, <span class="number">18</span>, <span class="string">&quot;BJ&quot;</span>, <span class="string">&quot;CN&quot;</span>]) <span class="comment"># 输出 My name is ethan \n Iam 18 years old. I am located at HZ, CN.</span></span><br><span class="line"></span><br><span class="line">student(*[<span class="string">&quot;ethan&quot;</span>, <span class="number">18</span>, <span class="string">&quot;BJ&quot;</span>]) <span class="comment"># TypeError: student() missing 1 required positional argument: &#x27;nation&#x27;</span></span><br></pre></td></tr></table></figure>

<p>\5. <strong>解包同样可以运用于函数传参中</strong>，上面例子就是将数组解包传入函数中，分别对应<code>a, b, c</code>三个形参。</p>
<p>\6. <strong>解包后的数量必须与函数定义的形参数量相同</strong>。</p>
<p>如果我们不知道具体会传入多少个参数，这时候就要<code>*args</code>上场了</p>
<h3 id="args"><a href="#args" class="headerlink" title="*args"></a>*<strong>args</strong></h3><p><code>*args</code>属于参数中的可变参数，因为它并没有指定关键字，而是表示诸多参数的合并。</p>
<p>这里函数定义时的<code>*</code>其实就是起到打包的作用，函数定义时的<code>*args</code>可以表示任意个数的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name, *scores</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My scores are &quot;</span>, *scores)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My avg score is &quot;</span>, <span class="built_in">sum</span>(scores))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">student(<span class="string">&quot;ethan&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 My name is ethan</span></span><br><span class="line"></span><br><span class="line">student(<span class="string">&quot;ethan&quot;</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 My name is ethan \n My scores are 80 \n My sum score is 80</span></span><br><span class="line"></span><br><span class="line">student(<span class="string">&quot;ethan&quot;</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">98</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 My name is ethan \n My scores are 80 90 98 \n My sum score is 268</span></span><br></pre></td></tr></table></figure>

<p>根据上面的实例可以观察到以下几点：</p>
<p>\1. <code>***args**</code><strong>可以将多个参数打包成一个元组。</strong></p>
<p>\2. <code>***args**</code><strong>是可变参数，可以不传，也可以传任意多个。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">*scores, name</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My scores are &quot;</span>, *scores)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">student(<span class="number">80</span>, <span class="number">90</span>, <span class="string">&quot;ethan&quot;</span>) <span class="comment"># 输出 TypeError: foo() missing 1 required keyword-only argument: &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">student(<span class="number">80</span>, <span class="number">90</span>, name=<span class="string">&quot;ethan&quot;</span>) <span class="comment"># 输出 My name is ethan \n My scores are 80 90</span></span><br></pre></td></tr></table></figure>

<p>\3.  <code>args</code>只是<strong>通俗约定的名称，实际可以叫任何其他的名称</strong>，例如本例中就叫做<code>scores</code>。 </p>
<p>\4. <code>*args</code>本质上<strong>为在函数传参时将剩余所有的参数一起打包</strong>，所以上面的案例中，我们无论传几个参数，都会被<code>*args</code>打包，而函数定义中的<code>name</code>参数则永远都不会有值，而<code>name</code>不是可变参数，属于必传参数，所以会直接报错</p>
<p>\5. 由于必传参数可以通过指定参数名称传入，所以<strong>当定义函数时必传参数位于可变参数后，调用时就必须指定参数名称</strong></p>
<p>大家可以假设一下如果不用<code>*args</code>的话会怎么样？以Python中最常用的<code>print</code>函数为例，定义如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self, *args, sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=<span class="literal">None</span></span>): <span class="comment"># known special case of print</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 输出 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>根据<code>print</code>函数的定义，可以直接<code>print(1, 2, 3)</code>，或者传入任何数量个想要打印输出的变量，那么不用<code>*args</code>的话，改写如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self, args, sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=<span class="literal">None</span></span>): <span class="comment"># known special case of print</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># 输出 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>同样要实现打印任何数量个变量，我们就必须将其组合成一个数组或元组传入，上述打印<code>[1, 2, 3]</code>的例子还勉强可以接受的话，那么如果想要打印很多不同类型的变量的时候，还需要将这些不同类型的变量先组成一个数组，这就会让代码<strong>显得很怪异，似乎不符合逻辑</strong>，而且代码的可读性也会下降。</p>
<h3 id="kwargs"><a href="#kwargs" class="headerlink" title="**kwargs"></a>*<strong>*kwargs</strong></h3><p><code>*</code>操作其实本质上讲就是<strong>对于可迭代对象的解包</strong>，对于列表和元组这种可迭代对象，<code>*</code>就可以直接将其解包成一个一个的元素。</p>
<p>但字典同样是可迭代对象，那么对字典使用<code>*</code>操作会是什么样的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name, age</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am %s years old.&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">student(*&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;ethan&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;) <span class="comment"># 输出 My name is name \n I am age years old.</span></span><br><span class="line"></span><br><span class="line">student(*&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ethan&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>&#125;) <span class="comment"># 输出 My name is Name \n Iam Age years old.</span></span><br></pre></td></tr></table></figure>

<p>从上面的输出结果可以看出，<code>*****</code><strong>解包操作似乎只是讲字典的键做了解包</strong>，所以上述的函数调用其实等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fun(*[<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>])</span><br><span class="line"></span><br><span class="line">fun(*[<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>那么如果想对键和值都做解包要怎么实现呢？</p>
<p><strong>在Python中对于字典的打包解包要使用</strong><code>***\***</code><strong>，如下</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student(**&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;ethan&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;) <span class="comment"># 输出 My name is ethan \n I am 18 years old.</span></span><br></pre></td></tr></table></figure>

<p>\1. <strong>对于字典解包进行传参，必须保证字典的键和函数定义的形参名称一致</strong></p>
<blockquote>
<p>很多朋友对于<code>*</code>和<code>**</code>总是搞混淆，其实我的记法是，<code>*</code>可以相当于对可迭代对象的元素寻址，但根据字典的底层数据结构，字典底层是一个二维数组，那么对于二维数组的元素寻址就需要使用两个<code>*</code>。</p>
</blockquote>
<p>同样的如果我们定义函数时<strong>无法确定需要传入什么样的关键字参数呢</strong>？那么就可以在定义函数时使用关键字参数的打包语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name, age, *scores, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am %s years old.&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My scores are &quot;</span>, *scores)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My avg score is &quot;</span>, <span class="built_in">sum</span>(scores)/<span class="built_in">len</span>(scores))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Other information:&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">student(<span class="string">&quot;ethan&quot;</span>, <span class="number">18</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">98</span>, gender=<span class="string">&quot;male&quot;</span>, weight=<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 输出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">My name is ethan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I am 18 years old.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">My scores are 80 90 98</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">My avg score is 89.33333333333333</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Other information: &#123;&#x27;gender&#x27;: &#x27;male&#x27;, &#x27;weight&#x27;: 70&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">student(<span class="string">&quot;ethan&quot;</span>, <span class="number">18</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">98</span>, **&#123;<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;male&quot;</span>, <span class="string">&quot;weight&quot;</span>:<span class="number">70</span>&#125;) <span class="comment"># 输出同上</span></span><br></pre></td></tr></table></figure>

<p>\2. <code>**kwargs</code>同样是一个<strong>约定俗成的写法</strong>，没有其他特殊含义，但是为了代码可读性，<strong>最好还是用约定俗成的</strong>。</p>
<p>\3. 在函数定义的形参中<code>***args**</code><strong>是对多个参数进行打包，而</strong><code>***\*kwargs**</code><strong>是对关键字参数进行打包。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>一般特殊技巧虽然好用，但都有一些额外需要注意的地方，所以显而易见的是我们这篇文章太“干”了，但这又是想写出更Pythonic的代码所必须要经历的。</p>
<p>最后留一个小问题供大家思考，为什么不能使用<code>print(**kwargs)</code>来打印关键字参数解包后的结果？</p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>可变参数</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>0.5 自动化运维番外篇-调试</title>
    <url>/posts/305cfeff.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p><strong>这是自动化运维新手村里最重要的一篇番外，没有之一。</strong></p>
<p><strong>调试</strong>应该是所有编程语言中都需要用到的一种技巧，不管对于编程新手还是资深码农，调试都会是不可或缺的技能。</p>
<p>刚接触编程的朋友经常会遇到的困惑就是，<strong>已经了解某段代码的功能逻辑，但却对于逻辑具体的实现却充满疑惑，其实这是十分正常的现象。</strong></p>
<span id="more"></span>

<h2 id="看不懂代码？"><a href="#看不懂代码？" class="headerlink" title="看不懂代码？"></a><strong>看不懂代码？</strong></h2><p>最本质的原因是抽象到具体之间存在一定的代沟。功能逻辑其实就是对某个场景或需求，依照我们的编程思路抽象出完成该功能的过程。</p>
<p>功能逻辑是通用的，可以用任何语言去实现这个功能，但不同语言之前的实现方式就会有所区分甚至<strong>大相径庭</strong>。</p>
<p>Python这门语言其实已经是对于新手来说相对友好的语言，功能逻辑和代码的具体实现之间不会有太大差异，甚至有的<strong>代码阅读起来就像英文一样</strong>，清晰易懂。</p>
<p>但编程语言总归是<strong>面向计算机的，而不是面向人脑的</strong>，计算机处理代码的方式以及很多时候为了程序健壮性所作出的边界处理都会让刚接触编程的朋友较难理解。</p>
<p>除此之外还包括每个人编程风格的不同，也会造成代码阅读的困难。</p>
<p>所以对于刚开始看不懂代码的朋友来说，<strong>调试是一个十分好用的方法</strong>，今天这篇文章就给大家详细介绍一下<strong>代码调试</strong>，帮大家排除编程路上<strong>看不懂代码</strong>的障碍</p>
<h2 id="什么是调试"><a href="#什么是调试" class="headerlink" title="什么是调试"></a><strong>什么是调试</strong></h2><p><strong>调试通俗的讲就是将程序解剖开然后呈现在我们面前</strong>，解剖的方式也有很多种：</p>
<p><strong>1.</strong> 将整个代码<strong>拆解成一个个代码块</strong>，分别去执行，以此来了解代码中不同阶段不同步骤所执行的结果。</p>
<p><strong>2.</strong> 在代码中想要观察的地方<strong>插入打印输出语句</strong>，这样当代码运行起来后就可以观察到此处的具体内容。</p>
<p><strong>3.<strong>使用</strong>断点调试</strong>，在想要观察的地方加入断点，让程序执行到此处时中断，这时就可以仔细分析断点处的变量情况以及查看上下文信息。</p>
<h3 id="调试的作用"><a href="#调试的作用" class="headerlink" title="调试的作用"></a><strong>调试的作用</strong></h3><p>调试的作用一般分为两种：</p>
<h4 id="排查bug。"><a href="#排查bug。" class="headerlink" title="排查bug。"></a><strong>排查bug。</strong></h4><p>当程序运行出现错误，并且通过错误日志无法判断出异常原因时，可以尝试重现bug，并通过上面几种调试的手段来观察程序的执行，以此来判断真正的异常原因</p>
<h4 id="分析代码。"><a href="#分析代码。" class="headerlink" title="分析代码。"></a><strong>分析代码。</strong></h4><p>如果已经了解了代码的大致逻辑，但对于代码的细节处理仍有疑惑，或者某些使用循环逻辑的地方较难直接用头脑分析演算出执行过程，这时候就可以借助调试手段来更为详尽准确的分析代码。</p>
<h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a><strong>如何调试</strong></h2><p>上文的三种调试方法中，前两种都十分简单，我觉得即使对于刚接触编程的朋友来说应该也都可以自己尝试使用。</p>
<p>今天我们着重讲解一下第三点：<strong>断点调试</strong>，这里主要是达到分析代码的作用，至于排查bug我们后续会详细讲解。</p>
<p>任何语言编程语言，不管是Java，C++，Golang还是Python，都可以借助工具实现断点调试，对于Python来说一般主流的代码编辑器都具备断点调试的功能，比如VSCode或者Pycharm。</p>
<p>但今天先不讲解如何通过IDE（Integrated Development Environment，集成开发环境）自带的功能做调试，而是教给大家一个Python里面自带的代码调试方法，<strong>我觉得这种方式是最为通用的，即使在没有IDE的服务器上也一样可以进行代码调试</strong>。</p>
<h2 id="PDB"><a href="#PDB" class="headerlink" title="PDB"></a><strong>PDB</strong></h2><p><code>pdb</code>是Python<strong>内置的一个方法库</strong>，为 Python 程序提供了一种交互的源代码调试功能。</p>
<p>主要特性包括设置断点、单步调试、进入函数调试、查看当前代码、查看栈片段、动态改变变量的值等。</p>
<p>这里举一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    ret = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line"></span><br><span class="line">        tmp = i ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        ret.append(tmp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    args = sys.argv</span><br><span class="line"></span><br><span class="line">    result = foo(<span class="built_in">int</span>(args[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br></pre></td></tr></table></figure>

<p>如上代码是一个获取从零到某个指定数字的平方序列的函数，通过命令行传入指定数字，然后返回它的平方序列。</p>
<p>我相信通过上面的解释大家都可以理解这个程序的功能逻辑，但仔细看代码实现时，大家可以会有困惑：</p>
<p>通过<code>sys.argv</code>获取到的<strong>究竟是什么，是什么类型，包含了哪些值</strong>，以及我在<code>foo()</code>函数的循环中每次<code>tmp</code>值是什么。</p>
<p><strong>当然这些问题其实应该属于Python的基础知识，理应熟记并且掌握，但对于刚接触编程的朋友来说某些基础知识可能记得不牢固，或者有的代码细节略微晦涩难懂，这时候就可以通过</strong><code>**pdb**</code><strong>这一利器来解剖代码。</strong></p>
<p>引入<code>pdb</code>并在某一行插入断点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_square.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    ret = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line"></span><br><span class="line">        tmp = i ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        ret.append(tmp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    args = sys.argv</span><br><span class="line"></span><br><span class="line">    pdb.set_trace()</span><br><span class="line"></span><br><span class="line">    result = foo(<span class="built_in">int</span>(args[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br></pre></td></tr></table></figure>

<p>在命令行中执行<code>python my_square 10</code>会得到如下输出</p>
<p><img src="https://s2.loli.net/2023/04/08/KspWId43TCvLHfu.png" alt="img"></p>
<p>这里表示程序在<code>result = foo(args[1])</code>处中断了，并且开头的<code>(Pdb)</code>表示已经进入到了<code>pdb</code>交互模式，我们这时候可以输出一些<code>pdb</code>的指令进行调试。</p>
<ol>
<li><code>**l(ist)**</code><strong>（小写的L）表示查看上下文代码</strong>，结果如下：</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/08/OqvXLYPToSN9HKx.png" alt="img"></p>
<p>可以查看到断点处的上下文代码，清晰的看到当前断点所处的位置，以此来去对上下文做出更进一步的调试操作。</p>
<ol>
<li><code>**p(rint) [var_name]**</code><strong>使用p字母加变量名查看变量</strong>，结果如下：</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/08/4qOXjHkP8QDbxpr.png" alt="img"></p>
<p>这里可以看到<code>args</code>是一个数组类型，并且第一个元素是程序代码的文件名，第二个元素才是输入的参数，所以这也是为什么我们调用函数时传入的<code>args[1]</code>。</p>
<p>这里有一个需要注意的点就是p字母在某些时候可以省略，直接输入变量名也可以查看变量详情，但<strong>当变量名与</strong><code>**pdb**</code><strong>内置的关键字冲突时就无法生效</strong>，所以建议大家平时也都使用<code>p + var_name</code>的方式查看变量。</p>
<ol>
<li><code>**s(tep)**</code><strong>使用s字母可以执行下一步并且步进到函数中去</strong>，结果如下：</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/08/nmv5iUfhHP17IOe.png" alt="img"></p>
<p>由之前的断点位置可知下一步该调用<code>foo()</code>函数，如果想观察到<code>foo()</code>函数内部的具体实现，就可以使用s字母，步进到函数体中，由上图也可以看出，输入s后已经位于了<code>foo()</code>函数的定义处，这时候就已经可以使用<code>p num</code>查看函数的参数详情了。</p>
<p>这里需要注意的是，如果想直接观察<code>foo()</code>函数，也可以在<code>foo()</code>函数内部写<code>pdb.set_trace()</code>并不是一定要从最外层步进才可以。</p>
<ol>
<li><code>**n(ext)**</code><strong>使用n字母同样可以执行下一步</strong>，结果如下：</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/08/B6puAcrM9eHaTIC.png" alt="img"></p>
<p>输入字母n之后可以让程序执行下一步，如上图我们输入n之后，-&gt;表示程序已经执行到了下一行，<strong>这里可以结合</strong><code>**p p [var_name]**</code><strong>一起使用，观察当前断点处的上下文变量信息</strong>。</p>
<ol>
<li><code>**r(eturn)**</code><strong>使用r字母同样可以执行下一步，但如果当前位于函数内，则会直接执行到函数结束处</strong></li>
</ol>
<p><img src="https://s2.loli.net/2023/04/08/veEnl8o4V2M6grb.png" alt="img"></p>
<p>如上图，输入r后直接跳转到了<code>foo()</code>函数的最后一行。</p>
<ol>
<li><code>**c(ontinue)**</code><strong>使用c字母可以继续执行程序</strong>。通常在观察到想要观察的信息后，会直接输入c执行完程序的剩余内容。</li>
<li><code>**break line_number**</code><strong>使用break+行号可以设置断点</strong>，如下图：</li>
</ol>
<p><img src="https://s2.loli.net/2023/04/08/DgHo4BCvhMUrK6N.png" alt="img"></p>
<p>输入break可以在当前行设置断点，如果break后加行号则可以在指定行号设置断点，如上图，在第八行有一个<code>B-&gt;</code>的符号，表示在第八行处有断点。</p>
<p>当通过break设置断点后，<strong>无论是输入 r 还是输入 c 都会在断点处中断</strong>，所以还需要通过 <code>clear</code>清除断点，使用<code>clear [line_number]</code>可以清除指定行号处的断点。</p>
<ol>
<li><code>**q(uit)**</code><strong>使用q字母可以直接退出调试模式</strong></li>
<li><strong>有两点需要注意的是：</strong></li>
</ol>
<p>直接输入Enter，会执行上一条命令；</p>
<p>输入PDB不认识的命令，PDB会把他当做Python语句在当前环境下执行；</p>
<p><strong>pdb还有很多其他的用法，但我们先学习这些较为常用的即可。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>代码调试虽然是一个利器，但仍需要合理正确的使用它，任何时候都不应该无脑的使用调试，而是应该<strong>先尝试理解分析代码的逻辑，这样才能事倍功半，我们还会继续在下一篇中给大家讲解一下如何使用Pycharm和VScode进行调试，敬请期待。</strong></p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>0.6 自动化运维番外篇-Pycharm调试</title>
    <url>/posts/1f97a037.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>上一篇番外讲解了调试对于编程的重要性，并且介绍了Python中的<code>pdb</code>工具包，可以帮我们在没有IDE的环境下进行代码调试。</p>
<p>但<code>pdb</code>终归是基于<strong>命令行交互式</strong>的，对于刚接触编程的朋友来说并不友好，并且在日常开发中，如果代码架构略微复杂，或者是引用的第三方库，不太了解具体的实现细节，<strong>那么</strong><code>**pdb**</code><strong>就不是最合适的调试方法</strong>了。</p>
<p>那么今天我们就讲解一下最容易上手且很直观的<strong>IDE调试方法</strong></p>
<span id="more"></span>

<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a><strong>IDE</strong></h2><p>集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序。</p>
<p>一般包括代码<strong>编辑器、编译器、调试器和图形用户界面</strong>等工具。</p>
<p>集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。</p>
<p>所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。</p>
<p><strong>目前Python语言中使用最常用的就是Pycharm和VSCode。</strong></p>
<p><strong>今天我们就详细讲解一下如何使用Pycharm进行调试</strong></p>
<h2 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a><strong>Pycharm</strong></h2><p>IDE除了显而易见的代码补全功能以外，清晰便捷的Debug功能也是非常重要的，<strong>如果你还是只用Pycharm来编辑代码，那可就有点儿暴殄天物了</strong>。</p>
<p>这次仍然用<code>pdb</code>篇中的示例代码为大家讲解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    ret = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line"></span><br><span class="line">        tmp = i ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        ret.append(tmp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    args = sys.argv</span><br><span class="line"></span><br><span class="line">    result = foo(<span class="built_in">int</span>(args[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br></pre></td></tr></table></figure>

<p>在Pycharm中展示如下图</p>
<p><img src="https://s2.loli.net/2023/04/08/SpfojDNIZ4TyxV8.png" alt="img"></p>
<p>关于Pycharm的其他细节使用不是今天这篇文章的主题，我们就略过不谈，单独了解一下Pycharm的调试功能</p>
<h3 id="开启调试"><a href="#开启调试" class="headerlink" title="开启调试"></a><strong>开启调试</strong></h3><p>Pycharm开启调试有三种方法</p>
<p>**1.**当文件中有<code>if __name__ == &quot;__main__&quot;:</code>时，Pycharm会识别到，并将该行标识为程序入口，用一个绿色的三角形表示。</p>
<p>左键单击该三角形会有一个下拉框，第二个选项<code>Debug &#39;main&#39;</code>就是开启调试的按钮</p>
<p><img src="https://s2.loli.net/2023/04/08/wNKMjuvmIXrRbfy.png" alt="img"></p>
<p>**2.**在文件空白处右键单击可以弹出下拉选相框，其中同样会有<code>Debug &#39;main&#39;</code>按钮</p>
<p><img src="https://s2.loli.net/2023/04/08/A7ymclLR8iPgGoJ.png" alt="img"></p>
<p>**3.**工具栏中有一个虫子符号的按钮，同样也是<code>Debug &#39;main&#39;</code>的按钮</p>
<p><img src="https://s2.loli.net/2023/04/08/cIShxJ786TRXmAi.png" alt="img"></p>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a><strong>断点调试</strong></h3><p>**1.**右侧黄色框中点击可以为指定行添加断点，添加断点后程序会执行到断点所在行中断，断点所在行为将要执行的下一行代码</p>
<p><img src="https://s2.loli.net/2023/04/08/oU8HsOJxB5CiWbf.png" alt="img"></p>
<p>**2.**我们已经在12行添加了一个断点，现在采取上述任意一种方式开启调试后，Pycharm页面如下图</p>
<p><img src="https://s2.loli.net/2023/04/08/NmHUqQu1SaLXKGz.png" alt="img"></p>
<p><strong>页面中有几大重要的部分已经通过红框和注释标识出来，我分别对其做一下详细的解释：</strong></p>
<ol>
<li><strong>变量值：</strong></li>
</ol>
<p>进行调试一个最主要的目的就是要知道程序运行过程中，定义的变量是如何变化的，他们的值或者类型分别是什么？</p>
<p><strong>Pycharm会在程序代码每行的行尾空白处表明该变量的当前值；</strong></p>
<p><strong>页面下方的Variables框中则会显示更为详细的变量信息</strong>，包括变量值，变量具有的属性和方法等；</p>
<p>并且Variables框的左侧有一列按钮可以对变量进行其他操作，<strong>最常用的就是添加要Watch的变量</strong>，比如我想查看<code>args</code>的长度，就可以点击黄色框中的加号，输入<code>len(args)</code>即可， 如下图</p>
<ol>
<li><strong>调试窗口&#x2F;输出窗口：</strong></li>
</ol>
<p>开启调试后默认页面就处在<code>Debugger</code>调试窗口下，但如果程序中存在打印输出的内容，则需要点击<code>Console</code>按钮，切换到输出窗口才可以看到输出内容。</p>
<ol>
<li><strong>调试操作按钮</strong></li>
</ol>
<p>调试时最主要的几个按钮如下图所示</p>
<ol>
<li>继续调试，在12行断点处点击Step Over按钮，会发现程序抛出了异常，如下图：</li>
</ol>
<p>这个错误的含义是<strong>数组的下标超出了范围</strong>，从上一步可以看出<code>args = [&#39;./main.py&#39;]</code>，<code>args</code>的长度只有1，但12行却要访问<code>args[1]</code>，表示访问<code>args</code>的第二个元素，很明显会<strong>发生数组越界</strong>，所以程序抛出了异常。</p>
<p><strong>这里要求我们通过命令行传入一个参数，但我们目前是直接使用Pycharm的调试按钮启动的程序，如何输入自定义参数呢</strong>？如下图</p>
<p><strong>上图中的红框处可以输入参数</strong>，相当于命令行执行时<code>python main.py</code>后面的内容，所以这里输入3，等价于<code>python main.py 3</code></p>
<ol>
<li><p>步入函数，现在输入参数后就可以在12行处点击Step Into或者Step Into MyCode按钮进入函数中</p>
</li>
<li><p><strong>一直点击Step Over一行一行执行函数</strong>，可以看到当前行执行到第7行，IDE显示第一次循环的<code>i = 0</code>， 计算得到的<code>tmp = 0</code></p>
</li>
<li><p>直接点击<strong>Run to Cursor</strong>，可以执行代码到光标处，因为当前代码执行到了第7行，<strong>光标默认位于此处</strong>，所以点击Run to Cursor可以直接执行下一次循环到此处，<strong>不用点击多次Step Over</strong>。</p>
</li>
</ol>
<p>当想要直接结束所处函数的执行，可以点击<strong>Step Out</strong>，便会<strong>执行完函数并返回至上一层</strong></p>
<ol>
<li><strong>如果存在多个断点的情况</strong>，可以直接点击左下角框选的按钮，则会跳转到下一个最近的断点处，如果当前断点之后没有断点则会直接运行完剩余程序。</li>
</ol>
<h2 id="Flask示例"><a href="#Flask示例" class="headerlink" title="Flask示例"></a><strong>Flask示例</strong></h2><p>前几天有个朋友提了一个问题，正好可以来为大家演示一下，当<strong>不了解程序内部实现时</strong>如何使用Pycharm进行代码调试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> <span class="title class_">Flask</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = <span class="title class_">Flask</span>(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_">run</span>()</span><br></pre></td></tr></table></figure>

<p>上面的代码是一段最为简单的启动Flask项目的示例代码</p>
<blockquote>
<p>Tips：Flask是使用Python编写的轻量级Web框架，马上我们会出相应的专题</p>
</blockquote>
<p>第二行<code>app = Flask(__name__)</code>的作用是创建一个应用对象实例。</p>
<p>app是Flask的实例，它接收包或者模块的名字作为参数，但一般都是传递(<code>__name__</code>)，让<code>flask.helpers.get_root_path</code>函数通过传入这个名字确定程序的根目录，以便获得静态文件和模板文件的目录。</p>
<p><strong>现在我们使用代码调试试图看看Flask是如何根据</strong><code>**__name__**</code><strong>确定程序根目录的。</strong></p>
<p>在app初始化处加入断点，然后点击Debug开启调试</p>
<p>现在点击<strong>Step Into</strong>跳进<code>Flask()</code>函数中</p>
<p>由上图可以看出，<strong>Flask类继承了Scaffold类</strong>，并且我们当前处于<code>super().__init__()</code>这一行，<strong>这一行表示对父类进行初始化</strong>，所以再次点击<strong>Step Into</strong>步入父类中（由于此处函数参数过长，代码存在换行，所以需要点击多次步入按钮，直到跳入父类中即可）。</p>
<p>由上图可知，现在已经进入到Flask的父类Scaffold的初始化函数中，并且我又点击了几次<strong>Step Over</strong>，直到运行到上图所在行。</p>
<p>这里就是<strong>对项目根目录的确定逻辑</strong>，由于我们在初始化app时没有传入<code>root_path</code>参数，所以当前root_path为None，这样就会用到<code>flask.helpers.get_root_path()</code>根据传入的<code>import_name</code>来确定项目根目录。</p>
<p>而<code>import_name</code>就是初始化类时传入的<code>__name__</code>。至于<code>get_root_path()</code>函数中<strong>具体如何实现的就留给大家自己探索</strong>。</p>
<h2 id="总结】"><a href="#总结】" class="headerlink" title="总结】"></a><strong>总结】</strong></h2><p>IDE的调试功能十分强大，毋庸置疑，如果能够合理运用，<strong>一定会在学习之路上让大家事半功倍</strong>，VSCode的调试方法我这里没有提到，如果有使用VSCode的朋友想了解它的调试方法，也可以在公众号给我留言，我也会出一篇详细的讲解。</p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>0.7 自动化运维番外-迭代器生成器</title>
    <url>/posts/f3a52318.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>在之前的文章中我们提到过很多次的<strong>可迭代对象</strong>，并且很多面试中对于Python几乎必问的一个问题是：“<strong>请解释一下迭代器和生成器？</strong>”</p>
<p>在Python中对象是否可迭代是一个十分重要的特性，今天就一次性的给大家讲解清楚究竟什么是<strong>可迭代</strong>，如何判断一个对象是否是可迭代的，什是<strong>迭代器</strong>，以及什么是又<strong>生成器</strong>？</p>
<span id="more"></span>

<p>下图可以清晰的表示<strong>可迭代对象， 迭代器， 生成器</strong>之间的关系：</p>
<p><img src="https://s2.loli.net/2023/04/08/GAbRtosKkmP6N2a.png" alt="img"></p>
<h2 id="可迭代对象（Iterable）"><a href="#可迭代对象（Iterable）" class="headerlink" title="可迭代对象（Iterable）"></a><strong>可迭代对象（Iterable）</strong></h2><p><strong>可迭代对象的概念比迭代器要广很多，从上图可以看到，可迭代对象包括迭代器，而生成器又是一种特殊的迭代器。</strong></p>
<p>通俗的讲<strong>可以通过for循环遍历的对象都是可迭代对象</strong>。</p>
<p>准确的讲，<strong>一个实现了</strong><code>**__iter__**</code><strong>()&#96;方法的对象就是可迭代对象</strong>，判断一个对象是不是可迭代，有两种方法：</p>
<p>1.通过<code>dir</code>函数获取某个对象的所有属性和方法，只要这个对象实现了<code>__iter()__</code>方法，那么它就是可迭代对象, 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 [..., &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;,...]</span></span><br></pre></td></tr></table></figure>

<p>2.通过<code>isinstance()</code>函数，判断一个对象是否是<code>Iterable</code>类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], Iterable))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 True</span></span><br></pre></td></tr></table></figure>

<p><strong>既然可以被for循环遍历的对象就是可迭代对象，那是否可迭代对象都可以通过for循环遍历呢？</strong></p>
<p>现在可以自己定义一个可迭代对象做一下验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIter</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_iter = MyIter()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(my_iter, Iterable))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_iter:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 TypeError: iter() returned non-iterator of type &#x27;NoneType&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上述代码证明<strong>不是所有的可迭代对象都可以被for循环遍历，前提是必须正确的实现</strong><code>**__iter__()**</code><strong>方法，让可迭代对象返回一个迭代器</strong>。</p>
<p>所以看到这里大家可以认为，<strong>for循环遍历的对象必须是一个可以返回迭代器的可迭代对象</strong>。</p>
<h2 id="迭代器对象（iterator）"><a href="#迭代器对象（iterator）" class="headerlink" title="迭代器对象（iterator）"></a><strong>迭代器对象（iterator）</strong></h2><p>上面已经介绍过，一个可迭代对象要正确的实现<code>__iter__()</code>方法让其返回一个迭代器，最终才可以被for循环遍历。</p>
<p>那么究竟要返回一个什么样的东西才叫迭代器呢？</p>
<blockquote>
<p><strong>官方定义如下：</strong></p>
</blockquote>
<ol>
<li><blockquote>
<p>迭代器是一个对象，该对象代表了一个数据流。</p>
</blockquote>
</li>
<li><blockquote>
<p>重复调用迭代器的<code>__next__</code>方法（或将迭代器对象当作参数传入內置函数next()中）将依次返回数据流中的元素。</p>
</blockquote>
</li>
<li><blockquote>
<p>当数据流中无可返回元素时，则抛出StopIteration异常。</p>
</blockquote>
</li>
<li><blockquote>
<p>迭代器必须拥有<code>__iter__</code>方法，该方法返回迭代器对象自身</p>
</blockquote>
</li>
</ol>
<p>通俗的讲就是迭代器对象必须同时实现<code>__iter__()</code>方法和<code>__next()__</code>方法。</p>
<p>for循环在遍历一个可迭代对象的时候，底层机制为</p>
<ol>
<li>先调用其<code>__iter__()</code>方法获取到其对应的迭代器对象；</li>
<li>并不断调用迭代器对象的<code>__next__()</code>方法获取下一个元素；</li>
<li>最终遇到StopIteration异常结束</li>
</ol>
<h3 id="列表是迭代器吗？"><a href="#列表是迭代器吗？" class="headerlink" title="列表是迭代器吗？"></a><strong>列表是迭代器吗？</strong></h3><p>这里有一个重要的问题需要大家思考一下：<strong>列表可以被for循环遍历，那列表是不是迭代器呢？</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for循环遍历list的代码如下：</span></span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_list:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 1， 2， 3</span></span><br></pre></td></tr></table></figure>

<p>按照官方的迭代器的定义，我们只需要做如下操作就可以验证列表是不是迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">next</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 TypeError: &#x27;list&#x27; object is not an iterator</span></span><br></pre></td></tr></table></figure>

<p>答案很明显，<strong>list并不是一个迭代器</strong>，我们进一步看看list具有哪些属性和方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 [&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__delitem__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getitem__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__iadd__&#x27;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;__imul__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__reversed__&#x27;, &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;__setitem__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;append&#x27;, &#x27;clear&#x27;, &#x27;copy&#x27;, &#x27;count&#x27;, &#x27;extend&#x27;, &#x27;index&#x27;, &#x27;insert&#x27;, &#x27;pop&#x27;, &#x27;remove&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>可以很清楚的看到，list并没有实现<code>__next__()</code>方法，所以它不是一个迭代器。</p>
<p><strong>在使用for循环对list进行遍历的时候，是Python底层调用了</strong><code>**iter()**</code><strong>方法，帮我们获取到了list对应的迭代器</strong>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>(my_list))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 &lt;list_iterator object at 0x7fccb81ca7c0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_list.__iter__())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 &lt;list_iterator object at 0x7fccb81ca7c0&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么list对应的迭代器又实现了哪些属性和方法呢：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>(<span class="built_in">iter</span>(my_list))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 [&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__length_hint__&#x27;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;__lt__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__next__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__setstate__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>显而易见，list对应的迭代器对象实现了<code>__next__()</code>方法，所以可以验证一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter = my_list.__iter__()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__()</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__()</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__()</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__()</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出：</p>
<ul>
<li>我们可以对<code>my_list</code>通过<code>__iter__()</code>返回的迭代器对象执行<code>__next__()</code>方法</li>
<li>并且每次对<code>my_iter</code>执行<code>__next__()</code>方法后，<code>my_iter</code>都会发生变化，但<code>my_list</code>却是不变的</li>
</ul>
<p><strong>综上，for循环遍历list其实本质在做的事情如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_iter = <span class="built_in">iter</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(my_iter))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 1， 2， 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iter(my_iter) 等价于 my_list.__iter__()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># next(my_iter) 等价于 my_iter.__next__()</span></span><br></pre></td></tr></table></figure>

<p><strong>所以最终可以得出的结论是：</strong></p>
<ol>
<li>for循环遍历的并不是可迭代对象本身，而是其对应的迭代器对象</li>
<li>可迭代对象对应的迭代器对象遍历结束后就会失效，无法回到起始位置</li>
<li>可以多次对可迭代对象进行遍历，是因为每次都会调用<code>iter()</code>方法生成该可迭代对象的新的迭代器对象</li>
</ol>
<h3 id="迭代器的优点："><a href="#迭代器的优点：" class="headerlink" title="迭代器的优点："></a><strong>迭代器的优点：</strong></h3><p><strong>迭代器最大的好处就是节省内存</strong></p>
<p>在Python中，文件对象也是一个迭代器，我们可以做如下验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f = open(<span class="string">&quot;test.txt&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">dir</span>(f)</span></span><br><span class="line"></span><br><span class="line">[&#x27;_CHUNK_SIZE&#x27;, &#x27;__class__&#x27;, &#x27;__del__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__enter__&#x27;, &#x27;__eq__&#x27;, &#x27;__exit__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__next__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;_checkClosed&#x27;, &#x27;_checkReadable&#x27;, &#x27;_checkSeekable&#x27;, &#x27;_checkWritable&#x27;, &#x27;_finalizing&#x27;, &#x27;buffer&#x27;, &#x27;close&#x27;, &#x27;closed&#x27;, &#x27;detach&#x27;, &#x27;encoding&#x27;, &#x27;errors&#x27;, &#x27;fileno&#x27;, &#x27;flush&#x27;, &#x27;isatty&#x27;, &#x27;line_buffering&#x27;, &#x27;mode&#x27;, &#x27;name&#x27;, &#x27;newlines&#x27;, &#x27;read&#x27;, &#x27;readable&#x27;, &#x27;readline&#x27;, &#x27;readlines&#x27;, &#x27;reconfigure&#x27;, &#x27;seek&#x27;, &#x27;seekable&#x27;, &#x27;tell&#x27;, &#x27;truncate&#x27;, &#x27;writable&#x27;, &#x27;write&#x27;, &#x27;write_through&#x27;, &#x27;writelines&#x27;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(f)</span></span><br><span class="line"></span><br><span class="line">&lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from collections import Iterator</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance(f, Iterator)</span></span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>既然文件对象也是一个迭代器，那我们假设一个场景：此时有一个很大的文本文件需要读取，常规的做法是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">    data = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line"></span><br><span class="line">     <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>上述代码可以将文件内容全部读取出来，并按行保存为数组赋值给<code>data</code>，那么可想而知当文件内容很多时，data就会占用很大的内存。</p>
<p>但我们可以运用迭代器的性质来很好的做出优化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>因为文件对象<code>f</code>是一个迭代器，所以理所当然可以对其使用for循环遍历。</p>
<p>而for循环遍历时第一步就是调用<code>iter()</code>函数获取到<code>f</code>到迭代器对象（此处f到迭代器对象就是自身），接下来就是每次循环的时候调用<code>__next__()</code>函数来获取下一行。</p>
<p>所以利用迭代器可以很大程度的节省内存，<strong>只有在调用</strong><code>**next()**</code><strong>方法时才会去获取下一个元素，这样可以避免一次性的加载很大的对象导致占用内存过多，而是在需要时才进行惰性计算</strong></p>
<h2 id="生成器对象（Generator）"><a href="#生成器对象（Generator）" class="headerlink" title="生成器对象（Generator）"></a><strong>生成器对象（Generator）</strong></h2><p>从开头的图中大家已经可以看出来，生成器是一种特殊的迭代器。</p>
<h3 id="至于为什么叫生成器？"><a href="#至于为什么叫生成器？" class="headerlink" title="至于为什么叫生成器？"></a><strong>至于为什么叫生成器？</strong></h3><p>主要是因为生成器函数并没有一次性将所有的元素都返回，而是每调用<code>__next__()</code>方法一次，生成一个元素，顾名思义叫做生成器。</p>
<h3 id="那这不就是迭代器吗？"><a href="#那这不就是迭代器吗？" class="headerlink" title="那这不就是迭代器吗？"></a><strong>那这不就是迭代器吗？</strong></h3><p>确实生成器就是一种迭代器，它具有迭代器所有的特点，只不过在Python中<strong>更轻量，更优雅</strong>，生成器主要有两种形式：</p>
<ol>
<li>通过函数创建，称作generator function</li>
<li>通过推导式创建，例如g&#x3D;(x<em>2 for x in range(10))，称作generator expression</em>*</li>
</ol>
<p>生成器对象是一种特殊的Iterator函数，它会在执行过程中保存执行的上下文环境，并在下次循环中从<strong>yield</strong>语句后继续执行，</p>
<p><strong>生成器的标志就是yield关键字。</strong></p>
<h3 id="所以生成器和迭代器最大的区别就是："><a href="#所以生成器和迭代器最大的区别就是：" class="headerlink" title="所以生成器和迭代器最大的区别就是："></a><strong>所以生成器和迭代器最大的区别就是</strong>：</h3><p>迭代器是一种宽泛的概念，大家可以将其理解为一种抽象的描述，平时我们并不会感知到，因为大多数的迭代器都有Python内置方法帮我们实现了，而生成器就是平时编程过程中经常会使用到的一种迭代器而已。</p>
<h2 id="终极示例"><a href="#终极示例" class="headerlink" title="终极示例"></a><strong>终极示例</strong></h2><p>这里给大家分别用普通方法，迭代器以及生成器三种方式实现求解斐波那契数列，并遍历从1到100000点结果：</p>
<h3 id="传统方式："><a href="#传统方式：" class="headerlink" title="传统方式："></a><strong>传统方式：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci_fun</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    numlist = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num-<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">        numlist.append(numlist[-<span class="number">2</span>]+numlist[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numlist[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">res = fibonacci_fun(<span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<h3 id="迭代器："><a href="#迭代器：" class="headerlink" title="迭代器："></a><strong>迭代器：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fibonacci_Iterator</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,counts</span>):</span><br><span class="line"></span><br><span class="line">        self.start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.end = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self.counts = counts</span><br><span class="line"></span><br><span class="line">        self.time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.time &gt;= self.counts:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            self.time += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            self.start,self.end = self.end,self.start + self.end</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> self.start</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">f_iter = Fibonacci_Iterator(<span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f_iter:</span><br><span class="line"></span><br><span class="line">     <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<h3 id="生成器："><a href="#生成器：" class="headerlink" title="生成器："></a><strong>生成器：</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci_generator</span>(<span class="params">counts</span>):</span><br><span class="line"></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    end = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(counts):</span><br><span class="line"></span><br><span class="line">        start,end = end,end+start</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f_gene = fibonacci_generator(<span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f_gene:</span><br><span class="line"></span><br><span class="line">     <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>大家可以从上面的代码中看出：</p>
<p>**1.**传统方法求遍历解时需要一次性算出所有的元素，并将其保存在一个列表中返回；</p>
<p>**2.**迭代器求解遍历时只会在for循环每次隐式调用<code>__next__()</code>方法时才求解；</p>
<p>**3.**生成器的实现则最为优雅，代码执行到yield会暂停，把结果返回出来，再次隐式调用<code>__next__()</code>启动生成器的时候会在暂停的位置继续往下执行</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>关于可迭代对象，迭代器，生成器的讲解在我看来是<strong>刚接触Python时最为难理解的部分</strong>，这篇文章也只是较为粗浅给大家讲解，相信大家会在后续的编程中会对今天的概念有更为深刻的理解和运用。</p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>迭代器</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>0.8 自动化运维番外篇-Python装饰器</title>
    <url>/posts/b73e3867.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>大多数编程语言都提供了一些<strong>奇技淫巧</strong>，通常叫做<strong>语法糖</strong>，对于语法糖的定义如下：</p>
<ol>
<li>计算机语言中特殊的某种语法</li>
<li>这种语法对语言的功能并没有影响</li>
<li>对于编程人员有更好的易用性</li>
<li>能够增加程序的可读性</li>
</ol>
<p>Python中同样也有很多语法糖，比如：<strong>列表推导式，with上下文管理器，装饰器</strong>等。其中装饰器是一个十分重要的特性，并且在之前面向对象章节中类的讲解，以及Flask框架的讲解中，也都或多或少使用过装饰器。</p>
<p><strong>今天这一章节，就来着重给大家讲解一个Python中的装饰器。</strong></p>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><p>装饰器是从<strong>Decorator</strong>直译而来，它可以<strong>在不改变一个函数代码和调用方式的情况下给函数添加新的功能。</strong></p>
<p>装饰器本质上是一个闭包函数，它接受被装饰的函数(func)作为参数，并返回一个包装过的函数。这样我们可以在不改变被装饰函数的代码的情况下给被装饰函数或程序添加新的功能。</p>
<p>Python的装饰器广泛应用于缓存、权限校验(如Flask中的@login_required和@permission_required装饰器)、性能测试(比如统计一段程序的运行时间)和插入日志等应用场景。</p>
<p><strong>有了装饰器，我们就可以抽离出大量与函数功能本身无关的代码，增加一个函数的重用性。</strong></p>
<p>先看一个最简单的装饰器例子，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">        start = time.time()</span><br><span class="line"></span><br><span class="line">        func(num)</span><br><span class="line"></span><br><span class="line">        end = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s cost %f seconds&quot;</span> % (func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    time.sleep(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    foo(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行程序后输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># foo cost 3.000634 seconds</span></span><br></pre></td></tr></table></figure>

<p>上述代码中的<code>timer</code>函数就是一个装饰器函数，它接收另外一个函数作为参数，并统计其运行的时间。</p>
<p><code>foo</code>函数是定义的一个示例函数，在其定义语句上面增加一行<code>@timer</code>就是给它增加了一个装饰器。</p>
<p><strong>所以@其实就是Python中装饰器的语法糖。</strong></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h2><p>装饰器函数其实本质上就是一个<strong>闭包函数</strong>，上面代码示例中的<code>timer</code>就是一个闭包函数。</p>
<p><strong>闭包是Python编程一个非常重要的概念</strong>。如果一个函数中定义了一个内函数，且内函数体内引用到了体外的变量，这时外函数通过return返回内函数的引用时，会把定义时涉及到的外部引用变量和内函数打包成一个整体（闭包）返回。</p>
<p>闭包的定义可能会有点儿晦涩难懂，我们通过下面的代码示例详细解释一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">a</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">b</span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line">    inner(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">outer(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为 4</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的<code>inner</code>就是内函数，内函数中定义了一个局部变量<code>b</code>，除此之外还引用到了其函数外部的<code>a</code>变量。</p>
<p><code>a</code>变量本身不属于<code>inner</code>函数的变量作用域，但如果<code>inner</code>函数使用<code>a</code>变量时<strong>无法在自己的局部作用域中找到该变量时</strong>，<strong>会继续向上一层作用域中寻找</strong>，而<code>inner</code>函数的上一层作用域就是<code>outer</code>函数，<code>a</code>变量就是<code>outer</code>函数的参数，所以此时<code>inner</code>函数就找到了<code>a</code>变量。</p>
<p>当调用<code>outer()</code>函数时，其实<code>outer</code>内部又调用了<code>inner</code>函数，但如果在<code>outer</code>函数里不调用<code>inner</code>函数，而是返回<code>inner</code>函数的引用，会有什么效果呢？代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">a</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">b</span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">f = outer(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;function outer.&lt;<span class="built_in">locals</span>&gt;.inner at <span class="number">0x7f9fd8093280</span>&gt;</span><br><span class="line"></span><br><span class="line">inner</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，执行<code>f = outer(2)</code>之后，并没有任何输出结果，内部也没有运行<code>inner</code>函数，而是将<code>inner</code>函数的引用返回了出来，所以<code>f</code>就是<code>inner</code>函数的引用。</p>
<p>如果想要调用<code>inner</code>函数，就需要如下写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">a</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">b</span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">f = outer(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者写成 outer(2)(1)</span></span><br></pre></td></tr></table></figure>

<p>正常情况下，一个函数运行结束的时候，临时变量会被<strong>销毁</strong>，所以上面代码中执行了<code>f = outer(2)</code>，<strong>此时其实outer函数已经执行结束了，所以outer函数中的局部变量a理应被销毁。</strong></p>
<p>但由于我们在<code>outer</code>函数中返回了<code>inner</code>函数的引用，而<code>inner</code>函数又使用了<code>outer</code>函数中的局部变量，所以执行完<code>f = outer(2)</code>后，还不能将被<code>inner</code>函数引用到的变量<code>a</code>销毁，<strong>而是会将outer函数的局部变量同inner函数绑定在一起，并将inner函数返回，以供后续调用。</strong></p>
<p>所以<code>outer</code>函数中最后的<code>return inner</code>做了两件事情:</p>
<p><strong>一件是返回了inner函数的引用</strong></p>
<p><strong>另一件就是暂时保留了被inner函数引用到的外部变量。</strong></p>
<p>综上所述，闭包就是<strong>即使外函数已经结束了，内函数仍然能够使用外函数的临时变量。</strong></p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a><strong>装饰器</strong></h2><p>在了解了闭包之后，就可以开始真正了解Python中的装饰器了。</p>
<p>计算一个函数执行时间的闭包代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">        start = time.time()</span><br><span class="line"></span><br><span class="line">        func(num)</span><br><span class="line"></span><br><span class="line">        end = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s cost %f seconds&quot;</span> % (func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<p><code>timer</code>函数是一个外函数，并接受一个参数<code>func</code>，<code>inner</code>函数是一个内函数，在<code>inner</code>函数中使用了<code>timer</code>的<code>func</code>变量；最终返回了<code>inner</code>函数的引用。</p>
<p>比较特殊的是<code>timer</code>函数可以接受的是一个函数的引用，所以我们可以做如下事情：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    time.sleep(num)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">timer(foo)(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为 foo cost 3.000634 seconds</span></span><br></pre></td></tr></table></figure>

<p><code>timer(foo)(3)</code>这种写法总让人感觉很奇怪，易读性很低，而且编程人员写起来也不优雅。这时候就到了语法糖发挥作用的时候了。</p>
<p>Python中<code>@</code>就是一个语法糖，它的作用就是将被装饰函数的引用当作参数传入装饰函数中，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">        start = time.time()</span><br><span class="line"></span><br><span class="line">        func(num)</span><br><span class="line"></span><br><span class="line">        end = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s cost %f seconds&quot;</span> % (func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    time.sleep(num)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">foo(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为 foo cost 3.000634 seconds</span></span><br></pre></td></tr></table></figure>

<p>所以<code>foo</code>函数被装饰后，在调用<code>foo</code>函数时，会先将<code>foo</code>函数的引用传入了<code>timer</code>函数中，再执行<code>timer</code>函数的返回值，等价于<code>timer(foo)(3)</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><strong>装饰器始终是Python中十分重要的一个语法糖</strong>，可以说随处可见，这一章节主要从实现的角度给大家讲解了一下装饰器，也是希望大家能够在Python提供的便利下，窥见更多实现原理和细节，并且这种深入的理解对以后的编程也会起到很大的作用。</p>
<p>下一章节我会讲解规范的Python代码中是如何使用装饰器的，并且带领大家对更深一步的源码进行阅读，敬请期待。</p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>0.9 自动化运维番外篇-Python装饰器-进阶</title>
    <url>/posts/bbbab255.html</url>
    <content><![CDATA[<hr>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>通过上一章节闭包函数和简单装饰器的讲解，大家应该能够理解Python中的装饰器的运行原理是怎样的了，这一节就需要讲解一些进阶的知识，并将功能进行泛化，使其更具有<strong>通用性和严谨性</strong>。</p>
<span id="more"></span>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变参数</strong></h2><p>可以先思考一下，上节示例代码中的<code>foo</code>函数只接受一个<code>num</code>参数，那我们定义的<code>timer</code>装饰器<strong>岂不是不能用来去装饰其他函数了</strong>？</p>
<p>这里就需要和可变参数进行结合（可变参数的讲解可以跳转到<a href="https://xzsh9e8v26.feishu.cn/docs/doccnHQr7HdMecZtoANNXw9apFc">自动化运维番外篇-Python参数</a> 中了解），代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;doc of inner&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        start = time.time()</span><br><span class="line"></span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        end = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s cost %f seconds&quot;</span> % (func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<p>上述代码就是修改之后可以用来装饰所有函数的一个装饰器</p>
<ol>
<li>因为<code>inner</code>函数接受的是可变的位置参数和关键字参数，所以理论上就可以接受任意被装饰函数的任意参数。</li>
<li>同时被装饰的函数可能本身会带有返回值，所以还需要定义一个变量接受它，并将其返回。</li>
</ol>
<h2 id="函数一致性"><a href="#函数一致性" class="headerlink" title="函数一致性"></a><strong>函数一致性</strong></h2><p>当对一个函数使用上述的装饰器进行装饰时，函数的内置变量会发生改变，诸如<code>__name__</code>和<code>__doc__</code>，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;doc of foo&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    time.sleep(num)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo.__name__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo__doc__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下：</span></span><br><span class="line"></span><br><span class="line">inner</span><br><span class="line"></span><br><span class="line">doc of inner</span><br></pre></td></tr></table></figure>

<p>从代码运行结果可以看出，最终的输出与定义的<code>foo</code>函数的内置变量并不相同，原因是经过装饰器的装饰后，<code>foo.__name__</code>等价于<code>timer(foo).__name__</code>，<code>foo.__doc__</code>等价于<code>timer(foo).__doc__</code>。</p>
<p>所以为了保证程序定义和输出的一致性，需要做出一定的修改，Python提供了内置的方法可以应对该现象，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;doc of inner&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        start = time.time()</span><br><span class="line"></span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        end = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s cost %f seconds&quot;</span> % (func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<h3 id="wraps"><a href="#wraps" class="headerlink" title="wraps"></a><strong>wraps</strong></h3><p>这里做出的改动是在内函数<code>inner</code>上加一个Python内置的装饰器<code>wraps</code>，该装饰器的功能就是将<code>func</code>参数的内置属性修改到<code>inner</code>上，使最终返回的<code>inner</code>函数看起来就和<code>func</code>一样，具体的<code>warps</code>的实现可以从源码中看出。</p>
<p><img src="https://s2.loli.net/2023/04/08/oBR2ITwA4itCgz3.png" alt="img"></p>
<p>通过<code>command+单击</code>跳转到<code>wraps</code>函数内部，可以看到<code>warps</code>函数有三个参数，分别如下 ：</p>
<ol>
<li><code>wrapped</code>该参数就是<code>timer</code>中的<code>func</code>，也就是<code>timer</code>要装饰的函数。</li>
<li><code>assigned</code>该参数等于内置的一个全局变量<code>WRAPPER_ASSIGNMENTS</code>，值为<code>(&#39;__module__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__doc__&#39;,&#39;__annotations__&#39;)</code>，这些值就是被装饰函数需要修改的内置属性</li>
<li><code>updated</code>该参数等于内置的另一个全局变量<code>WRAPPER_UPDATES</code>，值为<code>(&#39;__dict__&#39;,)</code>表示要被更新的属性。</li>
</ol>
<h3 id="partial"><a href="#partial" class="headerlink" title="partial"></a><strong>partial</strong></h3><p><code>partial</code>函数翻译过来是叫偏函数，通俗地讲，<strong>调用偏函数就是对一个函数做一些额外的操作，然后再返回该函数的调用</strong>。</p>
<p><strong>这听起来有点儿像装饰器，但其实并不完全相同</strong>。</p>
<p>在官方文档的描述中，这个函数的声明如下：<code>functools.partial(func, *args, **keywords)</code>。</p>
<p>它的作用就是返回一个<code>partial</code>对象，当这个<code>partial</code>对象被调用的时候，就像通过<code>func(*args, **kwargs)</code>的形式来调用<code>func</code>函数一样。如果有额外的 位置参数(<em>args)</em> <strong>或者</strong> 关键字参数(*kwargs) 被传给了这个<code>partial</code>对象，那它们也都会被传递给<code>func</code>函数，如果一个参数被多次传入，那么后面的值会覆盖前面的值。</p>
<p>所以<code>wraps</code>函数其实就是返回了一个<code>partial</code>对象，该对象是对<code>update_wrapper</code>的修饰，会将<code>wraps</code>中的<code>wrapped、assigned、updated</code>参数都传递到<code>update_wrapped</code>中。</p>
<h3 id="update-wrapper"><a href="#update-wrapper" class="headerlink" title="update_wrapper"></a><strong>update_wrapper</strong></h3><p>最后只需要搞懂<code>update_wrapper</code>函数就可以了，现在跳转进去看一下该函数的源码，如下图</p>
<p><img src="https://s2.loli.net/2023/04/08/icp9nrDZ6CsJTLH.png" alt="img"></p>
<p>通过源码可以看出，该函数接收一个<code>wrapper</code>参数，然后通过<code>getattr</code>获取<code>wrapped</code>中的所有<code>assigned</code>属性，然后通过<code>setattr</code>一一设置给<code>wrapper</code>，并且将<code>wrapped</code>函数的<code>__dict__</code>属性全部更新到<code>wrapper</code>的<code>__dict__</code>上（因为一个函数的<code>__dict__</code>是字典类型，所以可以直接通过<code>update</code>方法更新字典），最终返回<code>wrapper</code>函数。</p>
<p>经过<code>update_wrapper</code>函数之后，<code>wrapped</code>函数（即<code>foo</code>函数）的所有内置属性，都会被更新到<code>wrapper</code>函数（即<code>inner</code>函数）上去。</p>
<h3 id="整体理解"><a href="#整体理解" class="headerlink" title="整体理解"></a><strong>整体理解</strong></h3><ol>
<li>对<code>inner</code>函数加上<code>@wraps(func)</code> 的装饰，等价于<code>wraps(func)(inner)</code></li>
<li><code>wraps(func)</code>等价于<code>partial(update_wrapper, wrapped=func, assigned=assigned, updated=updated)</code></li>
<li><code>wraps(func)(inner)</code>等价于<code>partial(update_wrapper, wrapped=func, assigned=assigned, updated=updated)(inner)</code></li>
<li><code>partial(update_wrapper, wrapped=func...)(inner)</code>等价于<code>update_wrapper(inner, wrapped=func, , assigned=assigned, updated=updated)</code></li>
</ol>
<p>所以对<code>inner</code>函数使用进行<code>@wraps(func)</code>装饰后，最终<code>timer</code>函数中的返回的<code>inner</code>函数就会具备<code>func</code>(即<code>foo</code>)的所有属性；这样对<code>foo</code>函数使用<code>@timer</code>进行装饰才可以保证函数信息的一致性。</p>
<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a><strong>带参数的装饰器</strong></h2><p>通过<code>wraps</code>的学习，大家可能已经发现，<code>wraps</code>也是一个装饰器，但它却可以接受额外的参数，而自定义的<code>timer</code>却只能接受被装饰的函数作为参数。</p>
<p>其实我们同样也可以对<code>timer</code>进行修改，将其变成<strong>带参数的装饰器</strong>，方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">timeout=<span class="number">10</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func_log</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;&quot;&quot;doc of inner&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">            start = time.time()</span><br><span class="line"></span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">            end = time.time()</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s cost %f seconds&quot;</span> % (func.__name__, end - start))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> end-start &gt; timeout:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;%s run timeout&quot;</span> % func.__name__)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func_log</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params"><span class="number">5</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">num</span>):</span><br><span class="line"></span><br><span class="line">    time.sleep(num)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    foo(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码经过修改后，<code>timer</code>可以接受一个<code>timeout</code>参数，这个参数默认值为<code>10</code>，表示被装饰的函数如果执行超过10s，则判定为超时异常。</p>
<p>其实带参数的装饰器就是在原先的函数外面又包了一层函数，具体逻辑如下：</p>
<ol>
<li>调用<code>foo</code>函数<code>foo()</code>等价于<code>timer(5)(foo)(12)</code></li>
<li><code>timer(5)(foo)(12)</code>等价于<code>func_log(foo)(12)</code></li>
<li><code>func_log(foo)(12)</code>等价于<code>wraper(12)</code></li>
</ol>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a><strong>类装饰器</strong></h2><p>上面的装饰器是由函数来完成，实际上由于Python的灵活性， 用类也可以实现一个装饰器。</p>
<p>类能实现装饰器的功能， 是由于当我们调用一个对象时，实际上调用的是它的 call 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>:</span><br><span class="line"></span><br><span class="line">    __cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line"></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果缓存字典中有这个方法的执行结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 直接返回缓存的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.func.__name__ <span class="keyword">in</span> Cache.__cache:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Cache.__cache[self.func.__name__]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算方法的执行结果</span></span><br><span class="line"></span><br><span class="line">        value = self.func()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将其添加到缓存</span></span><br><span class="line"></span><br><span class="line">        Cache.__cache[self.func.__name__] = value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回计算结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Cache</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">long_time_func</span>():</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_time_func())</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;func cost %f seconds&quot;</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_time_func())</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;func cost %f seconds&quot;</span> % (end - start))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容如下</span></span><br><span class="line"></span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">func cost <span class="number">5.004846</span> seconds</span><br><span class="line"></span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">func cost <span class="number">0.000034</span> seconds</span><br></pre></td></tr></table></figure>

<p><strong>上述类装饰器实现的功能就是将函数的调用结果进行缓存</strong>。</p>
<p>由于类装饰器在平时的编程过程中并不多见，所以大家可以先简单理解上述示例代码了解原理即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这可能目前番外篇中最硬核的一次讲解了，其中涉及到的源码都是大家并不常看到的部分。</p>
<p>并且可能有的朋友发现，Python内置的源码，不管是从抽象角度，代码注释规范，参数命名，以及异常处理都十分的优雅，这其实也是阅读源码最大的好处，这会对我们今后的编程起到潜移默化的提升作用。</p>
<p>最后希望大家可以仔细阅读理解这一章节的内容，对Python装饰器能够有一个完整深入的理解。</p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>0.1 自动化运维番外篇-代码整洁之道</title>
    <url>/posts/cab6c8fa.html</url>
    <content><![CDATA[<hr>
<h1 id="第一章：整洁代码"><a href="#第一章：整洁代码" class="headerlink" title="第一章：整洁代码"></a><strong>第一章：整洁代码</strong></h1><h5 id="混乱的代价"><a href="#混乱的代价" class="headerlink" title="混乱的代价"></a><strong>混乱的代价</strong></h5><p>只要你干过两三年编程，就有可能曾被某人的糟糕代码绊倒过，如果你编程不止两三年，也可能被这种代码拖过后腿。进度延缓都程度会很严重。有些团队在项目初期进展迅速，但又那么一两年的时间却慢如蜗行。对代码的每次修改都影响到其他多处代码，最后这团乱麻越来越大，再也无法理清，束手无策。</p>
<p>随着混乱的增加，团队生产力持续下降，趋向于零，管理层只能添加更多人手带项目中，可新人并不清楚系统的设计，也不了解设计意图，而且团队中的其他人都背负着提升生产力的可怕压力，于是制造了更多的混乱。</p>
<h5 id="什么是整洁的代码"><a href="#什么是整洁的代码" class="headerlink" title="什么是整洁的代码"></a><strong>什么是整洁的代码</strong></h5><span id="more"></span>

<p>优雅、艺术</p>
<h1 id="第二章：有意义的命名"><a href="#第二章：有意义的命名" class="headerlink" title="第二章：有意义的命名"></a><strong>第二章：有意义的命名</strong></h1><h5 id="名副其实"><a href="#名副其实" class="headerlink" title="名副其实"></a><strong>名副其实</strong></h5><p>如果名称需要注释来补充，那这个命名就不算是名副其实</p>
<h5 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a><strong>避免误导</strong></h5><p>避免使用与本意相悖的词</p>
<p>避免对不同变量使用外形极为相似的名称</p>
<h5 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a><strong>做有意义的区分</strong></h5><p>要区分名称，就要以读者能鉴别不同之处的方式来区分，accountData与account没区别，theMessage也与message没区别</p>
<h5 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a><strong>使用读得出来的名称</strong></h5><p>命名时避免使用读不出来的傻乎乎的自造词，而是使用恰当的英语词</p>
<h5 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a><strong>使用可搜索的名称</strong></h5><p>单个字母和数字常亮的问题就是很难在一大篇文字中找出来，比如字母e可能出来在任何地方，所以，通常来说，长名称胜于短名称</p>
<h5 id="类名"><a href="#类名" class="headerlink" title="类名"></a><strong>类名</strong></h5><p>类名应当是名词或短语，如Customer，Account</p>
<p>避免使用Manager，Data，Info这样的类名</p>
<p>类名不应该是动词</p>
<h5 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a><strong>方法名</strong></h5><p>方法名应当是动词或动词短语，如postPayment，deletePage</p>
<h5 id="一以贯之"><a href="#一以贯之" class="headerlink" title="一以贯之"></a><strong>一以贯之</strong></h5><p>DeviceManager和ProtoolController之间，为什么不全用Controller或这Manager，所以在程序中，通常命名方式应该一以贯之</p>
<h1 id="第三章：函数"><a href="#第三章：函数" class="headerlink" title="第三章：函数"></a><strong>第三章：函数</strong></h1><h5 id="短小"><a href="#短小" class="headerlink" title="短小"></a><strong>短小</strong></h5><p>函数的第一规则是要短小，第二规则还是要短小</p>
<p>理论上通过抽象更小的函数，可以让函数的缩进层级不多于两层。</p>
<h5 id="只做一件事"><a href="#只做一件事" class="headerlink" title="只做一件事"></a><strong>只做一件事</strong></h5><p>函数应该只做同一抽象层级上的步骤，且只做一件事，</p>
<p>判断函数是否不止做了一件事，可以看是否还能再拆出一个函数，从而改变目前函数的抽象层级。</p>
<h5 id="每个函数一个抽象层级"><a href="#每个函数一个抽象层级" class="headerlink" title="每个函数一个抽象层级"></a><strong>每个函数一个抽象层级</strong></h5><p>让代码读起来像是自顶向下。</p>
<h5 id="使用描述性的名称"><a href="#使用描述性的名称" class="headerlink" title="使用描述性的名称"></a><strong>使用描述性的名称</strong></h5><p>函数越短小，功能越集中，就越便于起一个好名字，更好的描述函数做的事。</p>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h5><p>应尽量避免定义三个以上参数的函数，如果一些函数需要三个及以上的参数，就说明其中一些参数莺歌被封装城类了</p>
<p>函数参数应与函数处于同一个抽象层级，</p>
<p>如果参数多于两个，则对于测试的覆盖会是一个灾难。</p>
<p>避免使用标识参数，例如，函数传入一个bool值，如果为true将这样做，如果为false则那样做，这无异于大声宣布这个函数不止做了一件事；当必须存在这个标识时，应该通过重构，将标识限制在上层范围内。</p>
<h5 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a><strong>无副作用</strong></h5><p>避免在函数中做承诺以外的事，比如对其他变量做出预期外的改动。</p>
<h5 id="将指令与询问分开"><a href="#将指令与询问分开" class="headerlink" title="将指令与询问分开"></a><strong>将指令与询问分开</strong></h5><p>函数要么修改某对象的状态，要么返回该对象的有关信息，两样都干时会导致混乱。</p>
<h5 id="抽离错误处理代码块"><a href="#抽离错误处理代码块" class="headerlink" title="抽离错误处理代码块"></a><strong>抽离错误处理代码块</strong></h5><p>避免把错误处理与正常流程混为一谈，比如把错误处理单独抽离出来，这样代码会更加易于理解和修改。</p>
<h5 id="别重复自己"><a href="#别重复自己" class="headerlink" title="别重复自己"></a><strong>别重复自己</strong></h5><p>某个逻辑被重复多次会导致代码臃肿，且修改时需要修改多处地方。</p>
<h1 id="第四章：注释"><a href="#第四章：注释" class="headerlink" title="第四章：注释"></a><strong>第四章：注释</strong></h1><p>注释存在的时间越久，合理性就越低，没有人可以坚持的维护注释；</p>
<p>当发现自己需要写注释时，想想看是否可以用代码来表达。</p>
<h5 id="注释不能美化糟糕的代码"><a href="#注释不能美化糟糕的代码" class="headerlink" title="注释不能美化糟糕的代码"></a><strong>注释不能美化糟糕的代码</strong></h5><p>写注释的常见动机是糟糕代码的存在。带有少量注释的整洁代码，要比带有大量注释的复杂的代码好得多。</p>
<p>只要多想几秒钟，就可以用代码解释你的大部分意图，简单到只需要创建一个命名与注释所描述的相符的函数即可。</p>
<h1 id="第五章：格式"><a href="#第五章：格式" class="headerlink" title="第五章：格式"></a><strong>第五章：格式</strong></h1><h5 id="空白行"><a href="#空白行" class="headerlink" title="空白行"></a><strong>空白行</strong></h5><p>通过空白行标识出新的逻辑段。</p>
<h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a><strong>函数调用</strong></h5><p>若同一个文件中某个函数调用了另一个函数，那调用方应该放到被调方的上面。</p>
<h5 id="空格"><a href="#空格" class="headerlink" title="空格"></a><strong>空格</strong></h5><p>赋值语句的等号左右两边应该用空格隔开，函数参数之间也应该用空格隔开。</p>
<h5 id="团队规范"><a href="#团队规范" class="headerlink" title="团队规范"></a><strong>团队规范</strong></h5><p>同一个团队中的开发者应该遵守同一种格式风格。</p>
<h1 id="第六章：对象和数据结构"><a href="#第六章：对象和数据结构" class="headerlink" title="第六章：对象和数据结构"></a><strong>第六章：对象和数据结构</strong></h1><p>对象暴露行为，隐藏数据，便于添加新对象类型而无需修改既有行为，但同时难以再既有对象中添加新行为。</p>
<p>数据结构暴露数据，没有明显的行为，便于向既有数据结构添加新行为，同时难以向既有函数添加新数据结构。</p>
<p>在任何系统中，我们有时希望能够灵活的添加新数据类型，所以更喜欢在这部分使用对象，在另外一些时候，我们希望能灵活的添加新行为，这时我们更喜欢使用数据类型和过程。</p>
<h1 id="第七章：错误处理"><a href="#第七章：错误处理" class="headerlink" title="第七章：错误处理"></a><strong>第七章：错误处理</strong></h1><p>错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。</p>
<h5 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a><strong>抛出异常</strong></h5><p>在支持抛出异常的编程语言中尽量在遇到错误时跑出异常，而不是返回一个错误码。</p>
<h5 id="适当使用不可控异常"><a href="#适当使用不可控异常" class="headerlink" title="适当使用不可控异常"></a><strong>适当使用不可控异常</strong></h5><p>尽量避免在上层抽象中明确的捕获底层的错误类型，如果底层函数发生了修改，返回了新的异常类型，则上层函数需要全部修改去新增对应异常类型的捕获逻辑，这种做法明显破坏了代码的封装性。</p>
<h5 id="异常细节"><a href="#异常细节" class="headerlink" title="异常细节"></a><strong>异常细节</strong></h5><p>任何捕获异常的地方都要明确给出异常的上下文信息。</p>
<h5 id="异常封装"><a href="#异常封装" class="headerlink" title="异常封装"></a><strong>异常封装</strong></h5><p>当需要捕获被调函数多个不同类型的异常时，为了避免冗余的代码以及后续由于被调函数异常的修改而去改动多处代码，尽量将可能抛出的多个异常封装成一个异常类。</p>
<h5 id="抛出异常而不是返回null值"><a href="#抛出异常而不是返回null值" class="headerlink" title="抛出异常而不是返回null值"></a><strong>抛出异常而不是返回null值</strong></h5><p>避免返回null值，如果你打算在方法中返回null值不如抛出异常或返回特例对象；如果你调用的第三方API中可能返回null值，则可以考虑用新方法打包这个调用，在新方法中抛出异常或返回特例对象；否则返回null值基本上就是给自己增加工作量，也是在给调用者添乱，只要有一处没检查null值，应用程序就会失控。</p>
<h5 id="避免传入null值"><a href="#避免传入null值" class="headerlink" title="避免传入null值"></a><strong>避免传入null值</strong></h5><p>避免在方法参数中传入null值，虽然可以在方法中对参数做null值校验，但禁止传入null值可以避免出现很多无心之失。</p>
<h1 id="第八章：边界"><a href="#第八章：边界" class="headerlink" title="第八章：边界"></a><strong>第八章：边界</strong></h1><h5 id="避免暴露边界"><a href="#避免暴露边界" class="headerlink" title="避免暴露边界"></a><strong>避免暴露边界</strong></h5><p>当使用第三方代码的边界接口时，避免直接使用其API的返回值，而是将其进行封装，以便于对应用程序隐藏边界接口，并且能够后续做出更灵活的修改。</p>
<h5 id="保留未知"><a href="#保留未知" class="headerlink" title="保留未知"></a><strong>保留未知</strong></h5><p>当使用部分细节未知的边界接口时，最好的做法同样是将其进行封装，这样可以尽量避免不被未知的部分所困扰。</p>
<h1 id="第九章：测试"><a href="#第九章：测试" class="headerlink" title="第九章：测试"></a><strong>第九章：测试</strong></h1><h5 id="避免出现脏测试"><a href="#避免出现脏测试" class="headerlink" title="避免出现脏测试"></a><strong>避免出现脏测试</strong></h5><p>测试代码和生产代码一样重要，脏测试&#x3D;没测试，测试代码必须随着生产代码的演进而修改，否则测试代码越乱，就越需要花更多的时间加入新的测试。</p>
<h5 id="测试规则"><a href="#测试规则" class="headerlink" title="测试规则"></a><strong>测试规则</strong></h5><p>测试代码要遵循 构造-操作-检验 三个步骤。</p>
<h1 id="第十章：类"><a href="#第十章：类" class="headerlink" title="第十章：类"></a><strong>第十章：类</strong></h1><h5 id="短小-1"><a href="#短小-1" class="headerlink" title="短小"></a><strong>短小</strong></h5><p>类应该保持短小，并不是指代码行数，而是指“权责”。</p>
<h5 id="单一权责原则"><a href="#单一权责原则" class="headerlink" title="单一权责原则"></a><strong>单一权责原则</strong></h5><p>系统应该由许多短小的类而不是少量巨大的类组成，每个小类封装一个权责，并与其他类一起协同达到期望的目的。</p>
<h5 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a><strong>内聚</strong></h5><p>类应该只有少数的内置变量，类中的方法应该和变量相互依赖并结合成一个逻辑整体。</p>
<p>保持内聚性有利于得到一个短小的类</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h5><p>具体类包含实现细节，而抽象类则只呈现概念，依赖于具体细节的实现类，我们可以借助接口和抽象类来隔离这些细节带来的影响。</p>
<h1 id="第十一章：系统"><a href="#第十一章：系统" class="headerlink" title="第十一章：系统"></a><strong>第十一章：系统</strong></h1><h1 id="第十二章：迭代"><a href="#第十二章：迭代" class="headerlink" title="第十二章：迭代"></a><strong>第十二章：迭代</strong></h1><h5 id="运行所有的测试"><a href="#运行所有的测试" class="headerlink" title="运行所有的测试"></a><strong>运行所有的测试</strong></h5><p>全面测试并是吃通过所有测试的系统，才是可以部署的系统</p>
<h5 id="尽可能减少类和方法的数量"><a href="#尽可能减少类和方法的数量" class="headerlink" title="尽可能减少类和方法的数量"></a><strong>尽可能减少类和方法的数量</strong></h5><p>重构过程中，应该时刻关注变化之后的设计，在出现退步时及时消除重复。保证代码的表达力</p>
<h1 id="第十三章：并发编程"><a href="#第十三章：并发编程" class="headerlink" title="第十三章：并发编程"></a><strong>第十三章：并发编程</strong></h1><h5 id="并发防御"><a href="#并发防御" class="headerlink" title="并发防御"></a><strong>并发防御</strong></h5><p>建议分离并发代码和其他代码；</p>
<p>限制并发数据的作用域；</p>
<p>避免共享数据；</p>
<p>先使非并发代码正常工作</p>
]]></content>
      <categories>
        <category>番外篇</category>
      </categories>
      <tags>
        <tag>代码整洁之道</tag>
      </tags>
  </entry>
</search>
